//*************************************************************************************
//* CALIBRE DRC COMMAND FILE - CLN65S_6M_3X1Z1U.20a 10/16/2009
//* FOR TSMC 65NM/55NM CMOS LOGIC/RF G/GP/LP/LPG/ULP 1P6M PROCESS WITH 3X1Z1U METAL OPTION (WLCSP sealring support version)
//* DESIGN RULE DOCUMENT:      T-N65-CL-DR-001    VER 2.0
//* DRC COMMAND FILE DOCUMENT: T-N65-CL-DR-001-C1 VER 2.0a
//*************************************************************************************

//*************************************************************************************
// TSMC has developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
// The deck is to be used only in Calibre tools.
//*************************************************************************************



//  OPTION SETUP
//================
#DEFINE GUIDELINE_RES     // Turn on to check OD/PO resistor guidelines
#DEFINE CHECK_LATCHUP_BY_PAD_CONNECTION   // Turn off to disable PAD connection method for Latch-Up rule check.
#DEFINE DISCONNECT_AFTER_RESISTOR         // Turn on to break connection after resistor for Latch-Up rule check.
//#DEFINE DEFINE_PAD_BY_TEXT              // Turn on to recognize IO PAD by following text for Latch-Up rules 
  VARIABLE PAD_TEXT  "?"                  // Pin name of PAD
  VARIABLE VDD_TEXT  "VDD?"               // Pin name of VDD
  VARIABLE VSS_TEXT  "VSS?"               // Pin name of VSS 

#DEFINE GUIDELINE_LUP     // Turn on to check Latch-up prevention guidelines
#DEFINE GUIDELINE_ESD     // Turn on to check ESD protection guidelines
//#DEFINE NW_SUGGESTED    // Turn on to use conservative way to check NW.S.3/NW.S.4  
#DEFINE DATATYPE_WARNING  // Turn on to flag NW/OD/PO/CO warning datatype
//#DEFINE MIXED_SCHEME	  // Turn on to allow datatype 0 for M(y,z,r,u)/VIA(y,z,r,u) and datatype 1 for DM(y,z,r,u)
#DEFINE CHECK_LOW_DENSITY // Turn on to check OD/PO/Metal local low density. 
#DEFINE FRONT_END         // Turn on to check Front-End rules
#DEFINE BACK_END          // Turn on to check Back-End rules
#DEFINE FULL_CHIP         // Turn on for chip level design

#DEFINE GP              // Turn on for General-purpose Plus(GP) process
//#DEFINE LP              // Turn on for Low-Power(LP) and Ultra Low-Power(ULP) process
//#DEFINE LPG             // Turn on for Triple-gate-oxide (LPG) process 

//#DEFINE HALF_NODE       // Turn on for N55 process


//#DEFINE 28K_AP          //Turn on for 28K thicknees of AP
  
#DEFINE WLCSP_SEALRING    // Turn on if using WLCSP SEALRING structure


//#DEFINE ChipWindowUsed  // Turn on to specify chip boundary directly by following variables  
VARIABLE xLB   0.0	  // x-coordinate of left-bottom corner for user defined chip window 
VARIABLE yLB   0.0  	  // y-coordinate of left-bottom corner for user defined chip window 
VARIABLE xRT   1000.0	  // x-coordinate of right-top corner for user defined chip window  
VARIABLE yRT   1000.0	  // y-coordinate of right-top corner for user defined chip window 



//  OPTION SETUP OF DFM RULES
//===============================
//#DEFINE DFM             // Turn on to check DFM rules
//#DEFINE DFM_ONLY        // Turn on to check DFM rules only

VARIABLE CellsForRRuleRequired "*"         // include cell in Action-Required rules check 
VARIABLE CellsForRRuleRecommended "*"      // include cell in Recommendations check
VARIABLE CellsForRRuleAnalog " "           // include cell in Analog rules check (default is empty)
VARIABLE CellsForRRuleGuideline "*"        // include cell in Guidleline check
VARIABLE ExclCellsForRRuleRequired " "     // exclude cell from Action-Required rules check
VARIABLE ExclCellsForRRuleRecommended " "  // exclude cell from Recommendations check
VARIABLE ExclCellsForRRuleAnalog " "       // exclude cell from Analog rules check
VARIABLE ExclCellsForRRuleGuideline " "    // exclude cell from Guidleline check

// select by DFM category 
#DEFINE Required         // Turn on to check Action-Required rules
#DEFINE Recommended      // Turn on to check Recommendations
#DEFINE Analog           // Turn on to check Analog Recommendations(must select by layer RRuleAnalog or cell CellsForRRuleAnalog)
#DEFINE Guideline        // Turn on to check Guidelines

// select by DFM Grouping
//#DEFINE First_priority // Turn on to check First priority group 
//#DEFINE Systematic     // Turn on to check Systematic group
//#DEFINE Defect         // Turn on to check Defect group
//#DEFINE SPICE          // Turn on to check SPICE group

// select by each DFM rule respectively
// Action-required rules    
//#DEFINE _POS2_            // Systematic(Litho/OPC/Others) and SPICE related 
//#DEFINE _POEX2_           // Systematic(Others) and SPICE related 
//#DEFINE _POS5_            // Systematic(Litho/OPC) and SPICE related
//#DEFINE _POS14_           // Systematic(Others) and SPICE related
//#DEFINE _POEN1_           // Systematic(Others) and SPICE related
//#DEFINE _POEN2_           // Systematic(Others) and SPICE related
//#DEFINE _POEN3_           // Systematic(Others) and SPICE related
// Recommendations    
//#DEFINE _OPCR1_           // Systematic(Litho/OPC) related 
//#DEFINE _DNWEN1_          // Systematic(Others) related 
//#DEFINE _ODW2_            // SPICE related
//#DEFINE _ODS1_            // Defect related
//#DEFINE _ODS6_            // Systematic(Others) related 
//#DEFINE _NWRODS3_         // SPICE related
//#DEFINE _NWRODR1_         // SPICE related 
//#DEFINE _NWRSTIEN2_       // SPICE related
//#DEFINE _NWRSTIR1_        // SPICE related
//#DEFINE _POS1_            // Defect related
//#DEFINE _POS4_1_          // SPICE related
//#DEFINE _POS11_           // Systematic(Litho/OPC) related
//#DEFINE _POS13_           // Systematic(Litho/OPC) related 
//#DEFINE _RES2_            // SPICE related
//#DEFINE _RES8_            // SPICE related
//#DEFINE _RES9_            // SPICE related
//#DEFINE _COEN1_           // Systematic(Litho/OPC) and SPICE related
//#DEFINE _COEN3_           // Systematic(Litho/OPC) and SPICE related
//#DEFINE _COS3_            // 1st priority, Systematic(Others) and Defect related
//#DEFINE _M1S1_            // Defect related
//#DEFINE _M1S7_            // Systematic(Others) related
//#DEFINE _M1EN1_M1EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _VIA1EN1_VIA1EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _M2S1_            // Defect related
//#DEFINE _M2S7_            // Systematic(Others) related
//#DEFINE _M2EN1_M2EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _VIA2EN1_VIA2EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _M3S1_            // Defect related
//#DEFINE _M3S7_            // Systematic(Others) related
//#DEFINE _M3EN1_M3EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _VIA3EN1_VIA3EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _M4S1_            // Defect related
//#DEFINE _M4S7_            // Systematic(Others) related
//#DEFINE _M4EN1_M4EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
//#DEFINE _DTCDDN1_         // Systematic(Others) related
// Analog Recommendations 
//#DEFINE _POS5m_
//#DEFINE _POS6m_
//#DEFINE _RES5m_           
//#DEFINE _BJTR2_
//#DEFINE _BJTR3_
//#DEFINE _BJTR4_
//#DEFINE _BJTR5_
//#DEFINE _BJTR6_
//#DEFINE _BJTR7_
//#DEFINE _ANR17_
//#DEFINE _ANR20_
// Guidelines
//#DEFINE _OPCR2_           // Systematic(Litho/OPC) related
//#DEFINE _NWR1_            // Systematic(Other) and SPICE related
//#DEFINE _DNWR6_           // Systematic(Other) and SPICE related
//#DEFINE _NWRODR3_NWRSTIR3_ // SPICE related
//#DEFINE _COS6_            // SPICE related  
//#DEFINE _COR5_            // 1st priority, Defect and SPICE related 
//#DEFINE _VIA1R9_          // 1st priority, Defect and SPICE related                       
//#DEFINE _VIA2R9_          // 1st priority, Defect and SPICE related                       
//#DEFINE _VIA3R9_          // 1st priority, Defect and SPICE related                       
//#DEFINE _VIA4R5_          // 1st priority, Defect and SPICE related
//#DEFINE _VIA5R5_          // 1st priority, Defect and SPICE related





//
// ENVIRONMENT SETUP
//------------------

PRECISION    1000
RESOLUTION      5    // For 0.005um layout grid  

LAYOUT SYSTEM GDSII
LAYOUT PATH "GDSFILENAME"
LAYOUT PRIMARY "TOPCELLNAME"

DRC RESULTS DATABASE "DRC_RES.db"
DRC SUMMARY REPORT "DRC.rep"  // HIER
DRC KEEP EMPTY NO
DRC CHECK TEXT ALL
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES

LAYOUT PROCESS BOX RECORD YES
FLAG OFFGRID YES     // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO



//RULES VALUE VARIABLES
//=======================

VARIABLE METAL_LOW_DEN_WINDOW_SIZE 75
VARIABLE METAL_LOW_DEN_WINDOW_STEP 37.5
VARIABLE METAL_HIGH_DEN_WINDOW_SIZE 100
VARIABLE METAL_HIGH_DEN_WINDOW_STEP 50

VARIABLE  GRID      0.005
VARIABLE  OFFSETX   0.001

VARIABLE  DNW_S_1   3.5 
VARIABLE  DNW_S_2   2.5 
VARIABLE  DNW_W_1   3.0 
VARIABLE  DNW_S_3   1.65
VARIABLE  DNW_S_4   1.0 
VARIABLE  DNW_S_5   1.2
VARIABLE  DNW_EN_3  0.56
VARIABLE  DNW_O_1   0.4 


VARIABLE  OD_W_1    0.08 
VARIABLE  OD_W_2    0.12 
VARIABLE  OD_W_3    0.40
VARIABLE  OD_W_4    0.18
VARIABLE  OD_S_1    0.11 
VARIABLE  OD_S_2    0.18 
VARIABLE  OD_S_3_L  0.2 
VARIABLE  OD_S_3_W  0.15
VARIABLE  OD_S_3    0.13
VARIABLE  OD_S_3_1  0.125
VARIABLE  OD_S_4    0.18
VARIABLE  OD_S_5    0.18 
VARIABLE  OD_A_1    0.054 
VARIABLE  OD_A_2    0.085 
VARIABLE  OD_L_1    0.5
VARIABLE  OD_L_1_W  0.15 
VARIABLE  OD_L_2    25.0 
VARIABLE  OD_L_2_W  0.15
VARIABLE  OD_DN_1L   0.25
VARIABLE  OD_DN_1H   0.75
VARIABLE  OD_DN_2L   0.2
VARIABLE  OD_DN_2L_W 150
VARIABLE  OD_DN_2L_S 75
VARIABLE  OD_DN_2L_E 37.5
VARIABLE  OD_DN_2H   0.9
VARIABLE  OD_DN_2H_CORE 0.8
VARIABLE  OD_DN_2H_W 150
VARIABLE  OD_DN_2H_S 75
VARIABLE  OD_DN_2H_E 37.5
VARIABLE  OD_DN_3L   0.2
VARIABLE  OD_DN_3L_W 150
VARIABLE  OD_DN_3L_S 75
VARIABLE  OD_DN_3L_E 37.5
VARIABLE  OD_DN_3H   0.9
VARIABLE  OD_DN_3H_CORE 0.8
VARIABLE  OD_DN_3H_W 150
VARIABLE  OD_DN_3H_S 75
VARIABLE  OD_DN_3H_E 37.5

VARIABLE  NW_W_1    0.47 
VARIABLE  NW_W_2    1.80 
VARIABLE  NW_S_1    0.47 
VARIABLE  NW_S_2    1.00 
VARIABLE  NW_S_3    1.20 
VARIABLE  NW_S_4    1.20 
VARIABLE  NW_S_5    0.16 
VARIABLE  NW_S_6    0.16
VARIABLE  NW_S_7    0.31
VARIABLE  NW_EN_1   0.16
VARIABLE  NW_EN_2   0.16
VARIABLE  NW_EN_3   0.31
VARIABLE  NW_A_1    0.64
VARIABLE  NW_A_2    0.64
VARIABLE  NW_A_3    1.0
VARIABLE  NW_A_3_L  0.8
VARIABLE  NW_A_4    1.0
VARIABLE  NW_A_4_L  0.8

VARIABLE  NWROD_W_1   1.8 
VARIABLE  NWROD_S_1   1.2 
VARIABLE  NWROD_S_2   0.3 
VARIABLE  NWROD_EN_1  1.0 
VARIABLE  NWROD_EN_2  0.3 
VARIABLE  NWROD_O_1   0.4 
VARIABLE  NWRSTI_EN_1 0.4 
VARIABLE  NWRSTI_EN_2 0.3 
VARIABLE  NWRSTI_EN_3 0.3 
VARIABLE  NWRSTI_EX_1 0.3 

VARIABLE  NT_N_W_1    0.47 
VARIABLE  NT_N_S_1    0.47 
VARIABLE  NT_N_S_2    0.38 
VARIABLE  NT_N_S_3    1.20
VARIABLE  NT_N_EX_1   0.35 
VARIABLE  NT_N_A_1    0.64
VARIABLE  NT_N_A_2    0.64
VARIABLE  NT_N_A_3    1.0
VARIABLE  NT_N_A_3_L  0.8
VARIABLE  NT_N_A_4    1.0
VARIABLE  NT_N_A_4_L  0.8
VARIABLE  NT_N_W_2    0.20 
VARIABLE  NT_N_W_2_1  0.30	
VARIABLE  NT_N_W_2_2  0.20      
VARIABLE  NT_N_W_2_2_E  1.0     
VARIABLE  NT_N_W_2_2_M  0.5     
VARIABLE  NT_N_W_2_3  0.2     
VARIABLE  NT_N_W_3    1.20 
VARIABLE  NT_N_W_4    0.8 
VARIABLE  NT_N_W_5    0.5
VARIABLE  NT_N_EN_1_L 0.26
VARIABLE  NT_N_EN_1_H 0.285

VARIABLE  OD2_W_1     0.47 
VARIABLE  OD2_W_2     0.47
VARIABLE  OD2_S_1     0.47 
VARIABLE  OD2_S_2     0.27 
VARIABLE  OD2_S_3     0.34 
VARIABLE  OD2_S_4     0.47 
VARIABLE  OD2_S_5     0.47
VARIABLE  OD2_S_6     0.47
VARIABLE  OD2_S_7     0.47
VARIABLE  OD2_EN_1    0.34 
VARIABLE  OD2_EX_1    0.47 
VARIABLE  OD2_EX_2    0.47 
VARIABLE  OD2_EX_3    0.27 
VARIABLE  OD2_O_1     0.47 

VARIABLE  OD25_33_W_1  0.5 
VARIABLE  OD25_33_W_2  0.4 

VARIABLE  OD25_18_W_1  0.26


VARIABLE  PO_W_1      0.06 
VARIABLE  PO_W_2      0.28
VARIABLE  PO_W_3      0.38 
VARIABLE  PO_W_4      0.20
VARIABLE  PO_W_5      0.19
VARIABLE  PO_W_5_F    0.08
VARIABLE  PO_S_1      0.12 
VARIABLE  PO_S_2      0.13 
VARIABLE  PO_S_2_1    0.15 
VARIABLE  PO_S_2_1_W  0.09 
VARIABLE  PO_S_3      0.25 
VARIABLE  PO_S_4      0.05 
VARIABLE  PO_S_4_1    0.15 
VARIABLE  PO_S_4_1_A  0.0121 
VARIABLE  PO_S_5      0.10 
VARIABLE  PO_S_5_W    0.15 
VARIABLE  PO_S_6      0.10 
VARIABLE  PO_S_6_W    0.15 
VARIABLE  PO_S_7      0.18 
VARIABLE  PO_S_7_L    0.18 
VARIABLE  PO_S_7_W    0.13 
VARIABLE  PO_S_9      0.25 
VARIABLE  PO_S_10     0.14
VARIABLE  PO_S_10_Q   0.09  
VARIABLE  PO_S_10_E   0.035 
VARIABLE  PO_EX_1     0.14 
VARIABLE  PO_EX_2     0.115
VARIABLE  PO_EX_3     0.16
VARIABLE  PO_EX_3_W   0.15 
VARIABLE  PO_EX_3_S   0.10
VARIABLE  PO_L_1      25.0
VARIABLE  PO_L_1_W    0.13 
VARIABLE  PO_A_1      0.042 
VARIABLE  PO_A_1_1    0.051
VARIABLE  PO_A_2      0.094
VARIABLE  PO_DN_1_L   0.14
VARIABLE  PO_DN_1_H   0.40
VARIABLE  PO_DN_2     0.001 
VARIABLE  PO_DN_2_W   20
VARIABLE  PO_DN_2_S   10
VARIABLE  PO_DN_2_E   5
VARIABLE  PO_DN_3     0.14
VARIABLE  PO_R_6_U    0.425
VARIABLE  PO_R_6_V    0.11
VARIABLE  PO_R_6_W    0.255
VARIABLE  PO_R_6_X    0.065
VARIABLE  PO_S_15      1.0
VARIABLE  PO_S_15_L    0.08
VARIABLE  PO_S_15_A    630
VARIABLE  PO_S_15_DN   0.7
VARIABLE  PO_S_16      0.19

VARIABLE  VTH_N_W_1   0.18
VARIABLE  VTH_N_S_1   0.18 
VARIABLE  VTH_N_S_2   0.16 
VARIABLE  VTH_N_S_2_1 0.185 
VARIABLE  VTH_N_S_3   0.22
VARIABLE  VTH_N_EN_1  0.185 
VARIABLE  VTH_N_EN_2  0.16 
VARIABLE  VTH_N_A_1   0.27 
VARIABLE  VTH_N_A_2   0.27 
VARIABLE  VTH_N_R_2   0.4

VARIABLE  VTH_P_W_1   0.18
VARIABLE  VTH_P_S_1   0.18 
VARIABLE  VTH_P_S_2   0.16 
VARIABLE  VTH_P_S_2_1 0.185 
VARIABLE  VTH_P_S_3   0.22
VARIABLE  VTH_P_EN_1  0.185 
VARIABLE  VTH_P_EN_2  0.16 
VARIABLE  VTH_P_A_1   0.27 
VARIABLE  VTH_P_A_2   0.27 
VARIABLE  VTH_P_R_2   0.4

VARIABLE  VTL_N_W_1   0.18
VARIABLE  VTL_N_S_1   0.18 
VARIABLE  VTL_N_S_2   0.16 
VARIABLE  VTL_N_S_2_1 0.185 
VARIABLE  VTL_N_S_3   0.22
VARIABLE  VTL_N_EN_1  0.185 
VARIABLE  VTL_N_EN_2  0.16 
VARIABLE  VTL_N_A_1   0.27 
VARIABLE  VTL_N_A_2   0.27 
VARIABLE  VTL_N_R_2   0.4

VARIABLE  VTL_P_W_1   0.18
VARIABLE  VTL_P_S_1   0.18 
VARIABLE  VTL_P_S_2   0.16 
VARIABLE  VTL_P_S_2_1 0.185 
VARIABLE  VTL_P_S_3   0.22
VARIABLE  VTL_P_EN_1  0.185 
VARIABLE  VTL_P_EN_2  0.16 
VARIABLE  VTL_P_A_1   0.27 
VARIABLE  VTL_P_A_2   0.27 
VARIABLE  VTL_P_R_2   0.4


VARIABLE  mVTL_EN_1    0.05
VARIABLE  mVTL_S_1     0.05

VARIABLE  PP_W_1   0.18 
VARIABLE  PP_S_1   0.18 
VARIABLE  PP_S_2   0.13 
VARIABLE  PP_S_4   0.02 
VARIABLE  PP_S_5   0.32 
VARIABLE  PP_S_6   0.32 
VARIABLE  PP_S_6_J 0.16 
VARIABLE  PP_S_7   0.20 
VARIABLE  PP_EN_1  0.15 
VARIABLE  PP_EX_1  0.13 
VARIABLE  PP_EX_2  0.02 
VARIABLE  PP_EX_3  0.20 
VARIABLE  PP_EX_4  0.32 
VARIABLE  PP_O_1   0.13 
VARIABLE  PP_A_1   0.122 
VARIABLE  PP_A_2   0.122 
VARIABLE  PP_A_3   0.04 
VARIABLE  PP_R_1   0.16 

VARIABLE  NP_W_1   0.18 
VARIABLE  NP_S_1   0.18 
VARIABLE  NP_S_2   0.13 
VARIABLE  NP_S_4   0.02 
VARIABLE  NP_S_5   0.32  
VARIABLE  NP_S_6   0.32 
VARIABLE  NP_S_6_J 0.16
VARIABLE  NP_S_7   0.20 
VARIABLE  NP_EX_1  0.13 
VARIABLE  NP_EX_2  0.02 
VARIABLE  NP_EX_3  0.20 
VARIABLE  NP_EX_4  0.32 
VARIABLE  NP_O_1   0.13 
VARIABLE  NP_A_1   0.122 
VARIABLE  NP_A_2   0.122 
VARIABLE  NP_A_3   0.04 
VARIABLE  NP_R_1   0.16 


VARIABLE  DCO_W_1  0.4
VARIABLE  DCO_S_1  0.4
VARIABLE  DCO_S_2  0.055
VARIABLE  DCO_S_3  0.185
VARIABLE  DCO_S_4  0.16
VARIABLE  DCO_S_5  0.18
VARIABLE  DCO_S_6  0.4
VARIABLE  DCO_EN_1 0.185
VARIABLE  DCO_EN_2 0.16
VARIABLE  DCO_EX_1 0.18
VARIABLE  DCO_EX_2 0.18
VARIABLE  DCO_EX_3 0.055
VARIABLE  DCO_A_1  1.2
VARIABLE  DCO_A_2  1.2
VARIABLE  DCO_O_1  0.18
VARIABLE  DCO_R_5  0.2


VARIABLE  LDN_EX_1  0.18 
VARIABLE  LDN_O_1   0.18 
VARIABLE  LDP_EX_1  0.18 
VARIABLE  LDP_O_2   0.18 
VARIABLE  VT_S_1    0.18 
VARIABLE  VT_EX_2   0.18 

VARIABLE  RPO_W_1    0.43 
VARIABLE  RPO_S_1    0.43 
VARIABLE  RPO_S_2    0.22 
VARIABLE  RPO_S_3    0.22 
VARIABLE  RPO_S_4    0.38 
VARIABLE  RPO_S_5    0.30
VARIABLE  RPO_EX_1   0.22 
VARIABLE  RPO_EX_1_1   0.30 
VARIABLE  RPO_EX_1_1_W 10.0
VARIABLE  RPO_EX_2   0.22 
VARIABLE  RPO_A_1    1.00 
VARIABLE  RPO_A_2    1.00

VARIABLE  RES_8      0.16
VARIABLE  RES_11     0.13

VARIABLE  VAR_W_1    0.20
VARIABLE  VAR_W_4    0.40
VARIABLE  VAR_S_1    0.13
VARIABLE  VAR_EN_1   0.16
VARIABLE  VAR_R_4    0.16
VARIABLE  VAR_R_5_1  0.19
VARIABLE  VAR_R_5_2  0.13


VARIABLE  HVD_N_W_1     0.47 
VARIABLE  HVD_N_W_2     0.6 
VARIABLE  HVD_N_S_1     0.47 
VARIABLE  HVD_N_S_2     1.37 
VARIABLE  HVD_N_S_3     1.6 
VARIABLE  HVD_N_S_4     0.3
VARIABLE  HVD_N_S_5     0.6 
VARIABLE  HVD_N_S_6     3.0
VARIABLE  HVD_N_EX_1    0.24 
VARIABLE  HVD_N_O_1     0.3
VARIABLE  HVD_N_L_1     0.85
VARIABLE  HVD_N_A_1     0.64 
VARIABLE  HVD_N_A_2     0.64

VARIABLE  HVD_P_W_1     0.47 
VARIABLE  HVD_P_W_2     0.6 
VARIABLE  HVD_P_S_1     0.47 
VARIABLE  HVD_P_S_2     1.2 
VARIABLE  HVD_P_S_4     0.24
VARIABLE  HVD_P_S_5     0.48
VARIABLE  HVD_P_EX_1    0.24 
VARIABLE  HVD_P_EN_1    1.6 
VARIABLE  HVD_P_O_1     0.25 
VARIABLE  HVD_P_L_1     0.6 
VARIABLE  HVD_P_A_1     0.64 
VARIABLE  HVD_P_A_2     0.64

VARIABLE  BV_W_1        10
VARIABLE  BV_W_2        50
VARIABLE  BV_R_1        64

VARIABLE  CO_W_1     0.09 
VARIABLE  CO_W_2     0.09 
VARIABLE  CO_S_1     0.11 
VARIABLE  CO_S_2     0.14 
VARIABLE  CO_S_2_N   0.15 
VARIABLE  CO_S_2_1   0.14 
VARIABLE  CO_S_2_2   0.12 
VARIABLE  CO_S_4     0.07 
VARIABLE  CO_S_5     0.09
VARIABLE  CO_S_6     0.06
VARIABLE  CO_S_3     0.055 
VARIABLE  CO_EN_1    0.015
VARIABLE  CO_EN_1_1  0.03   
VARIABLE  CO_EN_2    0.01
VARIABLE  CO_EN_3    0.04 
VARIABLE  CO_EN_4    0.03


VARIABLE  M1_W_1     0.09 
VARIABLE  M1_W_2     0.19
VARIABLE  M1_W_3     12.0 
VARIABLE  M1_S_1     0.09 
#IFDEF HALF_NODE
VARIABLE  M1_S_2     0.11 
VARIABLE  M1_S_2_W   0.22   //N55 
VARIABLE  M1_S_2_L   0.42   //N55
VARIABLE  M1_S_2_1   0.16 
VARIABLE  M1_S_2_1_W 0.465  //N55  
VARIABLE  M1_S_2_1_L 0.465  //N55
VARIABLE  M1_S_2_2   0.1    //N55
VARIABLE  M1_S_2_2_W 0.2    //N55  
VARIABLE  M1_S_2_2_L 0.42   //N55
VARIABLE  M1_S_2_3   0.12   //N55
VARIABLE  M1_S_2_3_W 0.42   //N55  
VARIABLE  M1_S_2_3_L 0.465  //N55
VARIABLE  M1_S_3     0.50 
VARIABLE  M1_S_3_W   1.65  //N55
VARIABLE  M1_S_3_L   1.65  //N55
VARIABLE  M1_S_4     1.50 
VARIABLE  M1_S_4_W   4.95  //N55
VARIABLE  M1_S_4_L   4.95  //N55
#ELSE
VARIABLE  M1_S_2     0.11 
VARIABLE  M1_S_2_W   0.20 
VARIABLE  M1_S_2_L   0.38
VARIABLE  M1_S_2_1   0.16 
VARIABLE  M1_S_2_1_W 0.42  
VARIABLE  M1_S_2_1_L 0.42  
VARIABLE  M1_S_3     0.50 
VARIABLE  M1_S_3_W   1.5 
VARIABLE  M1_S_3_L   1.5 
VARIABLE  M1_S_4     1.50 
VARIABLE  M1_S_4_W   4.5 
VARIABLE  M1_S_4_L   4.5 
#ENDIF
VARIABLE  M1_S_6     0.19
VARIABLE  M1_S_5     0.11 
VARIABLE  M1_S_5_Q   0.11 
VARIABLE  M1_S_5_E   0.035
VARIABLE  M1_EN_2    0.04 
VARIABLE  M1_EN_3   0.025 
VARIABLE  M1_EN_4   0.04 
VARIABLE  M1_EN_4_W 1.0 
VARIABLE  M1_A_1    0.042 
VARIABLE  M1_A_2    0.2 
VARIABLE  M1_DN_1L   0.1
VARIABLE  M1_DN_1L_W METAL_LOW_DEN_WINDOW_SIZE  
VARIABLE  M1_DN_1L_S METAL_LOW_DEN_WINDOW_STEP  
VARIABLE  M1_DN_1L_E M1_DN_1L_W/4
VARIABLE  M1_DN_1H   0.8   
VARIABLE  M1_DN_1H_W METAL_HIGH_DEN_WINDOW_SIZE  
VARIABLE  M1_DN_1H_S METAL_HIGH_DEN_WINDOW_STEP   
VARIABLE  M1_DN_1H_E M1_DN_1H_W/4
VARIABLE  M1_DN_2    0.9
VARIABLE  M1_DN_2_W  20
VARIABLE  M1_DN_2_S  10
VARIABLE  M1_DN_2_E  5
VARIABLE  M1_DN_4    0.4
VARIABLE  M1_DN_4_W  250



VARIABLE  VIA1_W_1   0.10 
VARIABLE  VIA1_W_2   0.10 
VARIABLE  VIA1_S_1   0.10 
VARIABLE  VIA1_S_2   0.13
VARIABLE  VIA1_S_2_S 0.14 
VARIABLE  VIA1_S_3   0.13
VARIABLE  VIA1_EN_2  0.04 
VARIABLE  VIA1_EN_3  0.03
#IFDEF HALF_NODE
VARIABLE  VIA1_R_2_S1  0.22  //N55
VARIABLE  VIA1_R_2_S2  0.275 //N55
VARIABLE  VIA1_R_2_W   0.33  //N55
VARIABLE  VIA1_R_3_S1  0.22  //N55  
VARIABLE  VIA1_R_3_S2  0.385 //N55
VARIABLE  VIA1_R_3_W   0.77  //N55
VARIABLE  VIA1_R_4_W   0.33  //N55 
VARIABLE  VIA1_R_4_D   0.8
VARIABLE  VIA1_R_5_W   2.2   //N55
VARIABLE  VIA1_R_5_D   2.0 
VARIABLE  VIA1_R_6_W   3.3   //N55
VARIABLE  VIA1_R_6_L   11.0  //N55
VARIABLE  VIA1_R_6_D   5.0
#ELSE
VARIABLE  VIA1_R_2_S1  0.20 
VARIABLE  VIA1_R_2_S2  0.25 
VARIABLE  VIA1_R_2_W   0.30 
VARIABLE  VIA1_R_3_S1  0.20 
VARIABLE  VIA1_R_3_S2  0.35 
VARIABLE  VIA1_R_3_W   0.70 
VARIABLE  VIA1_R_4_W   0.3
VARIABLE  VIA1_R_4_D   0.8
VARIABLE  VIA1_R_5_W   2.0
VARIABLE  VIA1_R_5_D   2.0
VARIABLE  VIA1_R_6_W   3.0
VARIABLE  VIA1_R_6_L   10.0
VARIABLE  VIA1_R_6_D   5.0
#ENDIF
VARIABLE  VIA1_R_11_L   1.0
VARIABLE  VIA1_R_11_W   0.3
VARIABLE  VIA1_R_11_A   5.0
VARIABLE  VIA1_R_11_L2  5.0


VARIABLE  M2_W_1   0.10 
VARIABLE  M2_S_1   0.10
VARIABLE  M2_A_1   0.052 
VARIABLE  M2_A_2   0.20 
VARIABLE  M2_W_3   12.0 
#IFDEF HALF_NODE
VARIABLE  M2_S_2   0.12 
VARIABLE  M2_S_2_W 0.22   //N55 
VARIABLE  M2_S_2_L 0.42   //N55
VARIABLE  M2_S_2_1 0.16 
VARIABLE  M2_S_2_1_W 0.44 //N55
VARIABLE  M2_S_2_1_L 0.44 //N55 
VARIABLE  M2_S_2_2 0.11   //N55
VARIABLE  M2_S_2_2_W 0.2  //N55
VARIABLE  M2_S_2_2_L 0.42 //N55
VARIABLE  M2_S_2_3 0.13   //N55
VARIABLE  M2_S_2_3_W 0.4  //N55
VARIABLE  M2_S_2_3_L 0.44 //N55
VARIABLE  M2_S_3   0.50 
VARIABLE  M2_S_3_W 1.65   //N55
VARIABLE  M2_S_3_L 1.65   //N55
VARIABLE  M2_S_4   1.50 
VARIABLE  M2_S_4_W 4.95   //N55
VARIABLE  M2_S_4_L 4.95   //N55
#ELSE
VARIABLE  M2_S_2   0.12 
VARIABLE  M2_S_2_W 0.20 
VARIABLE  M2_S_2_L 0.38 
VARIABLE  M2_S_2_1 0.16 
VARIABLE  M2_S_2_1_W 0.4
VARIABLE  M2_S_2_1_L 0.4
VARIABLE  M2_S_3   0.50 
VARIABLE  M2_S_3_W 1.50 
VARIABLE  M2_S_3_L 1.50 
VARIABLE  M2_S_4   1.50 
VARIABLE  M2_S_4_W 4.50 
VARIABLE  M2_S_4_L 4.50 
#ENDIF
VARIABLE  M2_S_5   0.12 
VARIABLE  M2_S_5_Q 0.12 
VARIABLE  M2_S_5_E 0.035 
VARIABLE  M2_EN_2  0.04
VARIABLE  M2_EN_3  0.03
VARIABLE  M2_W_2     0.19
VARIABLE  M2_S_6     0.19

VARIABLE  M2_DN_1L   0.1
VARIABLE  M2_DN_1L_W METAL_LOW_DEN_WINDOW_SIZE  
VARIABLE  M2_DN_1L_S METAL_LOW_DEN_WINDOW_STEP  
VARIABLE  M2_DN_1L_E M2_DN_1L_W/4
VARIABLE  M2_DN_1H   0.8   
VARIABLE  M2_DN_1H_W METAL_HIGH_DEN_WINDOW_SIZE  
VARIABLE  M2_DN_1H_S METAL_HIGH_DEN_WINDOW_STEP   
VARIABLE  M2_DN_1H_E M2_DN_1H_W/4
VARIABLE  M2_DN_2    0.9
VARIABLE  M2_DN_2_W  20
VARIABLE  M2_DN_2_S  10
VARIABLE  M2_DN_2_E  5
VARIABLE  M2_DN_4    0.4
VARIABLE  M2_DN_4_W  250


VARIABLE  VIA2_W_1   0.10 
VARIABLE  VIA2_W_2   0.10 
VARIABLE  VIA2_S_1   0.10 
VARIABLE  VIA2_S_2   0.13
VARIABLE  VIA2_S_2_S 0.14 
VARIABLE  VIA2_S_3   0.13
VARIABLE  VIA2_EN_2  0.04 
VARIABLE  VIA2_EN_3  0.03
#IFDEF HALF_NODE
VARIABLE  VIA2_R_2_S1  0.22  //N55
VARIABLE  VIA2_R_2_S2  0.275 //N55
VARIABLE  VIA2_R_2_W   0.33  //N55
VARIABLE  VIA2_R_3_S1  0.22  //N55  
VARIABLE  VIA2_R_3_S2  0.385 //N55
VARIABLE  VIA2_R_3_W   0.77  //N55
VARIABLE  VIA2_R_4_W   0.33  //N55 
VARIABLE  VIA2_R_4_D   0.8
VARIABLE  VIA2_R_5_W   2.2   //N55
VARIABLE  VIA2_R_5_D   2.0 
VARIABLE  VIA2_R_6_W   3.3   //N55
VARIABLE  VIA2_R_6_L   11.0  //N55
VARIABLE  VIA2_R_6_D   5.0
#ELSE
VARIABLE  VIA2_R_2_S1  0.20 
VARIABLE  VIA2_R_2_S2  0.25 
VARIABLE  VIA2_R_2_W   0.30 
VARIABLE  VIA2_R_3_S1  0.20 
VARIABLE  VIA2_R_3_S2  0.35 
VARIABLE  VIA2_R_3_W   0.70 
VARIABLE  VIA2_R_4_W   0.3
VARIABLE  VIA2_R_4_D   0.8
VARIABLE  VIA2_R_5_W   2.0
VARIABLE  VIA2_R_5_D   2.0
VARIABLE  VIA2_R_6_W   3.0
VARIABLE  VIA2_R_6_L   10.0
VARIABLE  VIA2_R_6_D   5.0
#ENDIF
VARIABLE  VIA2_R_11_L   1.0
VARIABLE  VIA2_R_11_W   0.3
VARIABLE  VIA2_R_11_A   5.0
VARIABLE  VIA2_R_11_L2  5.0


VARIABLE  M3_W_1   0.10 
VARIABLE  M3_S_1   0.10
VARIABLE  M3_A_1   0.052 
VARIABLE  M3_A_2   0.20 
VARIABLE  M3_W_3   12.0 
#IFDEF HALF_NODE
VARIABLE  M3_S_2   0.12 
VARIABLE  M3_S_2_W 0.22   //N55 
VARIABLE  M3_S_2_L 0.42   //N55
VARIABLE  M3_S_2_1 0.16 
VARIABLE  M3_S_2_1_W 0.44 //N55
VARIABLE  M3_S_2_1_L 0.44 //N55 
VARIABLE  M3_S_2_2 0.11   //N55
VARIABLE  M3_S_2_2_W 0.2  //N55
VARIABLE  M3_S_2_2_L 0.42 //N55
VARIABLE  M3_S_2_3 0.13   //N55
VARIABLE  M3_S_2_3_W 0.4  //N55
VARIABLE  M3_S_2_3_L 0.44 //N55
VARIABLE  M3_S_3   0.50 
VARIABLE  M3_S_3_W 1.65   //N55
VARIABLE  M3_S_3_L 1.65   //N55
VARIABLE  M3_S_4   1.50 
VARIABLE  M3_S_4_W 4.95   //N55
VARIABLE  M3_S_4_L 4.95   //N55
#ELSE
VARIABLE  M3_S_2   0.12 
VARIABLE  M3_S_2_W 0.20 
VARIABLE  M3_S_2_L 0.38 
VARIABLE  M3_S_2_1 0.16 
VARIABLE  M3_S_2_1_W 0.4
VARIABLE  M3_S_2_1_L 0.4
VARIABLE  M3_S_3   0.50 
VARIABLE  M3_S_3_W 1.50 
VARIABLE  M3_S_3_L 1.50 
VARIABLE  M3_S_4   1.50 
VARIABLE  M3_S_4_W 4.50 
VARIABLE  M3_S_4_L 4.50 
#ENDIF
VARIABLE  M3_S_5   0.12 
VARIABLE  M3_S_5_Q 0.12 
VARIABLE  M3_S_5_E 0.035 
VARIABLE  M3_EN_2  0.04
VARIABLE  M3_EN_3  0.03
VARIABLE  M3_W_2     0.19
VARIABLE  M3_S_6     0.19

VARIABLE  M3_DN_1L   0.1
VARIABLE  M3_DN_1L_W METAL_LOW_DEN_WINDOW_SIZE  
VARIABLE  M3_DN_1L_S METAL_LOW_DEN_WINDOW_STEP  
VARIABLE  M3_DN_1L_E M3_DN_1L_W/4
VARIABLE  M3_DN_1H   0.8   
VARIABLE  M3_DN_1H_W METAL_HIGH_DEN_WINDOW_SIZE  
VARIABLE  M3_DN_1H_S METAL_HIGH_DEN_WINDOW_STEP   
VARIABLE  M3_DN_1H_E M3_DN_1H_W/4
VARIABLE  M3_DN_2    0.9
VARIABLE  M3_DN_2_W  20
VARIABLE  M3_DN_2_S  10
VARIABLE  M3_DN_2_E  5
VARIABLE  M3_DN_4    0.4
VARIABLE  M3_DN_4_W  250


VARIABLE  VIA3_W_1   0.10 
VARIABLE  VIA3_W_2   0.10 
VARIABLE  VIA3_S_1   0.10 
VARIABLE  VIA3_S_2   0.13
VARIABLE  VIA3_S_2_S 0.14 
VARIABLE  VIA3_S_3   0.13
VARIABLE  VIA3_EN_2  0.04 
VARIABLE  VIA3_EN_3  0.03
#IFDEF HALF_NODE
VARIABLE  VIA3_R_2_S1  0.22  //N55
VARIABLE  VIA3_R_2_S2  0.275 //N55
VARIABLE  VIA3_R_2_W   0.33  //N55
VARIABLE  VIA3_R_3_S1  0.22  //N55  
VARIABLE  VIA3_R_3_S2  0.385 //N55
VARIABLE  VIA3_R_3_W   0.77  //N55
VARIABLE  VIA3_R_4_W   0.33  //N55 
VARIABLE  VIA3_R_4_D   0.8
VARIABLE  VIA3_R_5_W   2.2   //N55
VARIABLE  VIA3_R_5_D   2.0 
VARIABLE  VIA3_R_6_W   3.3   //N55
VARIABLE  VIA3_R_6_L   11.0  //N55
VARIABLE  VIA3_R_6_D   5.0
#ELSE
VARIABLE  VIA3_R_2_S1  0.20 
VARIABLE  VIA3_R_2_S2  0.25 
VARIABLE  VIA3_R_2_W   0.30 
VARIABLE  VIA3_R_3_S1  0.20 
VARIABLE  VIA3_R_3_S2  0.35 
VARIABLE  VIA3_R_3_W   0.70 
VARIABLE  VIA3_R_4_W   0.3
VARIABLE  VIA3_R_4_D   0.8
VARIABLE  VIA3_R_5_W   2.0
VARIABLE  VIA3_R_5_D   2.0
VARIABLE  VIA3_R_6_W   3.0
VARIABLE  VIA3_R_6_L   10.0
VARIABLE  VIA3_R_6_D   5.0
#ENDIF
VARIABLE  VIA3_R_11_L   1.0
VARIABLE  VIA3_R_11_W   0.3
VARIABLE  VIA3_R_11_A   5.0
VARIABLE  VIA3_R_11_L2  5.0


VARIABLE  M4_W_1   0.10 
VARIABLE  M4_S_1   0.10
VARIABLE  M4_A_1   0.052 
VARIABLE  M4_A_2   0.20 
VARIABLE  M4_W_3   12.0 
#IFDEF HALF_NODE
VARIABLE  M4_S_2   0.12 
VARIABLE  M4_S_2_W 0.22   //N55 
VARIABLE  M4_S_2_L 0.42   //N55
VARIABLE  M4_S_2_1 0.16 
VARIABLE  M4_S_2_1_W 0.44 //N55
VARIABLE  M4_S_2_1_L 0.44 //N55 
VARIABLE  M4_S_2_2 0.11   //N55
VARIABLE  M4_S_2_2_W 0.2  //N55
VARIABLE  M4_S_2_2_L 0.42 //N55
VARIABLE  M4_S_2_3 0.13   //N55
VARIABLE  M4_S_2_3_W 0.4  //N55
VARIABLE  M4_S_2_3_L 0.44 //N55
VARIABLE  M4_S_3   0.50 
VARIABLE  M4_S_3_W 1.65   //N55
VARIABLE  M4_S_3_L 1.65   //N55
VARIABLE  M4_S_4   1.50 
VARIABLE  M4_S_4_W 4.95   //N55
VARIABLE  M4_S_4_L 4.95   //N55
#ELSE
VARIABLE  M4_S_2   0.12 
VARIABLE  M4_S_2_W 0.20 
VARIABLE  M4_S_2_L 0.38 
VARIABLE  M4_S_2_1 0.16 
VARIABLE  M4_S_2_1_W 0.4
VARIABLE  M4_S_2_1_L 0.4
VARIABLE  M4_S_3   0.50 
VARIABLE  M4_S_3_W 1.50 
VARIABLE  M4_S_3_L 1.50 
VARIABLE  M4_S_4   1.50 
VARIABLE  M4_S_4_W 4.50 
VARIABLE  M4_S_4_L 4.50 
#ENDIF
VARIABLE  M4_S_5   0.12 
VARIABLE  M4_S_5_Q 0.12 
VARIABLE  M4_S_5_E 0.035 
VARIABLE  M4_EN_2  0.04
VARIABLE  M4_EN_3  0.03
VARIABLE  M4_W_2     0.19
VARIABLE  M4_S_6     0.19

VARIABLE  M4_DN_1L   0.1
VARIABLE  M4_DN_1L_W METAL_LOW_DEN_WINDOW_SIZE  
VARIABLE  M4_DN_1L_S METAL_LOW_DEN_WINDOW_STEP  
VARIABLE  M4_DN_1L_E M4_DN_1L_W/4
VARIABLE  M4_DN_1H   0.8   
VARIABLE  M4_DN_1H_W METAL_HIGH_DEN_WINDOW_SIZE  
VARIABLE  M4_DN_1H_S METAL_HIGH_DEN_WINDOW_STEP   
VARIABLE  M4_DN_1H_E M4_DN_1H_W/4
VARIABLE  M4_DN_2    0.9
VARIABLE  M4_DN_2_W  20
VARIABLE  M4_DN_2_S  10
VARIABLE  M4_DN_2_E  5
VARIABLE  M4_DN_4    0.4
VARIABLE  M4_DN_4_W  250


VARIABLE  VIA4_W_1   0.36 
VARIABLE  VIA4_W_2   0.36 
VARIABLE  VIA4_S_1   0.34 
VARIABLE  VIA4_S_2   0.54 
VARIABLE  VIA4_S_2_S 0.56 
VARIABLE  VIA4_EN_1  0.02 
VARIABLE  VIA4_EN_2  0.08 
#IFDEF HALF_NODE
VARIABLE  VIA4_R_2_S 1.87  //N55 
VARIABLE  VIA4_R_2_W 1.98  //N55
VARIABLE  VIA4_R_3_W 3.3   //N55
VARIABLE  VIA4_R_3_L 11.0  //N55
VARIABLE  VIA4_R_3_D 5.0
#ELSE
VARIABLE  VIA4_R_2_S 1.7   
VARIABLE  VIA4_R_2_W 1.8 
VARIABLE  VIA4_R_3_W 3.0
VARIABLE  VIA4_R_3_L 10.0
VARIABLE  VIA4_R_3_D 5.0
#ENDIF
VARIABLE  VIA4_EN_3  0.24
VARIABLE  VIA4_EN_4  0.20
VARIABLE  VIA4_S_3   0.30
VARIABLE  VIA4_S_4   0.54
VARIABLE  VIA4_S_5   0.54

VARIABLE  M5_W_1   0.4
VARIABLE  M5_W_2   12.0 
VARIABLE  M5_S_1   0.4
#IFDEF HALF_NODE
VARIABLE  M5_S_2   0.5 
VARIABLE  M5_S_2_W 1.65  //N55 
VARIABLE  M5_S_2_L 1.65  //N55
VARIABLE  M5_S_3   1.5 
VARIABLE  M5_S_3_W 4.95  //N55
VARIABLE  M5_S_3_L 4.95  //N55
#ELSE
VARIABLE  M5_S_2   0.5 
VARIABLE  M5_S_2_W 1.5 
VARIABLE  M5_S_2_L 1.5 
VARIABLE  M5_S_3   1.5 
VARIABLE  M5_S_3_W 4.5 
VARIABLE  M5_S_3_L 4.5 
#ENDIF
VARIABLE  M5_EN_1  0.02 
VARIABLE  M5_EN_2  0.08 
VARIABLE  M5_A_1   0.565 
VARIABLE  M5_A_2   0.565 
VARIABLE  M5_DN_1L   0.1
VARIABLE  M5_DN_1L_W METAL_LOW_DEN_WINDOW_SIZE  
VARIABLE  M5_DN_1L_S METAL_LOW_DEN_WINDOW_STEP  
VARIABLE  M5_DN_1L_E M5_DN_1L_W/4
VARIABLE  M5_DN_1H   0.8   
VARIABLE  M5_DN_1H_W METAL_HIGH_DEN_WINDOW_SIZE  
VARIABLE  M5_DN_1H_S METAL_HIGH_DEN_WINDOW_STEP   
VARIABLE  M5_DN_1H_E M5_DN_1H_W/4
VARIABLE  M5_DN_2    0.9
VARIABLE  M5_DN_2_W  20
VARIABLE  M5_DN_2_S  10
VARIABLE  M5_DN_2_E  5
VARIABLE  M5_DN_4    0.4
VARIABLE  M5_DN_4_W  250
VARIABLE  M5_EN_3    0.1
VARIABLE  M5_DN_5L   0.5
VARIABLE  M5_DN_5L_W 200
VARIABLE  M5_DN_5L_S 100
VARIABLE  M5_DN_5L_E 2500
VARIABLE  M5_DN_5H   0.8
VARIABLE  M5_DN_5H_W 100
VARIABLE  M5_DN_5H_S 50
VARIABLE  M5_DN_5H_E 2500
VARIABLE  M5_W_4     0.84
VARIABLE  M5_S_4     0.84



VARIABLE  VIA5_W_1   0.36 
VARIABLE  VIA5_W_2   0.36 
VARIABLE  VIA5_S_1   0.34 
VARIABLE  VIA5_S_2   0.54 
VARIABLE  VIA5_S_2_S 0.56 
VARIABLE  VIA5_EN_1  0.02 
VARIABLE  VIA5_EN_2  0.08 
VARIABLE  VIA5_EN_5  0.08
#IFDEF HALF_NODE
VARIABLE  VIA5_R_2_S 1.87  //N55 
VARIABLE  VIA5_R_2_W 1.98  //N55
VARIABLE  VIA5_R_3_W 3.3   //N55
VARIABLE  VIA5_R_3_L 11.0  //N55
VARIABLE  VIA5_R_3_D 5.0
#ELSE
VARIABLE  VIA5_R_2_S 1.7   
VARIABLE  VIA5_R_2_W 1.8 
VARIABLE  VIA5_R_3_W 3.0
VARIABLE  VIA5_R_3_L 10.0
VARIABLE  VIA5_R_3_D 5.0
#ENDIF
VARIABLE  VIA5_R_8_S 1.7  



VARIABLE  M6_W_1     2.0
VARIABLE  M6_W_2     12.0
VARIABLE  M6_W_3     30.0
VARIABLE  M6_S_1     2.0
VARIABLE  M6_EN_1    0.3
VARIABLE  M6_A_1     9
VARIABLE  M6_A_2     9
VARIABLE  M6_DN_1L   0.2
VARIABLE  M6_DN_1H   0.7
VARIABLE  M6_DN_2L   0.1
VARIABLE  M6_DN_2L_W METAL_LOW_DEN_WINDOW_SIZE  
VARIABLE  M6_DN_2L_S METAL_LOW_DEN_WINDOW_STEP  
VARIABLE  M6_DN_2L_E M6_DN_2L_W/4
VARIABLE  M6_DN_2H   0.8   
VARIABLE  M6_DN_2H_W METAL_HIGH_DEN_WINDOW_SIZE  
VARIABLE  M6_DN_2H_S METAL_HIGH_DEN_WINDOW_STEP   
VARIABLE  M6_DN_2H_E M6_DN_2H_W/4


VARIABLE CTM_W_1  2.0
VARIABLE CTM_W_2  100
VARIABLE CTM_S_1  0.8
VARIABLE CTM_EN_1 0.4
VARIABLE CBM_W_1  2.8  
VARIABLE CBM_W_2  210 
VARIABLE CBM_EN_2 10 
VARIABLE CBM_S_3  0.5
VARIABLE CBM_S_1   2.0
VARIABLE CBM_S_1_A 40000
VARIABLE CBM_S_2   2.6
VARIABLE CBM_S_2_A 40000 



VARIABLE  Mx_DN_5    0.8
VARIABLE  Mx_DN_5_W  50
VARIABLE  Mx_DN_5_S  25

VARIABLE  MOM_S_1    0.1
VARIABLE  MOM_S_2    0.12
VARIABLE  MOM_A_1    7.01E7
VARIABLE  MOM_S_3    0.13
VARIABLE  MOM_S_4    0.13
VARIABLE  MOM_A_2    1.72E5


VARIABLE  LOGO_S_1   10.0

VARIABLE  CSR_R_2    2.5 
VARIABLE  CSR_S_1    0.36 
VARIABLE  CSR_EN_1   0.53
VARIABLE  CSR_S_2    0.35
VARIABLE  CSR_EN_2   0.525
VARIABLE  CSR_S_3    0.34
VARIABLE  CSR_EN_3   0.61
VARIABLE  CSR_S_4    0.56
VARIABLE  CSR_EN_4   0.61
VARIABLE  CSR_S_5    0.89
VARIABLE  CSR_EN_9   0.345
VARIABLE  CSR_R_3_X  16
VARIABLE  CSR_R_3_Y  9
VARIABLE  CSR_R_3_Z  4
VARIABLE  CSR_R_3_R  4
VARIABLE  CSR_W_1    10.0
VARIABLE  CSR_W_2_1  6.0
VARIABLE  CSR_W_2_2  10.0
VARIABLE  CSR_L_1_1  20.0
VARIABLE  CSR_L_1_2  25.0
#IFDEF WLCSP_SEALRING
VARIABLE  CSR_EN_5_1 5.0
VARIABLE  CSR_EN_5_2 9.0
#ELSE
VARIABLE  CSR_EN_5_1 4.0
VARIABLE  CSR_EN_5_2 8.0
#ENDIF
VARIABLE  CSR_EN_6_A 27.0
VARIABLE  CSR_EN_6_B 29.0
VARIABLE  CSR_EN_6_1_L1 17.0
VARIABLE  CSR_EN_6_1_L2 18.0

VARIABLE  CSR_EN_7_X 0.52
VARIABLE  CSR_EN_7_Y 0.47
VARIABLE  CSR_EN_7_Z 0.58
VARIABLE  CSR_EN_7_R 0.345
VARIABLE  CSR_EN_8   0.25

VARIABLE  SR_EN_1   2
VARIABLE  SR_S_1    10


VARIABLE  DOD_W_1   0.5 
VARIABLE  DOD_S_1   0.4 
VARIABLE  DOD_S_2   0.34 
VARIABLE  DOD_S_3   0.3 
VARIABLE  DOD_S_5   0.3 
VARIABLE  DOD_S_6   1.2 
VARIABLE  DOD_S_7   1.2 
VARIABLE  DOD_S_7_1 5 
VARIABLE  DOD_S_8   0.6 
VARIABLE  DOD_S_10  1.2 
VARIABLE  DOD_EN_1  0.3
VARIABLE  DOD_EN_2  0.6 

VARIABLE  DPO_W_1   0.4 
VARIABLE  DPO_S_1   0.3 
VARIABLE  DPO_S_2   0.2 
VARIABLE  DPO_S_3   0.5 
VARIABLE  DPO_S_5   1.2 
VARIABLE  DPO_S_6   1.2 
VARIABLE  DPO_S_6_1 5 
VARIABLE  DPO_S_9   1.2 
VARIABLE  DPO_EN_1  0.6 

VARIABLE  DM1_W_2     3.0 
#IFDEF HALF_NODE
VARIABLE  DM1_S_3     1.5 
VARIABLE  DM1_S_3_L   4.95
VARIABLE  DM1_S_3_W   4.95
VARIABLE  DM1_S_3_1   0.5
VARIABLE  DM1_S_3_1_L 1.65
VARIABLE  DM1_S_3_1_W 1.65
#ELSE
VARIABLE  DM1_S_3     1.5 
VARIABLE  DM1_S_3_L   4.5
VARIABLE  DM1_S_3_W   4.5
VARIABLE  DM1_S_3_1   0.5
VARIABLE  DM1_S_3_1_L 1.5
VARIABLE  DM1_S_3_1_W 1.5
#ENDIF
VARIABLE  DM1_S_4     5.0 
VARIABLE  DM1_S_5     5.0 
VARIABLE  DM1_S_5_1   5.0 
VARIABLE  DM1_S_8     2.5
VARIABLE  DM1_EN_1    2.5 
VARIABLE  DM2_W_2     3.0 
#IFDEF HALF_NODE
VARIABLE  DM2_S_3     1.5 
VARIABLE  DM2_S_3_L   4.95
VARIABLE  DM2_S_3_W   4.95
VARIABLE  DM2_S_3_1   0.5
VARIABLE  DM2_S_3_1_L 1.65
VARIABLE  DM2_S_3_1_W 1.65
#ELSE
VARIABLE  DM2_S_3     1.5 
VARIABLE  DM2_S_3_L   4.5
VARIABLE  DM2_S_3_W   4.5
VARIABLE  DM2_S_3_1   0.5
VARIABLE  DM2_S_3_1_L 1.5
VARIABLE  DM2_S_3_1_W 1.5
#ENDIF
VARIABLE  DM2_S_4     5.0 
VARIABLE  DM2_S_5     5.0 
VARIABLE  DM2_S_5_1   5.0 
VARIABLE  DM2_S_8     2.5
VARIABLE  DM2_EN_1    2.5 
VARIABLE  DM3_W_2     3.0 
#IFDEF HALF_NODE
VARIABLE  DM3_S_3     1.5 
VARIABLE  DM3_S_3_L   4.95
VARIABLE  DM3_S_3_W   4.95
VARIABLE  DM3_S_3_1   0.5
VARIABLE  DM3_S_3_1_L 1.65
VARIABLE  DM3_S_3_1_W 1.65
#ELSE
VARIABLE  DM3_S_3     1.5 
VARIABLE  DM3_S_3_L   4.5
VARIABLE  DM3_S_3_W   4.5
VARIABLE  DM3_S_3_1   0.5
VARIABLE  DM3_S_3_1_L 1.5
VARIABLE  DM3_S_3_1_W 1.5
#ENDIF
VARIABLE  DM3_S_4     5.0 
VARIABLE  DM3_S_5     5.0 
VARIABLE  DM3_S_5_1   5.0 
VARIABLE  DM3_S_8     2.5
VARIABLE  DM3_EN_1    2.5 
VARIABLE  DM4_W_2     3.0 
#IFDEF HALF_NODE
VARIABLE  DM4_S_3     1.5 
VARIABLE  DM4_S_3_L   4.95
VARIABLE  DM4_S_3_W   4.95
VARIABLE  DM4_S_3_1   0.5
VARIABLE  DM4_S_3_1_L 1.65
VARIABLE  DM4_S_3_1_W 1.65
#ELSE
VARIABLE  DM4_S_3     1.5 
VARIABLE  DM4_S_3_L   4.5
VARIABLE  DM4_S_3_W   4.5
VARIABLE  DM4_S_3_1   0.5
VARIABLE  DM4_S_3_1_L 1.5
VARIABLE  DM4_S_3_1_W 1.5
#ENDIF
VARIABLE  DM4_S_4     5.0 
VARIABLE  DM4_S_5     5.0 
VARIABLE  DM4_S_5_1   5.0 
VARIABLE  DM4_S_8     2.5
VARIABLE  DM4_S_9     1.5 
VARIABLE  DM4_EN_1    2.5 
VARIABLE  DM5_W_2     3.0 
#IFDEF HALF_NODE
VARIABLE  DM5_S_3     1.5 
VARIABLE  DM5_S_3_L   4.95
VARIABLE  DM5_S_3_W   4.95
VARIABLE  DM5_S_3_1   0.5
VARIABLE  DM5_S_3_1_L 1.65
VARIABLE  DM5_S_3_1_W 1.65
#ELSE
VARIABLE  DM5_S_3     1.5 
VARIABLE  DM5_S_3_L   4.5
VARIABLE  DM5_S_3_W   4.5
VARIABLE  DM5_S_3_1   0.5
VARIABLE  DM5_S_3_1_L 1.5
VARIABLE  DM5_S_3_1_W 1.5
#ENDIF
VARIABLE  DM5_S_4     5.0 
VARIABLE  DM5_S_5     5.0 
VARIABLE  DM5_S_5_1   5.0 
VARIABLE  DM5_S_8     2.5
VARIABLE  DM5_EN_1    2.5 
VARIABLE  DM6_W_2     3.0 
#IFDEF HALF_NODE
VARIABLE  DM6_S_3     1.5 
VARIABLE  DM6_S_3_L   4.95
VARIABLE  DM6_S_3_W   4.95
VARIABLE  DM6_S_3_1   0.5
VARIABLE  DM6_S_3_1_L 1.65
VARIABLE  DM6_S_3_1_W 1.65
#ELSE
VARIABLE  DM6_S_3     1.5 
VARIABLE  DM6_S_3_L   4.5
VARIABLE  DM6_S_3_W   4.5
VARIABLE  DM6_S_3_1   0.5
VARIABLE  DM6_S_3_1_L 1.5
VARIABLE  DM6_S_3_1_W 1.5
#ENDIF
VARIABLE  DM6_S_4     5.0 
VARIABLE  DM6_S_5     5.0 
VARIABLE  DM6_S_5_1   5.0 
VARIABLE  DM6_S_8     2.5
VARIABLE  DM6_EN_1    2.5 

VARIABLE  DM1_W_1   0.3    
VARIABLE  DM1_S_1   0.3   
VARIABLE  DM1_S_2   0.3   
VARIABLE  DM1_A_1   0.24  
VARIABLE  DM1_A_2   80.0
VARIABLE  DM1_S_10  0.4   
VARIABLE  DM2_W_1   0.3    
VARIABLE  DM2_S_1   0.3   
VARIABLE  DM2_S_2   0.3   
VARIABLE  DM2_A_1   0.24  
VARIABLE  DM2_A_2   80.0
VARIABLE  DM2_S_10  0.4   
VARIABLE  DM3_W_1   0.3    
VARIABLE  DM3_S_1   0.3   
VARIABLE  DM3_S_2   0.3   
VARIABLE  DM3_A_1   0.24  
VARIABLE  DM3_A_2   80.0
VARIABLE  DM3_S_10  0.4   
VARIABLE  DM4_W_1   0.3    
VARIABLE  DM4_S_1   0.3   
VARIABLE  DM4_S_2   0.3   
VARIABLE  DM4_A_1   0.24  
VARIABLE  DM4_A_2   80.0
VARIABLE  DM4_S_10  0.4   
VARIABLE  DM5_W_1  0.4    
VARIABLE  DM5_S_1  0.4    
VARIABLE  DM5_S_2  0.6 
VARIABLE  DM5_A_1  0.565  
VARIABLE  DM5_A_2  160.0 
VARIABLE  DM6_W_1  3.0    
VARIABLE  DM6_S_1  3.0   
VARIABLE  DM6_S_2  3.0 
VARIABLE  DM6_A_1  9.0 
VARIABLE  DM6_A_2  600.0 



VARIABLE FU_W_1      1
VARIABLE FU_S_1_1    2   
VARIABLE FU_S_4     27
VARIABLE FU_EN_1     8   
VARIABLE FU_EN_1_1   2.2 
VARIABLE FU_EN_2    13   
VARIABLE FU_EN_3    0.8
VARIABLE FU_W_2   21.6   // long-length AP fuse for Mu
VARIABLE FU_L_1   17.2   // long-length AP fuse for Mu
VARIABLE FU_L_1_1  8     // long-length AP fuse for Mu
VARIABLE FU_S_1    5.6   // long-length AP fuse for Mu
VARIABLE FU_S_2   10.8   // long-length AP fuse for Mu
VARIABLE FU_S_3    9.6   // long-length AP fuse for Mu
VARIABLE FU_A_1_L    3   // long-length AP fuse for Mu
VARIABLE FU_A_1_W    3   // long-length AP fuse for Mu


VARIABLE PR_W_1_Vx   0.1    
VARIABLE PR_W_1_Vy   0.2    
VARIABLE PR_W_1_Vz   0.36   
VARIABLE PR_W_1_Vr   0.29   
VARIABLE PR_S_1      1.0    
VARIABLE PR_S_2      3.2    
VARIABLE PR_S_3      0.5
VARIABLE PR_EN_1_Vx  0.6
VARIABLE PR_EN_1_Vy  0.52
VARIABLE PR_EN_1_Vz  0.52
VARIABLE PR_EN_1_Vr  0.52
VARIABLE PR_EX_2     12

#IFDEF HALF_NODE
VARIABLE LW_W_1_MIN  11  
VARIABLE LW_W_1_MAX  22
VARIABLE LW_L_1_MIN  33
VARIABLE LW_L_1_MAX  55
VARIABLE LW_EN_1     13.2
VARIABLE LW_EN_2     33
#ELSE
VARIABLE LW_W_1_MIN  10
VARIABLE LW_W_1_MAX  20
VARIABLE LW_L_1_MIN  30
VARIABLE LW_L_1_MAX  50
VARIABLE LW_EN_1     12
VARIABLE LW_EN_2     30
#ENDIF
VARIABLE LW_S_1      5
VARIABLE LW_S_2      15



VARIABLE  RV_W_1     3
VARIABLE  RV_S_1     3
VARIABLE  RV_S_3     6
VARIABLE  RV_EN_1    1.5

VARIABLE  AP_W_1     3
VARIABLE  AP_W_2     35.0
VARIABLE  AP_S_1     2
VARIABLE  AP_S_2     5
VARIABLE  AP_S_3     5
VARIABLE  AP_EN_1    1.5
VARIABLE  AP_EN_2    1.5
VARIABLE  AP_DN_1_L  0.1
VARIABLE  AP_DN_1_H  0.7

VARIABLE  LUP_2     15.0
VARIABLE  LUP_2_S   5.0
VARIABLE  LUP_3_W   0.2
VARIABLE  LUP_3_1_1 2
VARIABLE  LUP_3_1_2 3
VARIABLE  LUP_3_2_1 2.3
VARIABLE  LUP_3_2_2 4
VARIABLE  LUP_3_3_1 2.6
VARIABLE  LUP_3_3_2 5
VARIABLE  LUP_3_4_1 4
VARIABLE  LUP_3_4_2 8
VARIABLE  LUP_3_5_1 10
VARIABLE  LUP_3_5_2 15
VARIABLE  LUP_4   0.12
VARIABLE  LUP_5_1_1 2
VARIABLE  LUP_5_1_2 3
VARIABLE  LUP_5_2_1 2.3
VARIABLE  LUP_5_2_2 4
VARIABLE  LUP_5_3_1 2.6
VARIABLE  LUP_5_3_2 5
VARIABLE  LUP_5_4_1 4
VARIABLE  LUP_5_4_2 8
VARIABLE  LUP_5_5_1 10
VARIABLE  LUP_5_5_2 15
VARIABLE  LUP_6   30.0
VARIABLE  LUP_6_SRAM 40.0

VARIABLE  ESD_3g_MIN   15.0
VARIABLE  ESD_3g_MAX   60.0
VARIABLE  ESD_6g       2.0
VARIABLE  ESD_7g       2.4
VARIABLE  ESD_16g      360 
VARIABLE  ESD_17g      360
VARIABLE  ESD_18g_33V  0.4
VARIABLE  ESD_18g_25V  0.35
VARIABLE  ESD_18g_18V  0.2
VARIABLE  ESD_18g_10V  0.1
VARIABLE  ESD_20g      0.06
VARIABLE  ESD_21g      1.95
VARIABLE  ESD_22g      1.0
VARIABLE  ESD_23g      0.22
VARIABLE  ESD_28g      0.06
VARIABLE  ESD_30g      1.95
VARIABLE  ESD_32g      0.22
VARIABLE  ESD_33g      0.25
VARIABLE  ESD_37g      900
VARIABLE  ESD_48g      0.45
VARIABLE  ESD_49g      1.5
VARIABLE  ESD_50g      1.0
VARIABLE  ESD_51g      0.22
VARIABLE  ESD_56g      1.95
VARIABLE  ESD_57g      0.22
VARIABLE  ESD_58g      360
VARIABLE  ESD_59g      360
VARIABLE  ESD_60g      0.44
VARIABLE  ESD_61g_MIN  15
VARIABLE  ESD_61g_MAX  60
VARIABLE  ESD_63g      0.86
VARIABLE  ESD_64g      1.95
VARIABLE  ESD_65g      0.1
VARIABLE  ESD_66g      0.22

VARIABLE  SRAM_W_1  0.28
VARIABLE  SRAM_S_1  0.28
VARIABLE  SRAM_S_2  0.12
VARIABLE  SRAM_EN_1 0.12
VARIABLE  SRAM_EX_1 0.28
VARIABLE  SRAM_O_1  0.28
VARIABLE  SRAM_A_1  0.6

VARIABLE  WLD_R_1   0.05
VARIABLE  WLD_R_2   0.043
VARIABLE  WLD_R_3   0.14  // min.
VARIABLE  WLD_R_7    200









LAYER RESOLUTION COi 1	// inside SRAM periphrial regions only
LAYER RESOLUTION POi 1	// inside SRAM periphrial regions only

// DRAWN LAYER DEFINITIONS
//------------------------
LAYER DNWi        1   // deep-nwell
LAYER NWi         3000  // nwell technology
LAYER MAP 3 DATATYPE >=0 <=255 3000
LAYER NWi_OTHERS  3001     
LAYER MAP 3 DATATYPE >=1 <=255 3001
LAYER OD_18i     16  // define 1.8V thick gate oxides
LAYER OD_25i     18  // define 2.5V thick gate oxides
LAYER OD25_33    451 // define 2.5V thick gate oxides overdrive 3.3v
LAYER MAP 18 DATATYPE 3 451
LAYER OD25_18    452 // define 2.5V thick gate oxides underdrive 1.8v
LAYER MAP 18 DATATYPE 4 452
LAYER OD_33i     15  // define 3.3V thick gate oxides
LAYER OD_DECAP   118 // decoupling capacitor device region
LAYER PPi        25  // P+ S/D imlant
LAYER NPi        26  // N+ S/D imlant
LAYER COi  3010       // Define connect for M1 to S/D and Gate
LAYER MAP 30 DATATYPE >=0 <=10 3010
LAYER MAP 30 DATATYPE >=12 <=255 3010
LAYER CO_PUSH    3011 // rule pushed contact in SRAM cell
LAYER MAP 30 DATATYPE 11 3011  
LAYER COi_SRAM 3012            
LAYER MAP 30 DATATYPE >=11 <=13 3012 
LAYER COi_OTHERS 3013            
LAYER MAP 30 DATATYPE >=1 <=10 3013
LAYER MAP 30 DATATYPE >=12 <=255 3013
LAYER CBi        76  // Passivation opening for Bond Pad
LAYER CB2i       86  // Passivation-2 opening for Bond Pad
LAYER RPOi       29  // Silicided Block Layer
LAYER NT_Ni      11  // Native NMOS blocked implant
LAYER NCap_NTNi 450  // connected NMOS capacitors within same NT_N region
LAYER MAP 11 DATATYPE 20 450
LAYER FWALi      951   // Al fuse window
LAYER MAP 95 DATATYPE 20 951
LAYER FWCUi      952   // Cu fuse window
LAYER MAP 95 DATATYPE 0 952
FWi = FWALi OR FWCUi 
LAYER POFUSE 648     // Poly fuse implant layer    
LAYER MAP 156 DATATYPE 0 648
LAYER FUSELINK 649   // Dummy layer to cover poly fuse link region.   
LAYER MAP 156 DATATYPE 1 649
LAYER PMi        5   // Polymide window
LAYER PM1i   	  5001 // polyimide 1 window for WLCSP
LAYER MAP 5 DATATYPE 1 5001
LAYER PM2i   	  5002 // polyimide 2 window for WLCSP
LAYER MAP 5 DATATYPE 2 5002
LAYER SEALRINGi  162 // SEALRING Layer to cover seal ring area
LAYER VTH_Ni     67  // High Vt NMOS Implant
LAYER VTH_Pi     68  // High Vt PMOS Implant
LAYER VTL_Ni     12  // Low Vt NMOS Implant
LAYER VTL_Pi     13  // Low Vt PMOS Implant
LAYER UHVT_Ni    93  // Ultra High Vt NMOS Implant
LAYER UHVT_Pi    94  // Ultra High Vt PMOS Implant
LAYER CBDi       169 // CBD For solder Bump and RDL layer 
LAYER UBMi       170 // UBM For solder Bump and RDL layer 
LAYER RH         117  // Form P+OD/POLY resistor & N+OD/POLY resistor with RPO
LAYER ESD3       147  // Layer for DRC and logic operation to form ESD implant
LAYER VARi       143  // For both MOS and junction type varactor
LAYER APi        74   // ALRDL
LAYER Cu_PPIi    7410 // Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP
LAYER MAP 74 DATATYPE 10 7410
LAYER CBMi       88   // MIM Capacitor Bottom Metal
LAYER CTMi       77   // MIM Capacitor Top Metal
LAYER RVi        85   // Via hole between AP and top metal 
LAYER DCOi       90   // Dual Core oxide layer used to cover G core device
LAYER HVD_N      8101 // Define N-HVMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 1 8101 
LAYER HVD_P      8102 // Define P-HVMOS drain side where sustains high voltage
LAYER MAP 91 DATATYPE 2 8102 
LAYER HVD_N_nw   8103 // Define N-HVMOS drain side where sustains high voltage (NW approach)
LAYER MAP 91 DATATYPE 3 8103 

LAYER BJTDMY     110  // BJT dummy layer
LAYER NWDMY      114  // NWEL resistor dummy layer
LAYER RPDMY      115  // dummy layer to cover od/poly resistor wi/wo silicide
LAYER PMDMY      106  // dummy layer to cover fuse window and protection ring structure
LAYER SDI        122  // cover IO ESD area
LAYER ESD1DMY    145
LAYER ESD2DMY    146
LAYER LMARK      109  // Alignment Mark Rule for Laser Repair
LAYER SRM        410  // Layer to cover SRAM Cell
LAYER MAP 50 DATATYPE 0 410 
LAYER CSRDMY	 166  // Layer to cover chip corner areas
LAYER CDUDMY     165  // Dummy layer to cover CDU pattern on assembly isolation.
LAYER TCDDMY     1651 // Dummy layer to cover TCD pattern.
LAYER MAP 165 DATATYPE 1  1651
LAYER LOGO       158  // Dummy layer for product labels and LOGO
LAYER INDDMY     1440   // Dummy layer for inductor
LAYER MAP 144 DATATYPE >=0 <=14 1440

LAYER IND_CTAP   1441   // Dummy layer for inductor center tap
LAYER MAP 144 DATATYPE 34 1441
LAYER CTMDMY     1480    // Dummy layer for MIM capacitor
LAYER MAP 148 DATATYPE 0 1480
LAYER CTMDMY_10   1481    // Dummy layer for 1.0fF/um2 MIM capacitor
LAYER MAP 148 DATATYPE 110 1481
LAYER CTMDMY_15   1482    // Dummy layer for 1.5fF/um2 MIM capacitor
LAYER MAP 148 DATATYPE 115 1482
LAYER CTMDMY_20   1483    // Dummy layer for 2.0fF/um2 MIM capacitor
LAYER MAP 148 DATATYPE 120 1483
LAYER  MOMDMY_1  1551     // Dummy layer for M1 MOM region
LAYER MAP 155 DATATYPE 1 1551
LAYER  MOMDMY_2  1552     // Dummy layer for M2 MOM region
LAYER MAP 155 DATATYPE 2 1552
LAYER  MOMDMY_3  1553     // Dummy layer for M3 MOM region
LAYER MAP 155 DATATYPE 3 1553
LAYER  MOMDMY_4  1554     // Dummy layer for M4 MOM region
LAYER MAP 155 DATATYPE 4 1554
LAYER  MOMDMY_5  1555     // Dummy layer for M5 MOM region
LAYER MAP 155 DATATYPE 5 1555
LAYER  MOMDMY_6  1556     // Dummy layer for M6 MOM region
LAYER MAP 155 DATATYPE 6 1556
LAYER  MOMDMY_AP 1570            // Dummy layer for AP MOM region
LAYER MAP 155 DATATYPE 20 1570
LAYER  RTMOMDMY  1571            // Dummy layer for RTMOM 
LAYER MAP 155 DATATYPE 21 1571
LAYER MOMDMY_ALL 1550
LAYER MAP 155 DATATYPE >=1 <=9 1550
LAYER MAP 155 DATATYPE >=20 <=21 1550
LAYER RFDMY      161  // For RF circuit
LAYER WBDMY      157  // For CUP purpose
LAYER DIODMY     119  // Dummy layer for diode
LAYER SRAMDMY    400  // SRAM DRC violations waive layer		
LAYER MAP 186 DATATYPE 0 400  		
LAYER SRAMDMY_4    401  // SRAM periphrial region for 0.525 um2, 0.62um2, 0.974um2, 1.158um2
LAYER MAP 186 DATATYPE 4 401 
LAYER SRAMDMY_5     402  // SRAM periphrial region for 0.499 um2 
LAYER MAP 186 DATATYPE 5 402 
SRAMDMY_PERI = SRAMDMY_4 OR SRAMDMY_5
LAYER SRAMDMY_1  403          // pass gate region in sram cell
LAYER MAP 186 DATATYPE 1 403 
LAYER RAM1TDMY    460         // dummy layer to define 1T-MIM region
LAYER MAP 160 DATATYPE 0 460 
LAYER OD1Ti      27
LAYER CLDDi      92           // 1T-MIM Cell CLDD
LAYER CROWNi     102
LAYER P3i        103
LAYER SNCTi      101
LAYER LUPWDMY     2551     // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551
LAYER VDDDMY    2554    // DRC dummy layer to identify VDD PAD for Latch-Up rules.
LAYER MAP 255 DATATYPE 4 2554
LAYER VSSDMY    2555    // DRC dummy layer to identify VSS PAD for Latch-Up rules.
LAYER MAP 255 DATATYPE 5 2555
LAYER EMPTYi     999   // An Empty layer for DRC coding




LAYER M1i         501                       // Metal1 layer
LAYER MAP 31 DATATYPE 0  501           // Mapping (31;0) to 501 for M1i
LAYER MAP 31 DATATYPE 7  501           // Mapping (DM1_O, 31;7) to 501 for M1i, OPC dummy metal
LAYER M1_real     521                      // Metal1 layer (drawing metal)
LAYER MAP 31 DATATYPE 0  521          // Mapping (31;0) to 521 for M1i
LAYER DM1_O       781 
LAYER MAP 31 DATATYPE 7  781          // Mapping (DM1_O, 31;7) to 781 for OPC_M1i, OPC dummy metal
LAYER DUM1        541                      // dummy Metal1
LAYER MAP 31 DATATYPE 1  541          // Mapping (31;1) to 541 for DUM1
LAYER NOUSEM1     581                 
LAYER MAP 31 DATATYPE 20 581          // Mapping (31;20) to 581 for forbidden
LAYER MAP 31 DATATYPE 21 581          // Mapping (31;21) to 581 for forbidden
LAYER MAP 31 DATATYPE 40 581          // Mapping (31;40) to 581 for forbidden
LAYER MAP 31 DATATYPE 41 581          // Mapping (31;41) to 581 for forbidden
LAYER MAP 31 DATATYPE 60 581          // Mapping (31;60) to 581 for forbidden
LAYER MAP 31 DATATYPE 61 581          // Mapping (31;61) to 581 for forbidden
LAYER MAP 31 DATATYPE 80 581          // Mapping (31;80) to 581 for forbidden
LAYER MAP 31 DATATYPE 81 581          // Mapping (31;81) to 581 for forbidden
LAYER NOTUSEM1    621                       
LAYER MAP 31 DATATYPE >=161 <=165 621 // TSMC internal mask making layer (31;161-165)
LAYER DM1EXCL  371
LAYER MAP 150 DATATYPE 1 371

LAYER M2i         502                       // Metal2 layer
LAYER MAP 32 DATATYPE 0  502           // Mapping (32;0) to 502 for M2i
LAYER MAP 32 DATATYPE 7  502           // Mapping (DM2_O, 32;7) to 502 for M2i, OPC dummy metal
LAYER M2_real     522                      // Metal2 layer (drawing metal)
LAYER MAP 32 DATATYPE 0  522          // Mapping (32;0) to 522 for M2i
LAYER DM2_O       782 
LAYER MAP 32 DATATYPE 7  782          // Mapping (DM2_O, 32;7) to 782 for OPC_M2i, OPC dummy metal
LAYER DUM2        542                      // dummy Metal2
LAYER MAP 32 DATATYPE 1  542          // Mapping (32;1) to 542 for DUM2
LAYER NOUSEM2     582                 
LAYER MAP 32 DATATYPE 20 582          // Mapping (32;20) to 582 for forbidden
LAYER MAP 32 DATATYPE 21 582          // Mapping (32;21) to 582 for forbidden
LAYER MAP 32 DATATYPE 40 582          // Mapping (32;40) to 582 for forbidden
LAYER MAP 32 DATATYPE 41 582          // Mapping (32;41) to 582 for forbidden
LAYER MAP 32 DATATYPE 60 582          // Mapping (32;60) to 582 for forbidden
LAYER MAP 32 DATATYPE 61 582          // Mapping (32;61) to 582 for forbidden
LAYER MAP 32 DATATYPE 80 582          // Mapping (32;80) to 582 for forbidden
LAYER MAP 32 DATATYPE 81 582          // Mapping (32;81) to 582 for forbidden
LAYER NOTUSEM2    622                       
LAYER MAP 32 DATATYPE >=161 <=165 622 // TSMC internal mask making layer (32;161-165)
LAYER DM2EXCL  372
LAYER MAP 150 DATATYPE 2 372

LAYER M3i         503                       // Metal3 layer
LAYER MAP 33 DATATYPE 0  503           // Mapping (33;0) to 503 for M3i
LAYER MAP 33 DATATYPE 7  503           // Mapping (DM3_O, 33;7) to 503 for M3i, OPC dummy metal
LAYER M3_real     523                      // Metal3 layer (drawing metal)
LAYER MAP 33 DATATYPE 0  523          // Mapping (33;0) to 523 for M3i
LAYER DM3_O       783 
LAYER MAP 33 DATATYPE 7  783          // Mapping (DM3_O, 33;7) to 783 for OPC_M3i, OPC dummy metal
LAYER DUM3        543                      // dummy Metal3
LAYER MAP 33 DATATYPE 1  543          // Mapping (33;1) to 543 for DUM3
LAYER NOUSEM3     583                 
LAYER MAP 33 DATATYPE 20 583          // Mapping (33;20) to 583 for forbidden
LAYER MAP 33 DATATYPE 21 583          // Mapping (33;21) to 583 for forbidden
LAYER MAP 33 DATATYPE 40 583          // Mapping (33;40) to 583 for forbidden
LAYER MAP 33 DATATYPE 41 583          // Mapping (33;41) to 583 for forbidden
LAYER MAP 33 DATATYPE 60 583          // Mapping (33;60) to 583 for forbidden
LAYER MAP 33 DATATYPE 61 583          // Mapping (33;61) to 583 for forbidden
LAYER MAP 33 DATATYPE 80 583          // Mapping (33;80) to 583 for forbidden
LAYER MAP 33 DATATYPE 81 583          // Mapping (33;81) to 583 for forbidden
LAYER NOTUSEM3    623                       
LAYER MAP 33 DATATYPE >=161 <=165 623 // TSMC internal mask making layer (33;161-165)
LAYER DM3EXCL  373
LAYER MAP 150 DATATYPE 3 373

LAYER M4i         504                       // Metal4 layer
LAYER MAP 34 DATATYPE 0  504           // Mapping (34;0) to 504 for M4i
LAYER MAP 34 DATATYPE 7  504           // Mapping (DM4_O, 34;7) to 504 for M4i, OPC dummy metal
LAYER M4_real     524                      // Metal4 layer (drawing metal)
LAYER MAP 34 DATATYPE 0  524          // Mapping (34;0) to 524 for M4i
LAYER DM4_O       784 
LAYER MAP 34 DATATYPE 7  784          // Mapping (DM4_O, 34;7) to 784 for OPC_M4i, OPC dummy metal
LAYER DUM4        544                      // dummy Metal4
LAYER MAP 34 DATATYPE 1  544          // Mapping (34;1) to 544 for DUM4
LAYER NOUSEM4     584                 
LAYER MAP 34 DATATYPE 20 584          // Mapping (34;20) to 584 for forbidden
LAYER MAP 34 DATATYPE 21 584          // Mapping (34;21) to 584 for forbidden
LAYER MAP 34 DATATYPE 40 584          // Mapping (34;40) to 584 for forbidden
LAYER MAP 34 DATATYPE 41 584          // Mapping (34;41) to 584 for forbidden
LAYER MAP 34 DATATYPE 60 584          // Mapping (34;60) to 584 for forbidden
LAYER MAP 34 DATATYPE 61 584          // Mapping (34;61) to 584 for forbidden
LAYER MAP 34 DATATYPE 80 584          // Mapping (34;80) to 584 for forbidden
LAYER MAP 34 DATATYPE 81 584          // Mapping (34;81) to 584 for forbidden
LAYER NOTUSEM4    624                       
LAYER MAP 34 DATATYPE >=161 <=165 624 // TSMC internal mask making layer (34;161-165)
LAYER DM4EXCL  374
LAYER MAP 150 DATATYPE 4 374

LAYER M5_OLD      505                       // Metal5 layer
LAYER MAP 35 DATATYPE 0  505           // Mapping (35;0) to 505 for M5i
LAYER M5_NEW      525                      // Metal5 layer
LAYER MAP 35 DATATYPE 40 525          // Mapping (35;40) to 525 for M5i
#IFDEF MIXED_SCHEME
M5i = M5_OLD OR M5_NEW
#ELSE
M5i = COPY M5_NEW
#ENDIF
LAYER DUM5_OLD    545         
LAYER MAP 35 DATATYPE 1  545
LAYER DUM5_NEW    565
LAYER MAP 35 DATATYPE 41 565
#IFDEF MIXED_SCHEME
DUM5 = DUM5_OLD OR DUM5_NEW
#ELSE
DUM5 = COPY DUM5_NEW
#ENDIF
LAYER NOUSEM5_NEW 585
LAYER MAP 35 DATATYPE 0  585
LAYER MAP 35 DATATYPE 1  585
LAYER NOUSEM5_OLD 605
LAYER MAP 35 DATATYPE 20 605
LAYER MAP 35 DATATYPE 21 605
LAYER MAP 35 DATATYPE 60 605
LAYER MAP 35 DATATYPE 61 605
LAYER MAP 35 DATATYPE 80 605
LAYER MAP 35 DATATYPE 81 605
#IFDEF MIXED_SCHEME
NOUSEM5 = COPY NOUSEM5_OLD
#ELSE
NOUSEM5 = NOUSEM5_NEW OR NOUSEM5_OLD
#ENDIF
LAYER NOTUSEM5   625                       
LAYER MAP 35 DATATYPE >=161 <=165 625 // TSMC internal mask making layer (35;161-165)
LAYER DM5EXCL  375
LAYER MAP 150 DATATYPE 5 375

LAYER M6_OLD      506                       // Metal6 layer
LAYER MAP 36 DATATYPE 0  506           // Mapping (36;0) to 506 for M6i
LAYER M6_NEW      526                      // Metal6 layer
LAYER MAP 36 DATATYPE 60 526          // Mapping (36;60) to 526 for M6i
#IFDEF MIXED_SCHEME
M6i = M6_OLD OR M6_NEW
#ELSE
M6i = COPY M6_NEW
#ENDIF
LAYER DUM6_OLD    546         
LAYER MAP 36 DATATYPE 1  546
LAYER DUM6_NEW    566
LAYER MAP 36 DATATYPE 61 566
#IFDEF MIXED_SCHEME
DUM6 = DUM6_OLD OR DUM6_NEW
#ELSE
DUM6 = COPY DUM6_NEW
#ENDIF
LAYER NOUSEM6_NEW 586
LAYER MAP 36 DATATYPE 0  586
LAYER MAP 36 DATATYPE 1  586
LAYER NOUSEM6_OLD 606
LAYER MAP 36 DATATYPE 20 606
LAYER MAP 36 DATATYPE 21 606
LAYER MAP 36 DATATYPE 40 606
LAYER MAP 36 DATATYPE 41 606
LAYER MAP 36 DATATYPE 80 606
LAYER MAP 36 DATATYPE 81 606
#IFDEF MIXED_SCHEME
NOUSEM6 = COPY NOUSEM6_OLD
#ELSE
NOUSEM6 = NOUSEM6_NEW OR NOUSEM6_OLD
#ENDIF
LAYER NOTUSEM6   626                       
LAYER MAP 36 DATATYPE >=161 <=165 626 // TSMC internal mask making layer (36;161-165)
LAYER DM6EXCL  376
LAYER MAP 150 DATATYPE 6 376

LAYER M7_OLD      507                       // Metal7 layer
LAYER MAP 37 DATATYPE 0  507           // Mapping (37;0) to 507 for M7i
LAYER M7_NEW      527                      // Metal7 layer
LAYER MAP 37 DATATYPE 40 527          // Mapping (37;40) to 527 for M7i
#IFDEF MIXED_SCHEME
M7i = M7_OLD OR M7_NEW
#ELSE
M7i = COPY M7_NEW
#ENDIF
LAYER DUM7_OLD    547         
LAYER MAP 37 DATATYPE 1  547
LAYER DUM7_NEW    567
LAYER MAP 37 DATATYPE 41 567
#IFDEF MIXED_SCHEME
DUM7 = DUM7_OLD OR DUM7_NEW
#ELSE
DUM7 = COPY DUM7_NEW
#ENDIF
LAYER NOUSEM7_NEW 587
LAYER MAP 37 DATATYPE 0  587
LAYER MAP 37 DATATYPE 1  587
LAYER NOUSEM7_OLD 607
LAYER MAP 37 DATATYPE 20 607
LAYER MAP 37 DATATYPE 21 607
LAYER MAP 37 DATATYPE 60 607
LAYER MAP 37 DATATYPE 61 607
LAYER MAP 37 DATATYPE 80 607
LAYER MAP 37 DATATYPE 81 607
#IFDEF MIXED_SCHEME
NOUSEM7 = COPY NOUSEM7_OLD
#ELSE
NOUSEM7 = NOUSEM7_NEW OR NOUSEM7_OLD
#ENDIF
LAYER NOTUSEM7   627                       
LAYER MAP 37 DATATYPE >=161 <=165 627 // TSMC internal mask making layer (37;161-165)
LAYER DM7EXCL  377
LAYER MAP 150 DATATYPE 7 377

LAYER VIA1i      801
LAYER MAP 51 DATATYPE 0  801
LAYER NOUSEV1    821  
LAYER MAP 51 DATATYPE 20 821    // Mapping (51;20) to 821 for forbidden
LAYER MAP 51 DATATYPE 40 821    // Mapping (51;40) to 821 for forbidden
LAYER MAP 51 DATATYPE 80 821    // Mapping (51;80) to 821 for forbidden

LAYER VIA2i      802
LAYER MAP 52 DATATYPE 0  802
LAYER NOUSEV2    822  
LAYER MAP 52 DATATYPE 20 822    // Mapping (52;20) to 822 for forbidden
LAYER MAP 52 DATATYPE 40 822    // Mapping (52;40) to 822 for forbidden
LAYER MAP 52 DATATYPE 80 822    // Mapping (52;80) to 822 for forbidden

LAYER VIA3i      803
LAYER MAP 53 DATATYPE 0  803
LAYER NOUSEV3    823  
LAYER MAP 53 DATATYPE 20 823    // Mapping (53;20) to 823 for forbidden
LAYER MAP 53 DATATYPE 40 823    // Mapping (53;40) to 823 for forbidden
LAYER MAP 53 DATATYPE 80 823    // Mapping (53;80) to 823 for forbidden

LAYER VIA4_OLD      804               
LAYER MAP 54 DATATYPE 0 804
LAYER VIA4_NEW      814
LAYER MAP 54 DATATYPE 40  814
#IFDEF MIXED_SCHEME
VIA4i = VIA4_OLD OR VIA4_NEW
#ELSE
VIA4i = COPY VIA4_NEW
#ENDIF
LAYER NOUSEV4_NEW    824
LAYER MAP 54 DATATYPE 0 824
LAYER NOUSEV4_OLD    834
LAYER MAP 54 DATATYPE 20 834
LAYER MAP 54 DATATYPE 80 834
#IFDEF MIXED_SCHEME
NOUSEV4 = COPY NOUSEV4_OLD
#ELSE
NOUSEV4 = NOUSEV4_NEW OR NOUSEV4_OLD
#ENDIF


LAYER VIA5_OLD      805               
LAYER MAP 55 DATATYPE 0 805
LAYER VIA5_NEW      815
LAYER MAP 55 DATATYPE 40  815
#IFDEF MIXED_SCHEME
VIA5i = VIA5_OLD OR VIA5_NEW
#ELSE
VIA5i = COPY VIA5_NEW
#ENDIF
LAYER NOUSEV5_NEW    825
LAYER MAP 55 DATATYPE 0 825
LAYER NOUSEV5_OLD    835
LAYER MAP 55 DATATYPE 20 835
LAYER MAP 55 DATATYPE 80 835
#IFDEF MIXED_SCHEME
NOUSEV5 = COPY NOUSEV5_OLD
#ELSE
NOUSEV5 = NOUSEV5_NEW OR NOUSEV5_OLD
#ENDIF


LAYER VIA6_OLD      806               
LAYER MAP 56 DATATYPE 0 806
LAYER VIA6_NEW      816
LAYER MAP 56 DATATYPE 40  816
#IFDEF MIXED_SCHEME
VIA6i = VIA6_OLD OR VIA6_NEW
#ELSE
VIA6i = COPY VIA6_NEW
#ENDIF
LAYER NOUSEV6_NEW    826
LAYER MAP 56 DATATYPE 0 826
LAYER NOUSEV6_OLD    836
LAYER MAP 56 DATATYPE 20 836
LAYER MAP 56 DATATYPE 80 836
#IFDEF MIXED_SCHEME
NOUSEV6 = COPY NOUSEV6_OLD
#ELSE
NOUSEV6 = NOUSEV6_NEW OR NOUSEV6_OLD
#ENDIF





LAYER ODi  355 7 8
LAYER MAP 6 DATATYPE 0 355
LAYER MAP 6 DATATYPE 2 355
LAYER MAP 6 DATATYPE >=4 <=160 355
LAYER MAP 6 DATATYPE >=166 <=255 355
LAYER ODi_RFDRAIN 351 
LAYER MAP 6 DATATYPE 3 351
LAYER ODi_SRAM    352 
LAYER MAP 6 DATATYPE 11 352
LAYER MAP 6 DATATYPE 12 352
LAYER MAP 6 DATATYPE 13 352
LAYER ODi_OTHERS  354 7 8
LAYER MAP 6 DATATYPE 2 354
LAYER MAP 6 DATATYPE >=4 <=160 354
LAYER MAP 6 DATATYPE >=166 <=255 354
LAYER DOD      353
LAYER MAP 6 DATATYPE 1 353  // Mapping (6;1) to 353 for dummy OD
LAYER NOTUSEOD 1616
LAYER MAP 6 DATATYPE >=161 <=165 1616  // TSMC internal mask making layer (6;161-165)

LAYER POi  365
LAYER MAP 17 DATATYPE 0 365
LAYER MAP 17 DATATYPE >=2 <=50 365
LAYER MAP 17 DATATYPE >=52 <=160 365
LAYER MAP 17 DATATYPE >=166 <=255 365
LAYER POi_SRAM 363            
LAYER MAP 17 DATATYPE 11 363 
LAYER MAP 17 DATATYPE 12 363 
LAYER MAP 17 DATATYPE 13 363 
LAYER POi_OTHERS 364            
LAYER MAP 17 DATATYPE >=2 <=50 364
LAYER MAP 17 DATATYPE >=52 <=160 364
LAYER MAP 17 DATATYPE >=166 <=255 364
LAYER DPO      361
LAYER MAP 17 DATATYPE 1 361  // Mapping (17;1) to 361 for dummy PO
LAYER mVTLi    362	     // Used to generate poly logical operation in N65LP LVT process
LAYER MAP 17 DATATYPE 51 362 // Mapping (17;51, layer PO, purpose rule1) to 362 for mVTLi
LAYER NOTUSEPO 1716
LAYER MAP 17 DATATYPE >=161 <=165 1716   // TSMC internal mask making layer (17;161-165)

LAYER ODBLK  382
LAYER MAP 150 DATATYPE 20 382
LAYER POBLK  383
LAYER MAP 150 DATATYPE 21 383

LAYER MAP 182 DATATYPE 1 1821
LAYER RRuleRequired 1821        // marker layer for DFM action-required rules
LAYER MAP 182 DATATYPE 2 1822
LAYER RRuleRecommended 1822	// marker layer for DFM recommendations
LAYER MAP 182 DATATYPE 3 1823
LAYER RRuleAnalog 1823		// marker layer for analog rules and recommendations
LAYER MAP 182 DATATYPE 4 1824
LAYER RRuleGuideline 1824	// marker layer for DFM guidelines
LAYER MAP 182 DATATYPE 11 1831
LAYER excludeRRuleRequired 1831  // marker layer for excluding DFM action-required rules
LAYER MAP 182 DATATYPE 12 1832
LAYER excludeRRuleRecommended 1832 // marker layer for excluding DFM recommendations
LAYER MAP 182 DATATYPE 13 1833
LAYER excludeRRuleAnalog 1833	   // marker layer for excluding analog rules and recommendations
LAYER MAP 182 DATATYPE 14 1834
LAYER excludeRRuleGuideline 1834   // marker layer for excluding DFM guidelines




ALL_OD = ODi OR DOD
ALL_POLY = POi OR DPO

// metal in silicon
M1x = M1i OR DUM1 
M2x = M2i OR DUM2 
M3x = M3i OR DUM3 
M4x = M4i OR DUM4 
M5x = M5i OR DUM5 
M6x = M6i OR DUM6 



LAYOUT BASE LAYER OD_18i OD_25i OD_33i DCOi NT_Ni VTH_Ni VTH_Pi VTL_Ni VTL_Pi
LAYOUT BASE LAYER DNWi NWi ODi POi PPi NPi COi
LAYOUT TOP LAYER VIA1i M2i


LAYOUT TOP LAYER VIA2i M3i


LAYOUT TOP LAYER VIA3i M4i


LAYOUT TOP LAYER VIA4_OLD VIA4_NEW M5_OLD M5_NEW


LAYOUT TOP LAYER VIA5_OLD VIA5_NEW M6_OLD M6_NEW


LAYOUT TOP LAYER VIA6_OLD VIA6_NEW M7_OLD M7_NEW


LAYOUT TOP LAYER CBi CBDi UBMi WBDMY FWALi FWCUi PMi APi PMDMY LMARK SEALRINGi CSRDMY
LAYOUT TOP LAYER NWDMY SDI 
LAYOUT TOP LAYER SDI ESD1DMY ESD2DMY ESD3 SRM SRAMDMY LOGO
LAYOUT TOP LAYER DOD DPO ODBLK POBLK
LAYOUT TOP LAYER CBMi CTMi CTMDMY INDDMY VARi
LAYOUT TOP LAYER DUM1 DM1EXCL


LAYOUT TOP LAYER DUM2 DM2EXCL


LAYOUT TOP LAYER DUM3 DM3EXCL


LAYOUT TOP LAYER DUM4 DM4EXCL


LAYOUT TOP LAYER DUM5_OLD DUM5_NEW DM5EXCL


LAYOUT TOP LAYER DUM6_OLD DUM6_NEW DM6EXCL


LAYOUT TOP LAYER DUM7_OLD DUM7_NEW DM7EXCL




SRAM_EXCLUDE = COPY SRAMDMY



DNWi_EXTENT = EXTENT DNWi
NWi_EXTENT = EXTENT NWi
OD_18i_EXTENT = EXTENT OD_18i
OD_25i_EXTENT = EXTENT OD_25i
OD_33i_EXTENT = EXTENT OD_33i
OD_DECAP_EXTENT = EXTENT OD_DECAP
PPi_EXTENT = EXTENT PPi
NPi_EXTENT = EXTENT NPi
CBi_EXTENT = EXTENT CBi
CB2i_EXTENT = EXTENT CB2i
RPOi_EXTENT = EXTENT RPOi
NT_Ni_EXTENT = EXTENT NT_Ni
FWALi_EXTENT = EXTENT FWALi
FWCUi_EXTENT = EXTENT FWCUi
POFUSE_EXTENT = EXTENT POFUSE
FUSELINK_EXTENT = EXTENT FUSELINK
PMi_EXTENT = EXTENT PMi
PM1i_EXTENT = EXTENT PM1i
PM2i_EXTENT = EXTENT PM2i
VTH_Ni_EXTENT = EXTENT VTH_Ni
VTH_Pi_EXTENT = EXTENT VTH_Pi
VTL_Ni_EXTENT = EXTENT VTL_Ni
VTL_Pi_EXTENT = EXTENT VTL_Pi
UHVT_Ni_EXTENT = EXTENT UHVT_Ni
UHVT_Pi_EXTENT = EXTENT UHVT_Pi
CBDi_EXTENT = EXTENT CBDi
UBMi_EXTENT = EXTENT UBMi
RH_EXTENT = EXTENT RH
ESD3_EXTENT = EXTENT ESD3
VARi_EXTENT = EXTENT VARi
APi_EXTENT = EXTENT APi
Cu_PPIi_EXTENT = EXTENT Cu_PPIi
CBMi_EXTENT = EXTENT CBMi
CTMi_EXTENT = EXTENT CTMi
RVi_EXTENT = EXTENT RVi
DCOi_EXTENT = EXTENT DCOi
HVD_N_EXTENT = EXTENT HVD_N
HVD_P_EXTENT = EXTENT HVD_P
HVD_N_nw_EXTENT = EXTENT HVD_N_nw
BJTDMY_EXTENT = EXTENT BJTDMY
LMARK_EXTENT = EXTENT LMARK
SRM_EXTENT = EXTENT SRM
TCDDMY_EXTENT = EXTENT TCDDMY
SRAMDMY_EXTENT = EXTENT SRAMDMY
SRAMDMY_4_EXTENT = EXTENT SRAMDMY_4
SRAMDMY_5_EXTENT = EXTENT SRAMDMY_5
SRAMDMY_1_EXTENT = EXTENT SRAMDMY_1
OD1Ti_EXTENT = EXTENT OD1Ti
CLDDi_EXTENT = EXTENT CLDDi
CROWNi_EXTENT = EXTENT CROWNi
P3i_EXTENT = EXTENT P3i
SNCTi_EXTENT = EXTENT SNCTi
LUPWDMY_EXTENT = EXTENT LUPWDMY
VDDDMY_EXTENT = EXTENT VDDDMY
VSSDMY_EXTENT = EXTENT VSSDMY
M1i_EXTENT = EXTENT M1i
M1_real_EXTENT = EXTENT M1_real
DM1_O_EXTENT = EXTENT DM1_O
DUM1_EXTENT = EXTENT DUM1
M2i_EXTENT = EXTENT M2i
M2_real_EXTENT = EXTENT M2_real
DM2_O_EXTENT = EXTENT DM2_O
DUM2_EXTENT = EXTENT DUM2
M3i_EXTENT = EXTENT M3i
M3_real_EXTENT = EXTENT M3_real
DM3_O_EXTENT = EXTENT DM3_O
DUM3_EXTENT = EXTENT DUM3
M4i_EXTENT = EXTENT M4i
M4_real_EXTENT = EXTENT M4_real
DM4_O_EXTENT = EXTENT DM4_O
DUM4_EXTENT = EXTENT DUM4
M5_OLD_EXTENT = EXTENT M5_OLD
M5_NEW_EXTENT = EXTENT M5_NEW
DUM5_OLD_EXTENT = EXTENT DUM5_OLD
DUM5_NEW_EXTENT = EXTENT DUM5_NEW
M6_OLD_EXTENT = EXTENT M6_OLD
M6_NEW_EXTENT = EXTENT M6_NEW
DUM6_OLD_EXTENT = EXTENT DUM6_OLD
DUM6_NEW_EXTENT = EXTENT DUM6_NEW
M7_OLD_EXTENT = EXTENT M7_OLD
M7_NEW_EXTENT = EXTENT M7_NEW
DUM7_OLD_EXTENT = EXTENT DUM7_OLD
DUM7_NEW_EXTENT = EXTENT DUM7_NEW
ODi_EXTENT = EXTENT ODi
DOD_EXTENT = EXTENT DOD
POi_EXTENT = EXTENT POi
DPO_EXTENT = EXTENT DPO
mVTLi_EXTENT = EXTENT mVTLi


 MT_LAYERS =  ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((DNWi_EXTENT OR NWi_EXTENT) OR OD_18i_EXTENT) OR OD_25i_EXTENT) OR OD_33i_EXTENT) OR OD_DECAP_EXTENT) OR PPi_EXTENT) OR NPi_EXTENT) OR CBi_EXTENT) OR CB2i_EXTENT) OR RPOi_EXTENT) OR NT_Ni_EXTENT) OR FWALi_EXTENT) OR FWCUi_EXTENT) OR POFUSE_EXTENT) OR FUSELINK_EXTENT) OR PMi_EXTENT) OR PM1i_EXTENT) OR PM2i_EXTENT) OR VTH_Ni_EXTENT) OR VTH_Pi_EXTENT) OR VTL_Ni_EXTENT) OR VTL_Pi_EXTENT) OR UHVT_Ni_EXTENT) OR UHVT_Pi_EXTENT) OR CBDi_EXTENT) OR UBMi_EXTENT) OR RH_EXTENT) OR ESD3_EXTENT) OR VARi_EXTENT) OR APi_EXTENT) OR Cu_PPIi_EXTENT) OR CBMi_EXTENT) OR CTMi_EXTENT) OR RVi_EXTENT) OR DCOi_EXTENT) OR HVD_N_EXTENT) OR HVD_P_EXTENT) OR HVD_N_nw_EXTENT) OR BJTDMY_EXTENT) OR LMARK_EXTENT) OR SRM_EXTENT) OR TCDDMY_EXTENT) OR SRAMDMY_EXTENT) OR SRAMDMY_4_EXTENT) OR SRAMDMY_5_EXTENT) OR SRAMDMY_1_EXTENT) OR OD1Ti_EXTENT) OR CLDDi_EXTENT) OR CROWNi_EXTENT) OR P3i_EXTENT) OR SNCTi_EXTENT) OR LUPWDMY_EXTENT) OR VDDDMY_EXTENT) OR VSSDMY_EXTENT) OR M1i_EXTENT) OR M1_real_EXTENT) OR DM1_O_EXTENT) OR DUM1_EXTENT) OR M2i_EXTENT) OR M2_real_EXTENT) OR DM2_O_EXTENT) OR DUM2_EXTENT) OR M3i_EXTENT) OR M3_real_EXTENT) OR DM3_O_EXTENT) OR DUM3_EXTENT) OR M4i_EXTENT) OR M4_real_EXTENT) OR DM4_O_EXTENT) OR DUM4_EXTENT) OR M5_OLD_EXTENT) OR M5_NEW_EXTENT) OR DUM5_OLD_EXTENT) OR DUM5_NEW_EXTENT) OR M6_OLD_EXTENT) OR M6_NEW_EXTENT) OR DUM6_OLD_EXTENT) OR DUM6_NEW_EXTENT) OR M7_OLD_EXTENT) OR M7_NEW_EXTENT) OR DUM7_OLD_EXTENT) OR DUM7_NEW_EXTENT) OR ODi_EXTENT) OR DOD_EXTENT) OR POi_EXTENT) OR DPO_EXTENT) OR mVTLi_EXTENT

// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------
#IFDEF ChipWindowUsed
LAYER ChipWindow 500 // layer number for constructing chip boundary
POLYGON xLB yLB xRT yRT ChipWindow
CHIP       = PUSH ChipWindow
#ELSE
CHIP         = EXTENT MT_LAYERS 
//CHIP       = EXTENT 
//CHIP       = EXTENT CELL "*" ORIGINAL 
#ENDIF

CHIPx        = MERGE CHIP
BULK         = SIZE CHIP BY 1.0
PWELi        = BULK NOT NWi
PWEL         = PWELi NOT SRAM_EXCLUDE

// EXCLUDE UNCHECKED REGIONS
//--------------------------

DNW     = DNWi    NOT INSIDE SRAM_EXCLUDE
NWEL    = NWi     NOT INSIDE SRAM_EXCLUDE
OD      = ODi     NOT SRAM_EXCLUDE
ODs     = ODi     NOT INSIDE SRAM_EXCLUDE
OD_18   = OD_18i  NOT SRAM_EXCLUDE
OD_25   = OD_25i  NOT SRAM_EXCLUDE
OD_33   = OD_33i  NOT SRAM_EXCLUDE
POLY    = POi     NOT SRAM_EXCLUDE
POLYs   = POi     NOT INSIDE SRAM_EXCLUDE
PP      = PPi     NOT INSIDE SRAM_EXCLUDE
NP      = NPi     NOT INSIDE SRAM_EXCLUDE
VTHN    = VTH_Ni  NOT SRAM_EXCLUDE
VTHNs   = VTH_Ni  NOT INSIDE SRAM_EXCLUDE
VTHP    = VTH_Pi  NOT SRAM_EXCLUDE
VTHPs   = VTH_Pi  NOT INSIDE SRAM_EXCLUDE
VTLN    = VTL_Ni  NOT SRAM_EXCLUDE
VTLNs   = VTL_Ni  NOT INSIDE SRAM_EXCLUDE
VTLP    = VTL_Pi  NOT SRAM_EXCLUDE
VTLPs   = VTL_Pi  NOT INSIDE SRAM_EXCLUDE
RPO     = RPOi    NOT SRAM_EXCLUDE
RPOs    = RPOi    NOT INSIDE SRAM_EXCLUDE
NTN     = NT_Ni   NOT SRAM_EXCLUDE
NTNs    = NT_Ni   NOT INSIDE SRAM_EXCLUDE
NCap_NTN =  NCap_NTNi NOT SRAM_EXCLUDE  
CO      = COi     NOT SRAM_EXCLUDE
COs     = COi     NOT INSIDE SRAM_EXCLUDE
M1      = M1i     NOT SRAM_EXCLUDE
M1s     = M1i     NOT INSIDE SRAM_EXCLUDE
VIA1    = VIA1i   NOT SRAM_EXCLUDE
VIA1s   = VIA1i   NOT INSIDE SRAM_EXCLUDE
DCO     = DCOi    NOT SRAM_EXCLUDE
DCOs    = DCOi    NOT INSIDE SRAM_EXCLUDE
M2      = COPY M2i 
VIA2    = COPY VIA2i
M3      = COPY M3i 
VIA3    = COPY VIA3i
M4      = COPY M4i 
VIA4    = COPY VIA4i
M5      = COPY M5i 
VIA5    = COPY VIA5i
M6      = COPY M6i 
VIA6    = COPY VIA6i
M7      = COPY M7i 
AP      = COPY APi
CB      = COPY CBi  
CB2     = COPY CB2i
CBD     = COPY CBDi
UBM     = COPY UBMi
RV      = COPY RVi
FW      = COPY FWi
FW_AP   = COPY FWALi
FW_Cu   = COPY FWCUi
PM      = COPY PMi  
CBM     = COPY CBMi
CTM     = COPY CTMi
VAR	= COPY VARi
mVTL    = COPY mVTLi

#IFDEF WLCSP_SEALRING
ALL_PAD = COPY CB2i
#ELSE
ALL_PAD = (CBi OR CBDi) OR RVi
#ENDIF
UBM_MT = UBMi INTERACT CBDi
UBM_EXC = SIZE UBM_MT BY 5 INSIDE OF M6i STEP M6_S_1*0.7
CBMT = SIZE CBi BY 5 INSIDE OF M6i STEP M6_S_1*0.7
MTOP_EXC = CBMT OR UBM_EXC	// For high-density limit and max. width rule
CB_NON_CUP = CB NOT INTERACT WBDMY

LMARK_METAL = M6i AND LMARK
LSLOT = HOLES LMARK_METAL EMPTY  // L shaped oxide in L-mark metal in corner
LSOLID = LMARK_METAL NOT INTERACT LSLOT // L solid metal

LMARK_SLOT  = LMARK INTERACT LSLOT 
LMARK_SOLID = LMARK INTERACT LSOLID

IND_EXD = SIZE INDDMY BY 18
M5_MAX_WIDTH = (M5 NOT WBDMY) NOT IND_EXD
M6_MAX_WIDTH = ((M6 NOT MTOP_EXC) NOT LMARK ) NOT IND_EXD
    

OD2 = (OD_18 OR OD_25) OR OD_33
OD2i = (OD_18i OR OD_25i) OR OD_33i

IMP          = NPi OR PPi
NPOD         = OD AND NP
PPOD         = OD AND PP
COOD         = CO AND OD        // Diffusion contacts 
COPO         = CO NOT OD        // POLY contacts + floating contacts

RNWEL = NWEL INTERACT NWDMY	// NWEL resistor (Within OD & STI)
NWRES = RNWEL INTERACT RPO	// NWEL resistor (Within OD)
NONWR = NWEL NOT RNWEL		// NWEL exclude resistor area (Within OD)
ODWR  = OD INTERACT NWRES	// OD area of NW resistor (Within OD)
NPWR  = NP INTERACT NWRES	// N+ implant on NW resistor terminals (Within OD)
COWR  = COOD INTERACT NWRES	// Contact on NW resistor terminals (Within OD)
RHWR  = ODWR NOT RPO		// Silicided terminal of NW resistor (Within OD)
NWRES_STI = RNWEL NOT INTERACT RPO	// NWEL resistor (Under STI)
ODWR_STI = OD INTERACT NWRES_STI	// OD area of NW resistor (Under STI)
NPWR_STI = NP INTERACT NWRES_STI
COWR_STI = COOD INTERACT NWRES_STI	// Contact on NW resistor terminals (Under STI)

NSTP         = NPOD AND NONWR          // NWEL tap diffusion
NACT         = NPOD NOT NWEL           // NMOS device active diffusion
PACT         = PPOD AND NWEL           // PMOS device active diffusion
NACT2        = NACT INTERACT OD2
PACT2        = PACT INTERACT OD2
PSTP         = PPOD NOT NWEL           // Substrate (pwell) tap diffusion
DACT         = NACT OR PACT            // NMOS/PMOS device active diffusion
DSTP         = NSTP OR PSTP

GATE         = POLY AND OD	       // Gate regions for NMOS and PMOS
SD           = (DACT ENCLOSE GATE) NOT GATE  // Source, drain areas
FPO1         = POLY NOT OD             // Field poly
HV_GATE      = GATE AND OD2
LV_GATE      = GATE NOT OD2

DUMMY_GATE   = GATE INTERACT (POLY NOT INTERACT CO)
RF_DUMMY_GATE = DUMMY_GATE INSIDE RFDMY
    
GATE_NP      = GATE AND NP
GATE_PP      = GATE AND PP

GATE_W       = POLY COIN INSIDE EDGE GATE      // Gate width
GATE_L       = GATE NOT COIN INSIDE EDGE POLY  // Coincident edge of interconnect POLY

GATEN_W      = GATE_W INSIDE EDGE NP
GATEP_W      = GATE_W INSIDE EDGE PP

HV_GATE_W    = GATE_W INSIDE EDGE OD2         // 2.5V/3.3V/1.8V MOS gates
LV_GATE_W    = GATE_W NOT INSIDE EDGE OD2     // 1.0V MOS gates
18V_GATE_W   = HV_GATE_W INSIDE EDGE OD_18
25V_GATE_W   = HV_GATE_W INSIDE EDGE OD_25
33V_GATE_W   = HV_GATE_W INSIDE EDGE OD_33

// For poly and od resistors identify
RPDMYi        = RPDMY NOT INTERACT RPOi	  
RPO_RPDMY     = RPOi OR RPDMYi
ILP1          = POLY NOT RPO_RPDMY       // Interconnect poly
ODPO_RES_MARK = ((RPO NOT SDI) NOT BJTDMY) OUTSIDE INDDMY // For unsilicided OD/poly resistors
PORES	      = FPO1 AND ODPO_RES_MARK   // POLY unsilicided resistor region
PORESg        = PORES NOT INTERACT SDI
INOD          = OD NOT RPO_RPDMY
FOD           = (OD OUTSIDE NWDMY) NOT GATE
ODRES         = FOD AND ODPO_RES_MARK	// OD unsilicided resistor region
ODRES_a       = ODRES  AND (RH OR RPDMY)
PORES_a       = PORESg AND (RH OR RPDMY)

AYRE          = ODRES OR PORES		// unsilicided OD/poly resitors
NYRE          = NP AND AYRE
PYRE          = PP AND AYRE

NP_PP_BTE     = NPOD COIN OUTSIDE EDGE PPOD
BUTT_PSTP     = PSTP TOUCH NACT
BUTT_NSTP     = NSTP TOUCH PACT

// For BJT Device
PP_EMOD = PACT AND BJTDMY
NP_EMOD = NACT AND BJTDMY
EMOD = PP_EMOD OR NP_EMOD


RNGX     = PMDMY NOT FW
SEALRING = SEALRINGi NOT RNGX
VIA_EXD  = COPY SEALRINGi
VIA1_EXD = VIA1 NOT VIA_EXD
VIA2_EXD = VIA2 NOT VIA_EXD
VIA3_EXD = VIA3 NOT VIA_EXD
VIA4_EXD = VIA4 NOT VIA_EXD
VIA5_EXD = VIA5 NOT VIA_EXD


//For chip corner stress relief check
#IFDEF FULL_CHIP
CHIP_CORE    = SIZE CHIPx BY -20
#ELSE
CHIP_CORE    = COPY CHIP
#ENDIF


PADH = HOLES (ALL_PAD NOT CHIP_CORE)
SCORE = CHIP_CORE INSIDE PADH		// chip with sealring inside pad ring
CHIP_WISR = CHIPx INTERACT SCORE
SR_EDGE = CHIP_WISR NOT SCORE    
CHIP_NOSR = CHIP NOT INTERACT SR_EDGE
CHIP_EDGE  = CHIP_NOSR OR SCORE  

SR_EXC   = EXT SR_EDGE < 73.87 ABUT == 90 REGION INTERSECTING ONLY

SRCSR = SR_EDGE OR SR_EXC // sealring+corner+assembly isolation

SR_RING = CHIP_WISR NOT ( SIZE (CHIP_WISR NOT SRCSR) BY 10) 
    
EMPTY_AREA = INT CHIP_NOSR < 74 ABUT == 90 REGION INTERSECTING ONLY

CHIP_CHAMFERED = CHIP NOT EMPTY_AREA

#IFDEF FULL_CHIP
DEN_EXC_LOW = (((FWi OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA   // exclude region for low density
DEN_EXC = ((((FWi OR LMARK) OR LOGO) OR INDDMY) OR CSRDMY) OR EMPTY_AREA

#ELSE
DEN_EXC_LOW = ((FWi OR LMARK) OR LOGO) OR INDDMY                // exclude region for low density
DEN_EXC = (((FWi OR LMARK) OR LOGO) OR INDDMY) OR CSRDMY
#ENDIF

METAL_EXC_LOW = COPY DEN_EXC_LOW
METAL_EXC = COPY DEN_EXC

M1_EXC_LOW = COPY METAL_EXC_LOW
M1_EXC = COPY METAL_EXC

M2_EXC_LOW = COPY METAL_EXC_LOW
M2_EXC = COPY METAL_EXC

M3_EXC_LOW = COPY METAL_EXC_LOW
M3_EXC = COPY METAL_EXC

M4_EXC_LOW = METAL_EXC_LOW OR (SIZE CBM BY 1.5)
M4_EXC = COPY METAL_EXC

M5_EXC_LOW = COPY METAL_EXC_LOW
M5_EXC = COPY METAL_EXC

M6_EXC_LOW = COPY METAL_EXC_LOW
M6_EXC = COPY METAL_EXC


SR_M1 = M1 INTERACT SEALRING
SR_M2 = M2 INTERACT SEALRING
SR_M3 = M3 INTERACT SEALRING
SR_M4 = M4 INTERACT SEALRING
SR_M5 = M5 INTERACT SEALRING
SR_M6 = M6 INTERACT SEALRING
CO_BAR = CO INTERACT SEALRINGi
VIA1_BAR = VIA1 INTERACT SEALRINGi 
VIA2_BAR = VIA2 INTERACT SEALRINGi 
VIA3_BAR = VIA3 INTERACT SEALRINGi 
VIA4_BAR = VIA4 INTERACT SEALRINGi 
VIA5_BAR = VIA5 INTERACT SEALRINGi 
SR_CO = CO_BAR INTERACT SEALRING
SR_VIA1 = VIA1_BAR INTERACT SEALRING 
SR_VIA2 = VIA2_BAR INTERACT SEALRING 
SR_VIA3 = VIA3_BAR INTERACT SEALRING 
SR_VIA4 = VIA4_BAR INTERACT SEALRING 
SR_VIA5 = VIA5_BAR INTERACT SEALRING 

// DFM 
Block = ((PMDMY OR LOGO) OR SRCSR) OR LMARK 
VARIABLE BIG_AREA       4000000


// Nodal NWEL connectivity checks

ILP1i = POi NOT RPO_RPDMY	// Interconnect poly
NONWRi = NWi NOT INTERACT NWDMY 
NWRiT = (NWi INTERACT NWDMY) NOT NWDMY // NWR terminal  
RWi = PWELi INSIDE DNWi
NPODi = NPi AND ODi
PPODi = PPi AND ODi
NACTi = NPODi NOT NWi
PACTi = PPODi AND NWi
NSDi  = NACTi NOT POi		// NMOS source/drain
PSDi  = PACTi NOT POi		// PMOS source/drain
NSDc  = NSDi NOT RPO_RPDMY	// NMOS source/drain for connection
PSDc  = PSDi NOT RPO_RPDMY	// PMOS source/drain for connection
NSTPi = NPODi AND NONWRi        // Break the connection at NWR  
PSTPi = PPODi NOT NWi
UBMn = UBMi NOT INTERACT Cu_PPIi
UBMd = UBMi INTERACT Cu_PPIi

CONNECT NWEL DNW 	// For DNW.S.2 check only, not for electrical connection.
CONNECT NSTPi NWi                 
CONNECT NSTPi PSDc	// For butted pickup
CONNECT PSTPi RWi	// For DNW connection
CONNECT PSTPi PWELi     // For DNW connection
CONNECT PSTPi NSDc	// For butted pickup
CONNECT COi PSDc        // For butted CO
CONNECT COi NSDc        // For butted CO
CONNECT COi ILP1i       // For butted CO
CONNECT M1i ILP1i NSTPi PSTPi PSDc NSDc NWRiT BY COi
CONNECT M2i M1i BY VIA1i

CONNECT M3i M2i BY VIA2i

CONNECT M4i M3i BY VIA3i

CONNECT M5i CTMi CBMi M4i BY VIA4i

CONNECT M6i M5i BY VIA5i

CONNECT CBi M6i
// APRDL
CONNECT M6i APi  BY RVi
CONNECT M6i APi  BY CBi
CONNECT M6i APi  BY CBDi
CONNECT CB2i APi
CONNECT CB2i PM1i
CONNECT PM1i Cu_PPIi
CONNECT UBMn APi
CONNECT UBMn M6i BY CBDi
CONNECT UBMd Cu_PPIi BY PM2i

NWu   = COPY NWi
RWu   = COPY RWi
PWELu = COPY PWELi
NWRuT = COPY NWRiT
POu   = COPY POi
NSDu  = COPY NSDi
PSDu  = COPY PSDi
NSTPu = NPODi AND NWi
PSTPu = COPY PSTPi
COu   = COPY COi
M1u   = COPY M1i
VIA1u = COPY VIA1i
M2u   = COPY M2i
VIA2u = COPY VIA2i
M3u   = COPY M3i
VIA3u = COPY VIA3i
M4u   = COPY M4i
VIA4u = COPY VIA4i
M5u   = COPY M5i
VIA5u = COPY VIA5i
M6u   = COPY M6i
CBMu  = COPY CBMi
CTMu  = COPY CTMi
RVu   = COPY RVi
CBu   = COPY CBi
CBDu  = COPY CBDi
CB2u  = COPY CB2i 
APu   = COPY APi
Cu_PPIu = COPY Cu_PPIi
PM1u   = COPY PM1i
PM2u   = COPY PM2i
UBMnu  = COPY UBMn
UBMdu  = COPY UBMd

CONNECT NSTPu NWu
CONNECT NSTPu PSDu	// For butted pickup
CONNECT PSTPu RWu	// For DNW connection
CONNECT PSTPu PWELu	// For DNW connection
CONNECT PSTPu NSDu	// For butted pickup
CONNECT COu PSDu        // For butted CO
CONNECT COu NSDu        // For butted CO
CONNECT COu POu         // For butted CO
CONNECT M1u POu NSTPu PSTPu PSDu NSDu BY COu
CONNECT M1u NWRuT BY COu
CONNECT M2u M1u BY VIA1u

CONNECT M3u M2u BY VIA2u

CONNECT M4u M3u BY VIA3u

CONNECT M5u CTMu CBMu M4u BY VIA4u

CONNECT M6u M5u BY VIA5u

CONNECT CBu M6u           // for wire-bond without AP-RDL. AP/CB2 are not drawn.
CONNECT M6u APu  BY RVu
CONNECT M6u APu  BY CBu
CONNECT M6u APu  BY CBDu
CONNECT CB2u APu
CONNECT CB2u PM1u
CONNECT PM1u Cu_PPIu
CONNECT UBMnu APu
CONNECT UBMnu M6u BY CBDu
CONNECT UBMdu Cu_PPIu BY PM2u  


VDD_CBi = NET AREA RATIO CBi NSTPi > 0
VSS_CBi = NET AREA RATIO CBi PSTPi > 0
VDD_CB2i = NET AREA RATIO CB2i NSTPi > 0
VSS_CB2i = NET AREA RATIO CB2i PSTPi > 0
VDD_UBMni = NET AREA RATIO UBMn NSTPi > 0
VSS_UBMni = NET AREA RATIO UBMn PSTPi > 0
VDD_UBMdi = NET AREA RATIO UBMd NSTPi > 0
VSS_UBMdi = NET AREA RATIO UBMd PSTPi > 0

IO_CBi  = (CBi NOT VDD_CBi) NOT VSS_CBi 
IO_CB2i = (CB2i NOT VDD_CB2i) NOT VSS_CB2i
IO_UBMni = (UBMn NOT VDD_UBMni) NOT VSS_UBMni
IO_UBMdi = (UBMd NOT VDD_UBMdi) NOT VSS_UBMdi



#IFDEF FULL_CHIP
#DEFINE CHECK_LOW_DENSITY
#ENDIF


#IFDEF LP 
#IFDEF LPG
LPG.OPTION.ERR { @ If LPG option is enabled, LP option should be disabled. 
  COPY CHIPx    
}
#ENDIF
#ENDIF


#IFDEF HALF_NODE
#IFDEF LPG
LPG.N55.WARN {@ LPG is not the standard offer in N55 process
  COPY CHIPx
}
#ENDIF
MIM.N55.ERR{@ MIM is not offered in N55 process
  COPY CTM
  COPY CBM    
}
Inductor.N55.ERR{@ Inductor is not offered in N55 process
  COPY INDDMY
}
#ENDIF

M7.WARN { @ This 6M drc command file does not check additional M7 layer. Please use 7M drc command file. 
  COPY M7 
}


#IFNDEF DFM_ONLY


G.1.UBMi { @ grid must be an integer multiple of ^Grid um
          @ waive polygon with vertex number >= 100
  A = UBMi NOT INTERACT (VERTEX UBMi >= 100)
  OFFGRID A 5
}
G.1.CBDi { @ grid must be an integer multiple of ^Grid um
          @ waive polygon with vertex number >= 100
  A = CBDi NOT INTERACT (VERTEX CBDi >= 100)
  OFFGRID A 5
}
G.1.CB2i { @ grid must be an integer multiple of ^Grid um
          @ waive polygon with vertex number >= 100
  A = CB2i NOT INTERACT (VERTEX CB2i >= 100)
  OFFGRID A 5
}
G.1.PMi { @ grid must be an integer multiple of ^Grid um
          @ waive polygon with vertex number >= 100
  A = PMi NOT INTERACT (VERTEX PMi >= 100)
  OFFGRID A 5
}
G.1.PM2i { @ grid must be an integer multiple of ^Grid um
          @ waive polygon with vertex number >= 100
  A = PM2i NOT INTERACT (VERTEX PM2i >= 100)
  OFFGRID A 5
}
G.1.Cu_PPIi { @ grid must be an integer multiple of ^Grid um
          @ waive polygon with vertex number >= 100
  A = Cu_PPIi NOT INTERACT (VERTEX Cu_PPIi >= 100)
  OFFGRID A 5
}
G.1.DNWi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DNWi 5
}
G.1.NWi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NWi 5
}
G.1.OD_18i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD_18i 5
}
G.1.OD_25i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD_25i 5
}
G.1.OD25_33 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD25_33 5
}
G.1.OD25_18 { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD25_18 5
}
G.1.OD_33i { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD_33i 5
}
G.1.OD_DECAP { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD_DECAP 5
}
G.1.PPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID PPi 5
}
G.1.NPi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NPi 5
}
G.1.CBi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBi 5
}
G.1.RPOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID RPOi 5
}
G.1.NT_Ni { @ grid must be an integer multiple of ^Grid um
  OFFGRID NT_Ni 5
}
G.1.NCap_NTNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID NCap_NTNi 5
}
G.1.FWALi { @ grid must be an integer multiple of ^Grid um
  OFFGRID FWALi 5
}
G.1.FWCUi { @ grid must be an integer multiple of ^Grid um
  OFFGRID FWCUi 5
}
G.1.POFUSE { @ grid must be an integer multiple of ^Grid um
  OFFGRID POFUSE 5
}
G.1.FUSELINK { @ grid must be an integer multiple of ^Grid um
  OFFGRID FUSELINK 5
}
G.1.PM1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID PM1i 5
}
G.1.SEALRINGi { @ grid must be an integer multiple of ^Grid um
  OFFGRID SEALRINGi 5
}
G.1.VTH_Ni { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTH_Ni 5
}
G.1.VTH_Pi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTH_Pi 5
}
G.1.VTL_Ni { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTL_Ni 5
}
G.1.VTL_Pi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VTL_Pi 5
}
G.1.UHVT_Ni { @ grid must be an integer multiple of ^Grid um
  OFFGRID UHVT_Ni 5
}
G.1.UHVT_Pi { @ grid must be an integer multiple of ^Grid um
  OFFGRID UHVT_Pi 5
}
G.1.RH { @ grid must be an integer multiple of ^Grid um
  OFFGRID RH 5
}
G.1.ESD3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID ESD3 5
}
G.1.VARi { @ grid must be an integer multiple of ^Grid um
  OFFGRID VARi 5
}
G.1.APi { @ grid must be an integer multiple of ^Grid um
  OFFGRID APi 5
}
G.1.CBMi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CBMi 5
}
G.1.CTMi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMi 5
}
G.1.RVi { @ grid must be an integer multiple of ^Grid um
  OFFGRID RVi 5
}
G.1.DCOi { @ grid must be an integer multiple of ^Grid um
  OFFGRID DCOi 5
}
G.1.HVD_N { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_N 5
}
G.1.HVD_P { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_P 5
}
G.1.HVD_N_nw { @ grid must be an integer multiple of ^Grid um
  OFFGRID HVD_N_nw 5
}
G.1.BJTDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID BJTDMY 5
}
G.1.NWDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID NWDMY 5
}
G.1.RPDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RPDMY 5
}
G.1.PMDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID PMDMY 5
}
G.1.SDI { @ grid must be an integer multiple of ^Grid um
  OFFGRID SDI 5
}
G.1.ESD1DMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID ESD1DMY 5
}
G.1.ESD2DMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID ESD2DMY 5
}
G.1.SRM { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRM 5
}
G.1.CDUDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID CDUDMY 5
}
G.1.TCDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID TCDDMY 5
}
G.1.LOGO { @ grid must be an integer multiple of ^Grid um
  OFFGRID LOGO 5
}
G.1.INDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID INDDMY 5
}
G.1.CTMDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMDMY 5
}
G.1.CTMDMY_10 { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMDMY_10 5
}
G.1.CTMDMY_15 { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMDMY_15 5
}
G.1.CTMDMY_20 { @ grid must be an integer multiple of ^Grid um
  OFFGRID CTMDMY_20 5
}
G.1.MOMDMY_1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_1 5
}
G.1.MOMDMY_2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_2 5
}
G.1.MOMDMY_3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_3 5
}
G.1.MOMDMY_4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_4 5
}
G.1.MOMDMY_5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_5 5
}
G.1.MOMDMY_6 { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_6 5
}
G.1.MOMDMY_AP { @ grid must be an integer multiple of ^Grid um
  OFFGRID MOMDMY_AP 5
}
G.1.RTMOMDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RTMOMDMY 5
}
G.1.RFDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID RFDMY 5
}
G.1.WBDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID WBDMY 5
}
G.1.DIODMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID DIODMY 5
}
G.1.SRAMDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY 5
}
G.1.SRAMDMY_4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_4 5
}
G.1.SRAMDMY_5 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_5 5
}
G.1.SRAMDMY_1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID SRAMDMY_1 5
}
G.1.OD1Ti { @ grid must be an integer multiple of ^Grid um
  OFFGRID OD1Ti 5
}
G.1.CLDDi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CLDDi 5
}
G.1.CROWNi { @ grid must be an integer multiple of ^Grid um
  OFFGRID CROWNi 5
}
G.1.P3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID P3i 5
}
G.1.SNCTi { @ grid must be an integer multiple of ^Grid um
  OFFGRID SNCTi 5
}
G.1.LUPWDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID LUPWDMY 5
}
G.1.VDDDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID VDDDMY 5
}
G.1.VSSDMY { @ grid must be an integer multiple of ^Grid um
  OFFGRID VSSDMY 5
}
G.1.M1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M1i 5
}
G.1.M1_real { @ grid must be an integer multiple of ^Grid um
  OFFGRID M1_real 5
}
G.1.DM1_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM1_O 5
}
G.1.DUM1 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM1 5
}
G.1.M2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M2i 5
}
G.1.M2_real { @ grid must be an integer multiple of ^Grid um
  OFFGRID M2_real 5
}
G.1.DM2_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM2_O 5
}
G.1.DUM2 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM2 5
}
G.1.M3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M3i 5
}
G.1.M3_real { @ grid must be an integer multiple of ^Grid um
  OFFGRID M3_real 5
}
G.1.DM3_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM3_O 5
}
G.1.DUM3 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM3 5
}
G.1.M4i { @ grid must be an integer multiple of ^Grid um
  OFFGRID M4i 5
}
G.1.M4_real { @ grid must be an integer multiple of ^Grid um
  OFFGRID M4_real 5
}
G.1.DM4_O { @ grid must be an integer multiple of ^Grid um
  OFFGRID DM4_O 5
}
G.1.DUM4 { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM4 5
}
G.1.M5_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID M5_OLD 5
}
G.1.M5_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID M5_NEW 5
}
G.1.DUM5_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM5_OLD 5
}
G.1.DUM5_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM5_NEW 5
}
G.1.M6_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID M6_OLD 5
}
G.1.M6_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID M6_NEW 5
}
G.1.DUM6_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM6_OLD 5
}
G.1.DUM6_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM6_NEW 5
}
G.1.M7_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID M7_OLD 5
}
G.1.M7_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID M7_NEW 5
}
G.1.DUM7_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM7_OLD 5
}
G.1.DUM7_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID DUM7_NEW 5
}
G.1.VIA1i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA1i 5
}
G.1.VIA2i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA2i 5
}
G.1.VIA3i { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA3i 5
}
G.1.VIA4_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA4_OLD 5
}
G.1.VIA4_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA4_NEW 5
}
G.1.VIA5_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA5_OLD 5
}
G.1.VIA5_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA5_NEW 5
}
G.1.VIA6_OLD { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA6_OLD 5
}
G.1.VIA6_NEW { @ grid must be an integer multiple of ^Grid um
  OFFGRID VIA6_NEW 5
}
G.1.ODi { @ grid must be an integer multiple of ^Grid um
  OFFGRID ODi 5
}
G.1.DOD { @ grid must be an integer multiple of ^Grid um
  OFFGRID DOD 5
}
G.1.DPO { @ grid must be an integer multiple of ^Grid um
  OFFGRID DPO 5
}
G.1.mVTLi { @ grid must be an integer multiple of ^Grid um
  OFFGRID mVTLi 5
}
G.1.CO { @ 5nm grid is required for CO except CO inside layer 186;5
  X = COi NOT SRAMDMY_5
  OFFGRID X 5	
}
G.1.PO { @ 5nm grid is required for PO except PO inside layer 186;5
  X = POi NOT SRAMDMY_5
  OFFGRID X 5	
}


G.2.DNWi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD_18i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD_18i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_18i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD_25i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD_25i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_25i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD25_33 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD25_33 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD25_33 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD25_18 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD25_18 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD25_18 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD_33i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD_33i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_33i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD_DECAP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NPi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.COi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT COi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CO_PUSH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CO_PUSH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CO_PUSH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CB2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NT_Ni { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NCap_NTNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NCap_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NCap_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.FWALi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT FWALi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FWALi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.FWCUi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT FWCUi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FWCUi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POFUSE { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POFUSE < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POFUSE < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.FUSELINK { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT FUSELINK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FUSELINK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PM1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PM1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PM1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PM2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PM2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PM2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SEALRINGi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SEALRINGi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRINGi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTH_Ni { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTH_Pi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTL_Ni { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VTL_Pi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.UHVT_Ni { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT UHVT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UHVT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.UHVT_Pi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT UHVT_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UHVT_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBDi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.UBMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RH { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ESD3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VARi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.APi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT APi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.Cu_PPIi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT Cu_PPIi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT Cu_PPIi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CBMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RVi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DCOi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DCOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DCOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVD_N { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_N < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVD_P { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_P < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_P < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.HVD_N_nw { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT HVD_N_nw < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT HVD_N_nw < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.BJTDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.NWDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RPDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.PMDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SDI { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD1DMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ESD2DMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRM { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CDUDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.TCDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT TCDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT TCDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LOGO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.INDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMDMY_10 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMDMY_10 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY_10 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMDMY_15 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMDMY_15 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY_15 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CTMDMY_20 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CTMDMY_20 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY_20 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_6 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.MOMDMY_AP { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_AP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_AP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RTMOMDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RTMOMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RTMOMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RFDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.WBDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DIODMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY_4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY_5 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SRAMDMY_1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.RAM1TDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT RAM1TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RAM1TDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.OD1Ti { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT OD1Ti < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD1Ti < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CLDDi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CLDDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CLDDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.CROWNi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT CROWNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CROWNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.P3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT P3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT P3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.SNCTi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT SNCTi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SNCTi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.LUPWDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VDDDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VDDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VDDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VSSDMY { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VSSDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VSSDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M1_real { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M1_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM1_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM1 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M2_real { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M2_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM2_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM2 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M3_real { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M3_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM3_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM3 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M4i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M4_real { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M4_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DM4_O { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM4 { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M5_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M5_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM5_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM5_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M6_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M6_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM6_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM6_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M7_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M7_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.M7_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT M7_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM7_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM7_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DUM7_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DUM7_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA1i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA2i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA3i { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA4_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA4_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA4_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA4_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA4_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA4_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA5_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA5_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA5_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA5_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA6_OLD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA6_OLD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.VIA6_NEW { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT VIA6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA6_NEW < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.ODi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DOD { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.POi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT POi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.DPO { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2.mVTLi { @ LAYERS Shapes with acute angles between line segments are not allowed.
  INT mVTLi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT mVTLi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.3.DNWi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DNWi >0 <45
  ANGLE DNWi >45 <90
}
G.3.NWi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NWi >0 <45
  ANGLE NWi >45 <90
}
G.3.OD_18i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD_18i >0 <45
  ANGLE OD_18i >45 <90
}
G.3.OD_25i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD_25i >0 <45
  ANGLE OD_25i >45 <90
}
G.3.OD25_33 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD25_33 >0 <45
  ANGLE OD25_33 >45 <90
}
G.3.OD25_18 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD25_18 >0 <45
  ANGLE OD25_18 >45 <90
}
G.3.OD_33i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD_33i >0 <45
  ANGLE OD_33i >45 <90
}
G.3.OD_DECAP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD_DECAP >0 <45
  ANGLE OD_DECAP >45 <90
}
G.3.PPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE PPi >0 <45
  ANGLE PPi >45 <90
}
G.3.NPi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NPi >0 <45
  ANGLE NPi >45 <90
}
G.3.COi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE COi >0 <45
  ANGLE COi >45 <90
}
G.3.CO_PUSH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CO_PUSH >0 <45
  ANGLE CO_PUSH >45 <90
}
G.3.CBi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBi >0 <45
  ANGLE CBi >45 <90
}
G.3.RPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RPOi >0 <45
  ANGLE RPOi >45 <90
}
G.3.NT_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NT_Ni >0 <45
  ANGLE NT_Ni >45 <90
}
G.3.NCap_NTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NCap_NTNi >0 <45
  ANGLE NCap_NTNi >45 <90
}
G.3.FWALi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE FWALi >0 <45
  ANGLE FWALi >45 <90
}
G.3.FWCUi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE FWCUi >0 <45
  ANGLE FWCUi >45 <90
}
G.3.POFUSE { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POFUSE >0 <45
  ANGLE POFUSE >45 <90
}
G.3.FUSELINK { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE FUSELINK >0 <45
  ANGLE FUSELINK >45 <90
}
G.3.SEALRINGi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SEALRINGi >0 <45
  ANGLE SEALRINGi >45 <90
}
G.3.VTH_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTH_Ni >0 <45
  ANGLE VTH_Ni >45 <90
}
G.3.VTH_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTH_Pi >0 <45
  ANGLE VTH_Pi >45 <90
}
G.3.VTL_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTL_Ni >0 <45
  ANGLE VTL_Ni >45 <90
}
G.3.VTL_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VTL_Pi >0 <45
  ANGLE VTL_Pi >45 <90
}
G.3.UHVT_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE UHVT_Ni >0 <45
  ANGLE UHVT_Ni >45 <90
}
G.3.UHVT_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE UHVT_Pi >0 <45
  ANGLE UHVT_Pi >45 <90
}
G.3.RH { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RH >0 <45
  ANGLE RH >45 <90
}
G.3.ESD3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ESD3 >0 <45
  ANGLE ESD3 >45 <90
}
G.3.VARi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VARi >0 <45
  ANGLE VARi >45 <90
}
G.3.APi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE APi >0 <45
  ANGLE APi >45 <90
}
G.3.CBMi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CBMi >0 <45
  ANGLE CBMi >45 <90
}
G.3.CTMi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMi >0 <45
  ANGLE CTMi >45 <90
}
G.3.RVi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RVi >0 <45
  ANGLE RVi >45 <90
}
G.3.DCOi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DCOi >0 <45
  ANGLE DCOi >45 <90
}
G.3.HVD_N { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_N >0 <45
  ANGLE HVD_N >45 <90
}
G.3.HVD_P { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_P >0 <45
  ANGLE HVD_P >45 <90
}
G.3.HVD_N_nw { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE HVD_N_nw >0 <45
  ANGLE HVD_N_nw >45 <90
}
G.3.BJTDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE BJTDMY >0 <45
  ANGLE BJTDMY >45 <90
}
G.3.NWDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE NWDMY >0 <45
  ANGLE NWDMY >45 <90
}
G.3.RPDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RPDMY >0 <45
  ANGLE RPDMY >45 <90
}
G.3.SDI { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SDI >0 <45
  ANGLE SDI >45 <90
}
G.3.ESD1DMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ESD1DMY >0 <45
  ANGLE ESD1DMY >45 <90
}
G.3.ESD2DMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ESD2DMY >0 <45
  ANGLE ESD2DMY >45 <90
}
G.3.SRM { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRM >0 <45
  ANGLE SRM >45 <90
}
G.3.CDUDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CDUDMY >0 <45
  ANGLE CDUDMY >45 <90
}
G.3.TCDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE TCDDMY >0 <45
  ANGLE TCDDMY >45 <90
}
G.3.LOGO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LOGO >0 <45
  ANGLE LOGO >45 <90
}
G.3.INDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE INDDMY >0 <45
  ANGLE INDDMY >45 <90
}
G.3.CTMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMDMY >0 <45
  ANGLE CTMDMY >45 <90
}
G.3.CTMDMY_10 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMDMY_10 >0 <45
  ANGLE CTMDMY_10 >45 <90
}
G.3.CTMDMY_15 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMDMY_15 >0 <45
  ANGLE CTMDMY_15 >45 <90
}
G.3.CTMDMY_20 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CTMDMY_20 >0 <45
  ANGLE CTMDMY_20 >45 <90
}
G.3.MOMDMY_1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_1 >0 <45
  ANGLE MOMDMY_1 >45 <90
}
G.3.MOMDMY_2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_2 >0 <45
  ANGLE MOMDMY_2 >45 <90
}
G.3.MOMDMY_3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_3 >0 <45
  ANGLE MOMDMY_3 >45 <90
}
G.3.MOMDMY_4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_4 >0 <45
  ANGLE MOMDMY_4 >45 <90
}
G.3.MOMDMY_5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_5 >0 <45
  ANGLE MOMDMY_5 >45 <90
}
G.3.MOMDMY_6 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_6 >0 <45
  ANGLE MOMDMY_6 >45 <90
}
G.3.MOMDMY_AP { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE MOMDMY_AP >0 <45
  ANGLE MOMDMY_AP >45 <90
}
G.3.RTMOMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RTMOMDMY >0 <45
  ANGLE RTMOMDMY >45 <90
}
G.3.RFDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RFDMY >0 <45
  ANGLE RFDMY >45 <90
}
G.3.WBDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE WBDMY >0 <45
  ANGLE WBDMY >45 <90
}
G.3.DIODMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DIODMY >0 <45
  ANGLE DIODMY >45 <90
}
G.3.SRAMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY >0 <45
  ANGLE SRAMDMY >45 <90
}
G.3.SRAMDMY_4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_4 >0 <45
  ANGLE SRAMDMY_4 >45 <90
}
G.3.SRAMDMY_5 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_5 >0 <45
  ANGLE SRAMDMY_5 >45 <90
}
G.3.SRAMDMY_1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SRAMDMY_1 >0 <45
  ANGLE SRAMDMY_1 >45 <90
}
G.3.RAM1TDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE RAM1TDMY >0 <45
  ANGLE RAM1TDMY >45 <90
}
G.3.OD1Ti { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE OD1Ti >0 <45
  ANGLE OD1Ti >45 <90
}
G.3.CLDDi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CLDDi >0 <45
  ANGLE CLDDi >45 <90
}
G.3.CROWNi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE CROWNi >0 <45
  ANGLE CROWNi >45 <90
}
G.3.P3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE P3i >0 <45
  ANGLE P3i >45 <90
}
G.3.SNCTi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE SNCTi >0 <45
  ANGLE SNCTi >45 <90
}
G.3.LUPWDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE LUPWDMY >0 <45
  ANGLE LUPWDMY >45 <90
}
G.3.VDDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VDDDMY >0 <45
  ANGLE VDDDMY >45 <90
}
G.3.VSSDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VSSDMY >0 <45
  ANGLE VSSDMY >45 <90
}
G.3.M1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M1i >0 <45
  ANGLE M1i >45 <90
}
G.3.M1_real { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M1_real >0 <45
  ANGLE M1_real >45 <90
}
G.3.DM1_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM1_O >0 <45
  ANGLE DM1_O >45 <90
}
G.3.DUM1 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM1 >0 <45
  ANGLE DUM1 >45 <90
}
G.3.M2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M2i >0 <45
  ANGLE M2i >45 <90
}
G.3.M2_real { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M2_real >0 <45
  ANGLE M2_real >45 <90
}
G.3.DM2_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM2_O >0 <45
  ANGLE DM2_O >45 <90
}
G.3.DUM2 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM2 >0 <45
  ANGLE DUM2 >45 <90
}
G.3.M3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M3i >0 <45
  ANGLE M3i >45 <90
}
G.3.M3_real { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M3_real >0 <45
  ANGLE M3_real >45 <90
}
G.3.DM3_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM3_O >0 <45
  ANGLE DM3_O >45 <90
}
G.3.DUM3 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM3 >0 <45
  ANGLE DUM3 >45 <90
}
G.3.M4i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M4i >0 <45
  ANGLE M4i >45 <90
}
G.3.M4_real { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M4_real >0 <45
  ANGLE M4_real >45 <90
}
G.3.DM4_O { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DM4_O >0 <45
  ANGLE DM4_O >45 <90
}
G.3.DUM4 { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM4 >0 <45
  ANGLE DUM4 >45 <90
}
G.3.M5_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M5_OLD >0 <45
  ANGLE M5_OLD >45 <90
}
G.3.M5_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M5_NEW >0 <45
  ANGLE M5_NEW >45 <90
}
G.3.DUM5_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM5_OLD >0 <45
  ANGLE DUM5_OLD >45 <90
}
G.3.DUM5_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM5_NEW >0 <45
  ANGLE DUM5_NEW >45 <90
}
G.3.M6_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M6_OLD >0 <45
  ANGLE M6_OLD >45 <90
}
G.3.M6_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M6_NEW >0 <45
  ANGLE M6_NEW >45 <90
}
G.3.DUM6_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM6_OLD >0 <45
  ANGLE DUM6_OLD >45 <90
}
G.3.DUM6_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM6_NEW >0 <45
  ANGLE DUM6_NEW >45 <90
}
G.3.M7_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M7_OLD >0 <45
  ANGLE M7_OLD >45 <90
}
G.3.M7_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE M7_NEW >0 <45
  ANGLE M7_NEW >45 <90
}
G.3.DUM7_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM7_OLD >0 <45
  ANGLE DUM7_OLD >45 <90
}
G.3.DUM7_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DUM7_NEW >0 <45
  ANGLE DUM7_NEW >45 <90
}
G.3.VIA1i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA1i >0 <45
  ANGLE VIA1i >45 <90
}
G.3.VIA2i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA2i >0 <45
  ANGLE VIA2i >45 <90
}
G.3.VIA3i { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA3i >0 <45
  ANGLE VIA3i >45 <90
}
G.3.VIA4_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA4_OLD >0 <45
  ANGLE VIA4_OLD >45 <90
}
G.3.VIA4_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA4_NEW >0 <45
  ANGLE VIA4_NEW >45 <90
}
G.3.VIA5_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA5_OLD >0 <45
  ANGLE VIA5_OLD >45 <90
}
G.3.VIA5_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA5_NEW >0 <45
  ANGLE VIA5_NEW >45 <90
}
G.3.VIA6_OLD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA6_OLD >0 <45
  ANGLE VIA6_OLD >45 <90
}
G.3.VIA6_NEW { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE VIA6_NEW >0 <45
  ANGLE VIA6_NEW >45 <90
}
G.3.ODi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE ODi >0 <45
  ANGLE ODi >45 <90
}
G.3.DOD { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DOD >0 <45
  ANGLE DOD >45 <90
}
G.3.POi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE POi >0 <45
  ANGLE POi >45 <90
}
G.3.DPO { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE DPO >0 <45
  ANGLE DPO >45 <90
}
G.3.mVTLi { @ Shapes must be orthogonal or on a 45 degree angle.
  ANGLE mVTLi >0 <45
  ANGLE mVTLi >45 <90
}

G.4.ODi { @ Adjacent edges with length less than min. width is not allowed.
  ODia = ODi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH ODia < OD_W_1
  ODi_ShortExp = EXPAND EDGE X BY 0.01
  ODi_SmallJog = (VERTEX ODi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  ODi INSIDE EDGE ODi_SmallJog
}
G.4.POi { @ Adjacent edges with length less than min. width is not allowed.
  POia = POi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH POia < PO_W_1
  POi_ShortExp = EXPAND EDGE X BY 0.01
  POi_SmallJog = (VERTEX POi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  POi INSIDE EDGE POi_SmallJog
}
G.4.VTH_Ni { @ Adjacent edges with length less than min. width is not allowed.
  VTH_Nia = VTH_Ni NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTH_Nia < VTH_N_W_1
  VTH_Ni_ShortExp = EXPAND EDGE X BY 0.01
  VTH_Ni_SmallJog = (VERTEX VTH_Ni_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTH_Ni INSIDE EDGE VTH_Ni_SmallJog
}
G.4.VTH_Pi { @ Adjacent edges with length less than min. width is not allowed.
  VTH_Pia = VTH_Pi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTH_Pia < VTH_P_W_1
  VTH_Pi_ShortExp = EXPAND EDGE X BY 0.01
  VTH_Pi_SmallJog = (VERTEX VTH_Pi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTH_Pi INSIDE EDGE VTH_Pi_SmallJog
}
G.4.VTL_Ni { @ Adjacent edges with length less than min. width is not allowed.
  VTL_Nia = VTL_Ni NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTL_Nia < VTL_N_W_1
  VTL_Ni_ShortExp = EXPAND EDGE X BY 0.01
  VTL_Ni_SmallJog = (VERTEX VTL_Ni_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTL_Ni INSIDE EDGE VTL_Ni_SmallJog
}
G.4.VTL_Pi { @ Adjacent edges with length less than min. width is not allowed.
  VTL_Pia = VTL_Pi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH VTL_Pia < VTL_P_W_1
  VTL_Pi_ShortExp = EXPAND EDGE X BY 0.01
  VTL_Pi_SmallJog = (VERTEX VTL_Pi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  VTL_Pi INSIDE EDGE VTL_Pi_SmallJog
}
G.4.PPi { @ Adjacent edges with length less than min. width is not allowed.
  PPia = PPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH PPia < PP_W_1
  PPi_ShortExp = EXPAND EDGE X BY 0.01
  PPi_SmallJog = (VERTEX PPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  PPi INSIDE EDGE PPi_SmallJog
}
G.4.NPi { @ Adjacent edges with length less than min. width is not allowed.
  NPia = NPi NOT INSIDE SRAM_EXCLUDE
  X = LENGTH NPia < NP_W_1
  NPi_ShortExp = EXPAND EDGE X BY 0.01
  NPi_SmallJog = (VERTEX NPi_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  NPi INSIDE EDGE NPi_SmallJog
}
G.4.M1i { @ Adjacent edges with length less than min. width is not allowed.
  M1ia = M1i NOT INSIDE SRAM_EXCLUDE
  X = LENGTH M1ia < M1_W_1
  M1i_ShortExp = EXPAND EDGE X BY 0.01
  M1i_SmallJog = (VERTEX M1i_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
  M1i INSIDE EDGE M1i_SmallJog
}

G.4.M2i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M2i < M2_W_1
  M2i_ShortExp = EXPAND EDGE X BY 0.01
  M2i_SmallJog = VERTEX M2i_ShortExp > 4
  M2i INSIDE EDGE M2i_SmallJog
}
G.4.M3i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M3i < M3_W_1
  M3i_ShortExp = EXPAND EDGE X BY 0.01
  M3i_SmallJog = VERTEX M3i_ShortExp > 4
  M3i INSIDE EDGE M3i_SmallJog
}
G.4.M4i { @ Adjacent edges with length less than min. width is not allowed.
  X = LENGTH M4i < M4_W_1
  M4i_ShortExp = EXPAND EDGE X BY 0.01
  M4i_SmallJog = VERTEX M4i_ShortExp > 4
  M4i INSIDE EDGE M4i_SmallJog
}

//G.4.CO is checked by CO.W.1
//G.4.VIAx is checked by VIAx.W.1

G.5.NOTUSEM1 { @ Do not use NOTUSEM1 which is reserved for tsmc internal mask making
    COPY NOTUSEM1
}
G.5.NOTUSEM2 { @ Do not use NOTUSEM2 which is reserved for tsmc internal mask making
    COPY NOTUSEM2
}
G.5.NOTUSEM3 { @ Do not use NOTUSEM3 which is reserved for tsmc internal mask making
    COPY NOTUSEM3
}
G.5.NOTUSEM4 { @ Do not use NOTUSEM4 which is reserved for tsmc internal mask making
    COPY NOTUSEM4
}
G.5.NOTUSEM5 { @ Do not use NOTUSEM5 which is reserved for tsmc internal mask making
    COPY NOTUSEM5
}
G.5.NOTUSEM6 { @ Do not use NOTUSEM6 which is reserved for tsmc internal mask making
    COPY NOTUSEM6
}
G.5.NOTUSEM7 { @ Do not use NOTUSEM7 which is reserved for tsmc internal mask making
    COPY NOTUSEM7
}
G.5.NOTUSEOD { @ Do not use NOTUSEOD which is reserved for tsmc internal mask making
    COPY NOTUSEOD
}
G.5.NOTUSEPO { @ Do not use NOTUSEPO which is reserved for tsmc internal mask making
    COPY NOTUSEPO
}


USER_GUIDE.M1 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM1
}    
USER_GUIDE.M2 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM2
}    
USER_GUIDE.M3 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM3
}    
USER_GUIDE.M4 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM4
}    
USER_GUIDE.M5 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM5
}    
USER_GUIDE.M6 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM6
}    
USER_GUIDE.M7 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM7
}    
USER_GUIDE.VIA1 { @ Via layers with forbidden datatypes.
  COPY NOUSEV1
}    
USER_GUIDE.VIA2 { @ Via layers with forbidden datatypes.
  COPY NOUSEV2
}    
USER_GUIDE.VIA3 { @ Via layers with forbidden datatypes.
  COPY NOUSEV3
}    
USER_GUIDE.VIA4 { @ Via layers with forbidden datatypes.
  COPY NOUSEV4
}    
USER_GUIDE.VIA5 { @ Via layers with forbidden datatypes.
  COPY NOUSEV5
}    
USER_GUIDE.VIA6 { @ Via layers with forbidden datatypes.
  COPY NOUSEV6
}    
USER_GUIDE.2 { @ Dummy metal,poly,od can't be used to connect
  DUM1 INTERACT COi
  DUM1 INTERACT VIA1i
  DUM2 INTERACT VIA1i
  DUM2 INTERACT VIA2i
  DUM3 INTERACT VIA2i
  DUM3 INTERACT VIA3i
  DUM4 INTERACT VIA3i
  DUM4 INTERACT VIA4i
  DUM5 INTERACT VIA4i
  DUM5 INTERACT VIA5i
  DUM6 INTERACT VIA5i
  DPO INTERACT COi
  DOD INTERACT COi
}  


#IFDEF DATATYPE_WARNING

NW_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any layer other than (3;0) that default MT form considers to create NW mask. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to NW in the MT form to ensure complete fabrication. It is strongly recommended to use NW;drawing (3;0) layer to define NW regions. 
    COPY NWi_OTHERS
}

OD_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any other layer to create OD mask such as pdiff (7;0), ndiff (8;0) or any layer other than (6;0), and (6;1) that default MT form considers. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to OD in the MT form to ensure complete fabrication.  It is strongly recommended to use only OD;drawing (6;0) and OD;dummy (6;1) layers to defined OD and DOD regions.
  COPY ODi_OTHERS
}

OD_DATATYPE.WARNING2 { @ SRAM OD (6;11-13) layer are only allowed in SRAM region. 
   ODi_SRAM NOT (SRM OR SRAMDMY)  
}

OD_DATATYPE.WARNING3 { @ Layer (6;3) is for recognition purpose of RF devices, please take care if this layer is adopted for non-RF designs and not for masking purpose of diffusion regions together with OD (6;0). 
   ODi_RFDRAIN NOT RFDMY
   ODi_RFDRAIN AND POi
   ODi_RFDRAIN NOT ODi
}



PO_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any layer other than (17;0), and (17,1) that default MT form considers to create PO mask. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to PO in the MT form to ensure complete fabrication. It is strongly recommended to use PO;drawing (17;0) and PO;dummy (17;1) layer to define PO and DPO regions. 
    COPY POi_OTHERS
}

PO_DATATYPE.WARNING2 { @ SRAM PO (17;11-13) layer are only allowed in SRAM region. 
   POi_SRAM NOT (SRM OR SRAMDMY)  
}

CO_DATATYPE.WARNING1 { @ Extreme user care needs to be taken when using any layer other than (30;0) that default MT form considers to create CO mask. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to CO in the MT form to ensure complete fabrication. It is strongly recommended to use CO;drawing (30;0) to define CO regions. 
    COPY COi_OTHERS
}

CO_DATATYPE.WARNING2 { @ SRAM CO (30;11-13) layer are only allowed in SRAM region. 
   COi_SRAM NOT (SRM OR SRAMDMY)  
}

#ENDIF





#IFDEF FRONT_END


//NW CHECKS
//=========

NW2V = NWEL AND OD2
NW1V = NWEL NOT OD2

NW.W.1 { @ Width >= ^NW_W_1 um 
  A = (INT NWEL < NW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  A OUTSIDE SRAM_EXCLUDE
  B = A CUT SRAM_EXCLUDE
  C = (NWEL INTERACT B) NOT SRAM_EXCLUDE
  D = INT C < NW_W_1 ABUT < 90 SINGULAR REGION 
  B INTERACT D 
}

NW.S.1 { @ Space >= ^NW_S_1 um 
  (EXT NWEL < NW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

NW.S.2 { @ Space of two NW1V with different potentials >= ^NW_S_2 um 
  NW1V_NODAL = STAMP NW1V BY NWi
  (EXT NW1V_NODAL < NW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

NW.S.3 { @ NW1V space to NW2V with different potentials >= ^NW_S_3 um 
  (EXT NW1V NW2V < NW_S_3 ABUT < 90 > 0 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

NW.S.4 { @ Space of two NW2V with different potentials >= NW2V ^NW_S_4 um 
  NW2V_NODAL = STAMP NW2V BY NWi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

#IFDEF NW_SUGGESTED

SUGGESTED.NW.S.3_NW.S.4 { @ A more conservative way to check NW.S.3, NW.S.4 with 
		          @ varied operating voltages determination of nwels.
  NW1V = NWEL OUTSIDE OD2
  NW2V = NWEL NOT OUTSIDE OD2
  EXT NW1V NW2V < NW_S_3 ABUT < 90 > 0 SINGULAR REGION
  NW2V_NODAL = STAMP NW2V BY NWi
  EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
#ENDIF

NW.S.5 { @ Space to PW STRAP >= ^NW_S_5 um 
  EXT NWi PPOD < NW_S_5 ABUT < 90 SINGULAR REGION
  PPOD CUT NWi
}

NW.S.6 { @ Space to N+active except dummy TCD region >= ^NW_S_6 um 
  A = NPOD NOT INTERACT RNWEL
  (EXT NWi A < NW_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE TCDDMY
  (A CUT NWi) NOT INSIDE TCDDMY
}

NW.S.7 { @ Space to (N+active interact OD2) >= ^NW_S_7 um 
  EXT NWi NACT2 < NW_S_7 ABUT < 90 SINGULAR REGION
}

NW.EN.1 { @ Enclosure of NW STRAP >= ^NW_EN_1 um 
  ENC NPOD NONWR < NW_EN_1 ABUT < 90 SINGULAR REGION
}

NW.EN.2 { @ Enclosure of P+active >= ^NW_EN_2 um 
  ENC PPOD NONWR < NW_EN_2 ABUT < 90 SINGULAR REGION
}

NW.EN.3 { @ ENClosure of (P+active interact with OD2) >= ^NW_EN_3 um 
  ENC PACT2 NWi < NW_EN_3 ABUT < 90 SINGULAR REGION
}

NW.A.1 { @ Area >= ^NW_A_1 um2
  AREA NWEL < NW_A_1
}

VARIABLE NW_A_2pre ((NW_A_2 + (NW_S_1 * NW_S_1 * 3.142))/(2 * NW_S_1))*((NW_A_2 + (NW_S_1 * NW_S_1 * 3.142))/(2 * NW_S_1))/3.141

NW.A.2 { @ Enclosed Area >= ^NW_A_2 um2
  A = HOLES NWEL INNER < NW_A_2pre
  B = A NOT NWEL
  (AREA B < NW_A_2) NOT INSIDE SRAM_EXCLUDE
}

NW.A.3 { @ Area (one of edge length < ^NW_A_3_L um) >= ^NW_A_3 um2
  X = LENGTH NWEL < NW_A_3_L
  Y = NWEL WITH EDGE X   
  AREA Y < NW_A_3
}

VARIABLE NW_A_4pre ((NW_A_4 + (NW_S_1 * NW_S_1 * 3.142))/(2 * NW_S_1))*((NW_A_4 + (NW_S_1 * NW_S_1 * 3.142))/(2 * NW_S_1))/3.141

NW.A.4 { @ Enclosed Area (one of the enclosed edge length < ^NW_A_4_L um) >= ^NW_A_4 um2
  A = HOLES NWEL INNER < NW_A_4pre
  X = LENGTH A < NW_A_4_L
  Y = A WITH EDGE X 
  B = Y NOT NWi
  (AREA B < NW_A_4) NOT INSIDE SRAM_EXCLUDE
}




//NWROD CHECKS
//=============

NWROD.W.1 { @ Width >= ^NWROD_W_1 (NWRSTI.W.1 is checked by NWROD.W.1)
  INT RNWEL < NWROD_W_1 ABUT < 90 SINGULAR REGION
}

NWROD.S.1 { @ Space to NWROD or to NW >= ^NWROD_S_1
@ NWRSTI.S.1  Space to NWRSTI or to NW >= ^NWROD_S_1
    
  EXT RNWEL < NWROD_S_1 ABUT < 90 NOTCH SINGULAR REGION
  EXT RNWEL NWEL < NWROD_S_1 ABUT < 90 SINGULAR REGION 
}  

NWROD.S.2 { @ Space to RPO >= 0.3 
  EXT NWRES RPO < NWROD_S_2 ABUT < 90 SINGULAR REGION
  (NWRES AND RPO) NOT INTERACT NWDMY
  A = RPO INSIDE EDGE NWRES
  EXT A < RPO_W_1 ABUT == 90 REGION INTERSECTING ONLY
}

NWROD.EN.1 { @ Enclosure by OD >= 1.0 
  ENC NWRES ODWR < NWROD_EN_1 ABUT < 90 SINGULAR REGION
  NWRES CUT ODWR
}

NWROD.EN.2 { @ Enclosure of CO >= 0.3 
  X = RHWR AND NWRES	// Terminal
  ENC COWR X < NWROD_EN_2 ABUT < 90 SINGULAR REGION
  COWR NOT X
}

NWROD.O.1 { @ RPO overlap of NP. Use exact value (0.4 um) on sides touching NWDMY. = 0.4 
  INT NPWR RPO < NWROD_O_1 ABUT < 90 SINGULAR REGION
  A = RHWR INSIDE EDGE NWEL
  B = EXPAND EDGE A OUTSIDE BY NWROD_O_1
  ((NPWR AND RPO) AND NWRES) NOT B
  RHWR NOT NPWR
}

NWROD.O.2 { @ {OD AND NWDMY} overlap of {NP, PP, VTH_N, VTH_P, VTL_N, or VTL_P} (all implant layers except NW) is not allowed.   
  A = OD AND NWDMY
  A AND NP
  A AND PP
  A AND VTHN
  A AND VTHP
  A AND VTLN
  A AND VTLP
}

NWROD.R.4 { @ Only one polygon of NW in NWROD is allowed in one OD
  A = OD INTERACT (NWRES AND OD) > 1
  NWRES INTERACT A
}

NWROD.R.5 { @ Only two polygons of NP in NWROD is allowed in one OD
  A = OD INTERACT NWRES
  VALID = A INTERACT (NP INTERACT NWRES) == 2
  NP INTERACT (A NOT INTERACT VALID)
}

NWROD.R.6 { @ Only two polygons of RPO hole(Salicide) in NWROD is allowed in same OD
  A = OD INTERACT NWRES
  VALID = A INTERACT (HOLES RPO) == 2
  RPO INTERACT (A NOT INTERACT VALID)
}

NWROD.R.7 { @ OD space for NW with parallel length > 0 if NW space <= 5um
  ((EXT NWRES <= 5 NOTCH OPPOSITE REGION) NOT NWRES) INSIDE OD
}


//NWRSTI CHECKS
//=============

//NWRSTI.W.1 is checked by NWROD.W.1
//NWRSTI.S.1 is checked by NWROD.S.1

NWRSTI.EN.1 { @ NP enclosure of OD >= 0.4 
  ENC ODWR_STI NPWR_STI < NWRSTI_EN_1 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}

NWRSTI.EN.2 { @ OD extension on NWRSTI >= ^NWRSTI_EN_2 um
@ NWRSTI.EN.3 Enclosure of CO >= ^NWRSTI_EN_2 um
  X = ODWR_STI AND NWRES_STI	// Terminal
  ENC COWR_STI X < NWRSTI_EN_2 ABUT < 90 SINGULAR REGION
  COWR_STI NOT X
}
// NWRSTI.EN.3 is checked by NWRSTI.EN.2

NWRSTI.EX.1 { @ OD extension on NWRSTI >= 0.3 
  ENC NWRES_STI ODWR_STI < NWRSTI_EX_1 ABUT < 90 SINGULAR REGION
  A = ODWR_STI INSIDE EDGE NWRES_STI
  INT A < OD_W_1 ABUT == 90 REGION INTERSECTING ONLY
  ANGLE A == 45
  (NWRES_STI NOT NWDMY) NOT OD
}

NWRSTI.O.1 { @ {NP interact with NWDMY} overlap of {PP, VTH_P, or VTL_P} (all p-type implant layers) is not allowed   
  A = NP INTERACT NWDMY
  A AND PP
  A AND VTHP
  A AND VTLP
}  



//NT_N RULES CHECK
//================
 
NTN_OD      = NTN AND OD
NTN_PO      = NTN AND POLY
NTN_GATE_W  = NTN_PO INSIDE EDGE NTN_OD
NTN_2_3V_GATE_W = NTN_GATE_W INSIDE EDGE (OD_25 OR OD_33)
NTN_18V_GATE_W   = NTN_GATE_W INSIDE EDGE OD_18

NT_N.W.1 { @ Width >= ^NT_N_W_1 um 
  INT NTN < NT_N_W_1 ABUT < 90 SINGULAR REGION
}

#IFDEF LP
NTN_GATE_W_less_E  = LENGTH NTN_GATE_W <= NT_N_W_2_2_E 
NTN_GATE_W_less_EM = ENC [NTN_GATE_W_less_E] NTN_OD <= NT_N_W_2_2_M OPPOSITE   

NT_N.W.2.1 { @ Channel length of 1.2V native device [LP process] >= ^NT_N_W_2_1 um
  NTN_GATE_W_more_EM = NTN_GATE_W NOT COIN INSIDE EDGE NTN_GATE_W_less_EM 
  INT NTN_GATE_W_more_EM NTN_GATE_W < NT_N_W_2_1 ABUT < 90 REGION
}

NT_N.W.2.2 { @ Channel length of 1.2V native device [LP process with limited E<=1um & M<=0.5um]  >= ^NT_N_W_2_2 um
  INT NTN_GATE_W_less_EM < NT_N_W_2_2 ABUT < 90 REGION
}

#IFDEF HALF_NODE

NT_N.W.2.3 { @ Channel length of core native device [Only for N55 LP] >= ^NT_N_W_2_3 um
  NTN_CORE_GATE_W = NTN_GATE_W NOT INSIDE EDGE OD2
  INT NTN_CORE_GATE_W < NT_N_W_2_3 ABUT < 90 REGION
}

#ENDIF
#ELSE
#IFDEF LPG
NTN_G_GATE_W  = NTN_GATE_W INSIDE EDGE DCO
NTN_LP_GATE_W = NTN_GATE_W NOT INSIDE EDGE DCO

NT_N.W.2 { @ Channel length of 1.0V native device [G process]>= ^NT_N_W_2 um
  INT NTN_G_GATE_W < NT_N_W_2 ABUT < 90 REGION
}

NTN_GATE_W_less_E  = LENGTH NTN_LP_GATE_W <= NT_N_W_2_2_E 
NTN_GATE_W_less_EM = ENC [NTN_GATE_W_less_E] NTN_OD <= NT_N_W_2_2_M OPPOSITE

NT_N.W.2.1 { @ Channel length of 1.2V native device [LP process] >= ^NT_N_W_2_1 um
  NTN_GATE_W_more_EM = NTN_LP_GATE_W NOT COIN INSIDE EDGE NTN_GATE_W_less_EM 
  INT NTN_GATE_W_more_EM NTN_LP_GATE_W < NT_N_W_2_1 ABUT < 90 REGION
}

NT_N.W.2.2 { @ Channel length of 1.2V native device [LP process with limited E<=1um & M<=0.5um] >= ^NT_N_W_2_2 um
  INT NTN_GATE_W_less_EM < NT_N_W_2_2 ABUT < 90 REGION
}

#ELSE

NT_N.W.2 { @ Channel length of 1.0V native device >= ^NT_N_W_2 um
  INT NTN_GATE_W < NT_N_W_2 ABUT < 90 REGION
}
#ENDIF
#ENDIF

NT_N.W.3 { @Channel length of 2.5V/3.3V native device >= ^NT_N_W_3 um
  INT NTN_2_3V_GATE_W < NT_N_W_3 ABUT < 90 REGION
}

NT_N.W.4 { @ Channel length of 1.8V native device >= ^NT_N_W_4 um
  INT NTN_18V_GATE_W < NT_N_W_4 ABUT < 90 REGION
}

NT_N.W.5 { @ Channel width >= ^NT_N_W_5 um
   LENGTH NTN_GATE_W < NT_N_W_5
}  

NT_N.S.1 { @ Space >= ^NT_N_S_1 um 
  EXT NTN < NT_N_S_1 ABUT < 90 SINGULAR REGION
}

NTN_exc_ind = NTN NOT INDDMY

NT_N.S.2 { @ Space to [Active outside NT_N] >= ^NT_N_S_2 um
  A = DACT NOT NTN
  EXT NTN_exc_ind A < NT_N_S_2 ABUT < 90 SINGULAR REGION
}

NT_N.S.3 { @ Space to NW >= ^NT_N_S_3 um
  EXT NTN NWi < NT_N_S_3 ABUT < 90 SINGULAR REGION
}

NT_N.EN.1 { @ Enclosure range of N+OD >= ^NT_N_EN_1_L um <= ^NT_N_EN_1_H um
  A = NTN_exc_ind INTERACT NPOD
  B = NPOD INTERACT NTN_exc_ind
  ENC B A < NT_N_EN_1_L ABUT < 90 SINGULAR REGION
  B CUT A
  A NOT (SIZE B BY NT_N_EN_1_H)
}

NT_N.EX.1 { @ PO extension on (OD inside NT_N) (PO endcap) >= ^NT_N_EX_1 um 
  ENC NTN_OD POLY < NT_N_EX_1 ABUT < 90 SINGULAR REGION
}
NT_N.A.1 { @ Area >= ^NT_N_A_1 um2
  (AREA NTNs < NT_N_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE NT_N_A_2pre ((NT_N_A_2 + (NT_N_S_1 * NT_N_S_1 * 3.142))/(2 * NT_N_S_1))*((NT_N_A_2 + (NT_N_S_1 * NT_N_S_1 * 3.142))/(2 * NT_N_S_1))/3.141
NT_N.A.2 { @ Enclosed area >= ^NT_N_A_2 um2
  A = HOLES NTN INNER < NT_N_A_2pre
  B = A NOT NTN
  AREA B < NT_N_A_2
}

NT_N.A.3 { @ Area [one of edge length < ^NT_N_A_3_L um] >= ^NT_N_A_3 um2
  X = LENGTH NTNs < NT_N_A_3_L
  Y = NTNs WITH EDGE X   
  AREA Y < NT_N_A_3
}

VARIABLE NT_N_A_4pre ((NT_N_A_4 + (NT_N_S_1 * NT_N_S_1 * 3.142))/(2 * NT_N_S_1))*((NT_N_A_4 + (NT_N_S_1 * NT_N_S_1 * 3.142))/(2 * NT_N_S_1))/3.141

NT_N.A.4 { @ Enclosed Area [one of the enclosed edge length < ^NT_N_A_4_L um] >= ^NT_N_A_4 um2
  A = HOLES NTNs INNER < NW_A_4pre
  X = LENGTH A < NT_N_A_4_L
  Y = A WITH EDGE X 
  B = Y NOT NT_Ni
  (AREA B < NT_N_A_4) NOT INSIDE SRAM_EXCLUDE
}

NT_N.R.1 { @ Overlap of (NW or DNW) is not allowed 
  NTN AND DNW
  NTN AND NWEL
}

NT_N.R.2 { @ P+Gate is not allowed in NT_N
   NTN AND GATE_PP
}

NT_N.R.3 { @ Only one OD is allowed in NT_N 
  A = NTN_exc_ind CUT OD > 1
  A NOT INTERACT NCap_NTN
  B = A INTERACT NCap_NTN
  C = OD INTERACT B
  NCap_NTN NOT OD // OD of NMOS cap sould be exactly covered by NCap_NTN
  C NOT NCap_NTN  // Mixture of NMOS cap and normal device is not allowed
  NCap_NTN NOT NTN // NCap_NTN must be fully inside NTN 
  A INTERACT NSDc > 1 BY NET // all source and all drain of all Nmos caps in the same NT_N must be connected together. 
}


//DNW CHECKS
//==========

DNW.W.1 { @ Width >= 3.0 
  (INT DNW < DNW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

DNW.S.1 { @ Space >= 3.5 
  (EXT DNW < DNW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

DNW.S.2 { @ Space to NW >= 2.5 
  (EXT DNW NWEL < DNW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION MEASURE ALL) NOT INSIDE SRAM_EXCLUDE
}

DNW.S.3 { @ Space to {N+ACTIVE outside DNW} except dummy TCD region (TCDDMY) >= 1.65 
  A = NACT OUTSIDE DNW
  (EXT DNW A < DNW_S_3 ABUT < 90 SINGULAR REGION) NOT INSIDE TCDDMY
}

RW   = PWEL INSIDE DNW
PWELx = PWEL NOT INSIDE DNW
RW1V = RW OUTSIDE OD2
RW2V = RW NOT OUTSIDE OD2
RW1V_NODAL = STAMP RW1V BY RWi
RW2V_NODAL = STAMP RW2V BY RWi
PWEL_NODAL = STAMP PWELx BY PWELi

DNW.S.4 { @  RW space to {RW OR PW} with different potential >= ^DNW_S_4 um 
  (EXT RW1V_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW1V_NODAL PWEL_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

DNW.S.5 { @  {RW OR PW} space to {RW interact with OD2} with different potential >= ^DNW_S_5 um
  (EXT RW2V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL RW1V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL PWEL_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}


DNW.EN.3 { @ Enclosure of N+ACTIVE >= 0.56 
  (ENC NACT DNW < DNW_EN_3 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}


DNW.O.1 { @ Overlap of NW >= 0.4 
  (INT DNW NWEL < DNW_O_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

// DNW.R.2 is not necessary to check
// DNW.R.3 is not necessary to check
// DNW.R.4 can not be checked by DRC

DNW.R.5 { @ DNW cut N+ACTIVE is not allowed   
    NACT CUT DNW
}



//OD CHECKS
//=========

OD.W.1 { @ Width >= 0.08 
  INT OD < OD_W_1 ABUT < 90 SINGULAR REGION
}
OD.W.2 { @ Width of MOS (<= 1.2V) [for core device] >= 0.12 
  LENGTH GATE_W < OD_W_2
}
OD.W.3 { @ Width of MOS (> 1.2V to <= 3.3V) [for I/O device] >= 0.4 
  LENGTH HV_GATE_W < OD_W_3
}

OD_EDGE_45 = OD ANGLE == 45

OD.W.4 { @ Width of 45 degree bent OD Please make sure the vertex of 45 degree pattern is on 5nm grid (refer to the guideline, G.6gU, in section 3.7) >= 0.18 
  INT OD_EDGE_45 < OD_W_4 ABUT < 90 REGION
}
OD.S.1 { @ Space >= 0.11 
  EXT OD < OD_S_1 ABUT < 90 SINGULAR REGION
}

HV_OD_E = OD INSIDE EDGE OD2

OD.S.2 { @ Space (inside OD2) >= 0.18 
  EXT HV_OD_E < OD_S_2 ABUT < 90 REGION
}  


Wide_OD_0.15 = ( SIZE OD BY OD_S_3_W/2 UNDEROVER ) AND OD 

OD.S.3 { @ Space of two ODs (width (W) > 0.15 m), if the parallel length (L) >= 0.2 m >= 0.13 
  OD_SPACE_BOTH = EXT Wide_OD_0.15 < OD_S_3  OPPOSITE REGION
  ENCLOSE RECTANGLE OD_SPACE_BOTH OD_S_1 OD_S_3_L  
}

OD.S.3.1 { @ Space to OD (width (W) > 0.15 m), if the parallel length (L) >= 0.2 m >= 0.125 
  OD_SPACE_ONE = EXT Wide_OD_0.15 OD < OD_S_3_1  OPPOSITE REGION
  ENCLOSE RECTANGLE OD_SPACE_ONE OD_S_1 OD_S_3_L    
}  

OD.S.4 { @ Space to 45-degree bent OD >= 0.18 
  X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY OD_S_4
  X AND OD
}  

OD.S.5 { @ Space between two segments of a U-shape or an O-shape OD (notch only) >= 0.18 
  CONVEX EDGE OD ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < OD_S_5
}  

OD.A.1 { @ Area >= 0.054 
  (AREA ODs < OD_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE OD_A_2pre ((OD_A_2 + (OD_S_1 * OD_S_1 * 3.142))/(2 * OD_S_1))*((OD_A_2 + (OD_S_1 * OD_S_1 * 3.142))/(2 * OD_S_1))/3.141

OD.A.2 { @ Enclosed area >= 0.085 
  A = HOLES OD INNER < OD_A_2pre
  B = A NOT OD
  AREA B < OD_A_2
}

OD.L.1 { @ Maximum length of {ACTIVE (source) [width < 0.15 m] interacts with butted_STRAP} <= 0.5 
  BUTTED_EDGE = LENGTH NP_PP_BTE < OD_L_1_W
  CHECK_SD = SD WITH EDGE BUTTED_EDGE
  NARROW_SD = INT (CHECK_SD COIN INSIDE EDGE OD) < OD_L_1_W ABUT < 90 OPPOSITE REGION 
  CHECK_OD = (NARROW_SD WITH EDGE BUTTED_EDGE) OR (NARROW_SD WITH EDGE GATE_W)
  PATH LENGTH (OD COIN INSIDE EDGE CHECK_OD) > OD_L_1
} 

OD.L.2 { @ Maximum OD length [OD width is < 0.15 m] between two contacts as well as between one contact and the OD line end <= 25 
  LONGP = AREA INOD > OD_W_1 * OD_L_2	
  X = LONGP INTERACT COOD
  CHECK_COOD = COOD INTERACT X
  A = SIZE CHECK_COOD BY OD_L_2 / 2 INSIDE OF X STEP OD_S_1*0.7
  LINEN = X INTERACT A == 1
  P2P = X INTERACT A > 1
  B = A INTERACT LINEN
  C = SIZE B BY OD_L_2 / 2 INSIDE OF LINEN STEP OD_S_1*0.7
  BAD = (LINEN NOT C) OR (P2P NOT A)
  BAD_EDGE = BAD COIN INSIDE EDGE OD
  ERR = INT BAD_EDGE < OD_L_2_W ABUT < 90 REGION
  X INTERACT ERR
}  



OD.R.1 { @ OD must be fully covered by {NP OR PP} except for {DOD OR NWDMY}   
  ((OD NOT INTERACT NWRES) NOT LOGO) NOT IMP
}



//DUMMY OD RULE
//================

DOD.W.1 { @ Width >= 0.5 
  INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}
DOD.S.1 { @ Space >= 0.4 
  EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}
DOD.S.2 { @ Space to OD >= ^DOD_S_2 um (Overlap is not allowed)
  EXT ODi DOD < DOD_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DOD.S.3 { @ Space to PO >= ^DOD_S_3 um (Overlap is not allowed)
  EXT POi DOD < DOD_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DOD.S.5 { @ Space to NW >= ^DOD_S_5 um
  EXT NWi DOD < DOD_S_5 ABUT < 90 SINGULAR REGION 
}
DOD.S.6 { @ Space to FW (Overlap is not allowed) >= 1.2 
  EXT FWi DOD < DOD_S_6 ABUT < 90 SINGULAR REGION 
  FWi AND DOD
}
// for solid L-mark (old)
DOD.S.7 { @ Space to LMARK (Overlap is not allowed) >= ^DOD_S_7 um
  EXT LMARK_SOLID DOD < DOD_S_7 ABUT < 90 SINGULAR REGION 
  LMARK_SOLID AND DOD
}
// for hollow L-mark (new)
DOD.S.7.1 { @ Space to L-slot (Overlap is not allowed) >= ^DOD_S_7_1 um
  EXT LSLOT DOD < DOD_S_7_1 ABUT < 90 SINGULAR REGION 
  LSLOT AND DOD
}

DOD.S.8 { @ Space to NWDMY (Overlap is not allowed) >= 0.6 
  EXT NWDMY DOD < DOD_S_8 ABUT < 90 SINGULAR REGION 
  NWDMY AND DOD
}
DOD.S.9 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DOD
}
DOD.S.10 { @ Space to INDDMY (Overlap is not allowed) >= 1.2 
  EXT INDDMY DOD < DOD_S_10 ABUT < 90 SINGULAR REGION 
  INDDMY AND DOD
}
DOD.EN.1 { @ Enclosure by NW >= ^DOD_EN_1 um
  ENC DOD NWi < DOD_EN_1 ABUT < 90 SINGULAR REGION
  DOD CUT NWi
}

#IFDEF FULL_CHIP
DOD.EN.2 { @ Enclosure by chip edge >= 0.6 
  DOD NOT (SIZE CHIP_CHAMFERED BY -DOD_EN_2)
}
OD.DN.1L { @ {OD OR DOD} density across full chip >= 25%
  DENSITY ALL_OD CHIP < OD_DN_1L INSIDE OF LAYER CHIPx PRINT OD.DN.1L.density
  [ AREA(ALL_OD)/AREA(CHIP) ]
  
}
OD.DN.1H { @ {OD OR DOD} density across full chip <= 75%
  DENSITY ALL_OD CHIP > OD_DN_1H INSIDE OF LAYER CHIPx PRINT OD.DN.1H.density
  [ AREA(ALL_OD)/AREA(CHIP) ]
}  
#ENDIF

OD_EXC = NWDMY OR DEN_EXC
ODx = ALL_OD NOT OD_EXC
CHIP_NOT_ODEXC = CHIP NOT OD_EXC

#IFDEF CHECK_LOW_DENSITY
OD.DN.2L { @ Min. OD density over window 150 step 75 >= 20% 
  ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC < OD_DN_2L WINDOW OD_DN_2L_W STEP OD_DN_2L_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
  F = WITH WIDTH (ERR_WIN NOT OD_EXC) >= OD_DN_2L_E
  DENSITY F ODx CHIP_NOT_ODEXC < OD_DN_2L WINDOW OD_DN_2L_W STEP OD_DN_2L_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2L.density
          [ !AREA(F)+AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}
#ENDIF

OD.DN.2H_IO { @ Max. OD density over window 150 step 75 <= 90% 
  ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC > OD_DN_2H WINDOW OD_DN_2H_W STEP OD_DN_2H_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
  F = WITH WIDTH (ERR_WIN NOT OD_EXC) >= OD_DN_2H_E
  DENSITY F ODx CHIP_NOT_ODEXC > OD_DN_2H WINDOW OD_DN_2H_W STEP OD_DN_2H_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2H_IO.density
  [ !!AREA(F)*AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]

}

ODx_MAX_CORE = ODx NOT OD2
CHIP_MAX_CORE = CHIP_NOT_ODEXC NOT OD2

OD.DN.2H_CORE { @ Max. OD density over window 150 step 75 <= 80% in core 
  ERR_WIN = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_2H_CORE WINDOW OD_DN_2H_W STEP OD_DN_2H_S INSIDE OF LAYER CHIPx BACKUP
           [ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
  F = WITH WIDTH ((ERR_WIN NOT OD2) NOT OD_EXC) >= OD_DN_2H_E 
  DENSITY F ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_2H_CORE WINDOW OD_DN_2H_W STEP OD_DN_2H_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.2H_CORE.density
  [!!AREA(F)*AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
}


OD.DN.3L { @ Min. OD density over window 150 step 75 >= 20% (within ODBLK)
   ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC < OD_DN_3L WINDOW OD_DN_3L_W STEP OD_DN_3L_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
   F = WITH WIDTH ((ERR_WIN AND ODBLK) NOT OD_EXC) >= OD_DN_3L_E
   DENSITY F ODx CHIP_NOT_ODEXC < OD_DN_3L WINDOW OD_DN_3L_W STEP OD_DN_3L_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.3L.density
          [ !AREA(F)+AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}

OD.DN.3H_IO { @ Max. OD density over window 150 step 75 <= 90% (within ODBLK)
   ERR_WIN = DENSITY ODx CHIP_NOT_ODEXC > OD_DN_3H WINDOW OD_DN_3H_W STEP OD_DN_3H_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
   F = WITH WIDTH ((ERR_WIN AND ODBLK) NOT OD_EXC) >= OD_DN_3H_E
   DENSITY F ODx CHIP_NOT_ODEXC > OD_DN_3H WINDOW OD_DN_3H_W STEP OD_DN_3H_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.3H_IO.density
  [ !!AREA(F)*AREA(ODx)/AREA(CHIP_NOT_ODEXC) ]
}


OD.DN.3H_CORE { @ Max. OD density over window 150 step 75 <= 80% in core (within ODBLK)
  ERR_WIN = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_3H_CORE WINDOW OD_DN_3H_W STEP OD_DN_3H_S INSIDE OF LAYER CHIPx BACKUP
           [ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
  F = WITH WIDTH (((ERR_WIN AND ODBLK) NOT OD2) NOT OD_EXC) >= OD_DN_3H_E 
  DENSITY F ODx_MAX_CORE CHIP_MAX_CORE > OD_DN_3H_CORE WINDOW OD_DN_3H_W STEP OD_DN_3H_S INSIDE OF LAYER CHIPx BACKUP PRINT OD.DN.3H_CORE.density
  [!!AREA(F)*AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
}

#IFDEF FULL_CHIP

DOD.R.1 { @ DOD is must. DOD must be an individual CAD layer (datatype 1 as default, like 6;1)
  CHIPx  NOT INTERACT DOD
}

#ENDIF

// DOD.R.2 is checked by CSR.R.1

DOD.R.3 { @ Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed.   
  NOT RECTANGLE DOD ORTHOGONAL ONLY
  HOLES DOD
}



//THICK OXIDE CHECKS
//==================


OD2.W.1 { @ Width >= 0.47 
  INT OD_18 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD_25 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD_33 < OD2_W_1 ABUT < 90 SINGULAR REGION
}  
OD2.S.1 { @ Space >= 0.47 
  EXT OD2 < OD2_S_1 ABUT < 90 SINGULAR REGION
}
OD2.S.2 { @ OD2 space to {ACTIVE OR GATE} >= ^OD2_S_2 um 
  DACTG = DACT OR GATE  
  EXT OD2 DACTG < OD2_S_2 ABUT < 90 SINGULAR REGION
}
OD2.S.3 { @ Space to 1.0V or 1.2V GATE in S/D direction. >= 0.34 
  A = OD2 INSIDE EDGE OD  
  EXT A GATE_W < OD2_S_3 ABUT < 90 REGION
  GATE CUT OD2
  B = LV_GATE_W INSIDE EDGE VAR
  EXT B OD2 < OD2_S_3 ABUT < 90 OPPOSITE REGION
}
OD2.S.4 { @ Space to NW. Space = 0 is allowed. >= 0.47 
  EXT OD_18 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD_25 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD_33 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EN.1 { @ Enclosure of 1.8V or 2.5V or 3.3V Gate in S/D direction. >= 0.34 
  ENC GATE_W OD_18 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
  ENC GATE_W OD_25 < OD2_EN_1 ABUT < 90 OPPOSITE REGION    
  ENC GATE_W OD_33 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
}
OD2.EX.1 { @ NW extension on OD2. Extension = 0 is allowed. >= 0.47 
  ENC OD_18 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD_25 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD_33 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.2 { @ Extension on NW. Extension = 0 is allowed. >= 0.47 
  ENC NWEL OD_18 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD_25 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD_33 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.3 { @ Extension on {ACTIVE OR GATE} >= 0.27 
   // This only applies to active OD or gate
   DACTG = DACT OR GATE  
   CHECK_EDGE_18 = ENC [DACTG] OD_18 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE_18 NOT COIN OUTSIDE EDGE DSTP
   CHECK_EDGE_25 = ENC [DACTG] OD_25 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE_25 NOT COIN OUTSIDE EDGE DSTP
   CHECK_EDGE_33 = ENC [DACTG] OD_33 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE_33 NOT COIN OUTSIDE EDGE DSTP
   OD_18 INSIDE DACTG
   OD_25 INSIDE DACTG
   OD_33 INSIDE DACTG
}
OD2.O.1 { @ Overlap of NW. Overlap = 0 is allowed. >= 0.47 
  X = OD_18 AND NWEL
  INT X < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Y = OD_25 AND NWEL
  INT Y < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Z = OD_33 AND NWEL
  INT Z < OD2_O_1 ABUT < 89.5 SINGULAR REGION
 
}
OD2.R.1 { @ OD_33, OD_25, and OD_18 can not be used on the same die.
  X = CHIPx INTERACT OD_25
  X INTERACT OD_18
  X INTERACT OD_33
  Y = CHIPx INTERACT OD_33
  Y INTERACT OD_18
}

OD2.W.2 { @ Width of (OD2 OR (NW OR NT_N)) >= 0.47
@ DRC filter out the errors only on NW.
  Y =  OD2i OR NT_Ni
  X =  NWi OR Y
  A = (INT X < OD2_W_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (A OUTSIDE SRAM_EXCLUDE) INTERACT Y 
  B = A CUT SRAM_EXCLUDE
  C = (X INTERACT B) NOT SRAM_EXCLUDE
  D = INT C < OD2_W_2 ABUT < 90 SINGULAR REGION 
  (B INTERACT D) INTERACT Y 
}  

OD2.S.5 { @ Space of (NW NOT OD2) >= 0.47 
  X = NWi NOT OD2i	
  (EXT X < OD2_S_5 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.6 { @ Space of (NW AND OD2) >= 0.47 
  X = NWi AND OD2i	
  (EXT X <  OD2_S_6 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
OD2.S.7 { @ Space of (OD2 NOT (NW OR NT_N)) >= 0.47 
  X = OD2i NOT (NWi OR NT_Ni)	
  (EXT X < OD2_S_7 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}




25_33V_GATE_W = 25V_GATE_W INSIDE EDGE OD25_33
25_18V_GATE_W = 25V_GATE_W INSIDE EDGE OD25_18

OD25_33.W.1 { @ Channel length of 2.5V NMOS overdriven to 3.3V (NMOS Gate AND OD25_33) >= ^OD25_33_W_1 um  
   25_33V_GATE_W_NP = (25_33V_GATE_W INSIDE EDGE NP) NOT COIN INSIDE EDGE RF_DUMMY_GATE  
   INT 25_33V_GATE_W_NP < OD25_33_W_1 ABUT < 90 REGION
}

OD25_33.W.2 { @ Channel length of 2.5V PMOS overdriven to 3.3V (PMOS Gate AND OD25_33) >= ^OD25_33_W_2 um  
   25_33V_GATE_W_PP = (25_33V_GATE_W INSIDE EDGE PP) NOT COIN INSIDE EDGE RF_DUMMY_GATE  
   INT 25_33V_GATE_W_PP < OD25_33_W_2 ABUT < 90 REGION
}

OD25_33.R.1 { @ {GATE AND OD25_33} can't overlap OD_18,OD33,or OD25_18. {Gate AND OD25_33} must be covered by OD_25. OD25_33 can't cut GATE  
   25_33V_GATE = GATE AND OD25_33
   25_33V_GATE AND OD_18
   25_33V_GATE AND OD_33
   25_33V_GATE AND OD25_18
   25_33V_GATE NOT OD_25
   GATE CUT OD25_33
}

OD25_18.W.1 { @ Channel length of 2.5V MOS underdriven to 1.8V (Gate AND OD25_18) >= ^OD25_18_W_1 um  
   INT 25_18V_GATE_W < OD25_18_W_1 ABUT < 90 REGION
}

OD25_18.R.1 { @ {GATE AND OD25_18} can't overlap OD_18,OD33,or OD25_33. {Gate AND OD25_18} must be covered by OD_25. OD25_18 can't cut GATE  
   25_18V_GATE = GATE AND OD25_18
   25_18V_GATE AND OD_18
   25_18V_GATE AND OD_33
   25_18V_GATE AND OD25_33
   25_18V_GATE NOT OD_25
   GATE CUT OD25_18
}




//PO CHECKS
//=========

POLY_EDGE_45 = POLY ANGLE == 45

PO.W.1 { @ Width >= ^PO_W_1 um 
  INT POLY < PO_W_1 ABUT < 90 SINGULAR REGION
}


PO.S.1 { @ Space >= ^PO_S_1 um 
  EXT POLY < PO_S_1 ABUT < 90 SINGULAR REGION
}

PO.S.2 { @ GATE space in the same OD >= ^PO_S_2 um. 
  EXT GATE_W < PO_S_2 ABUT < 90 REGION
}

PO.W.2 { @ Channel length of 2.5V MOS >= ^PO_W_2 um 
   25V_GATE_W_NORMAL = 25V_GATE_W NOT INSIDE EDGE (OD25_18 OR OD25_33) 
   INT 25V_GATE_W_NORMAL < PO_W_2 ABUT < 90 REGION 
}

PO.W.3 { @ Channel length of 3.3V MOS (except gate without PO CO in RFDMY) >= ^PO_W_3 um 
   33V_GATE_W_CHECK = 33V_GATE_W NOT COIN INSIDE EDGE RF_DUMMY_GATE
   INT 33V_GATE_W_CHECK < PO_W_3 ABUT < 90 REGION
}

PO.W.4 { @ Channel length of 1.8V MOS >= ^PO_W_4 um
  INT 18V_GATE_W < PO_W_4 ABUT < 90 REGION
}

PO.W.5 { @ Width of 45 degree FIELD poly >= ^PO_W_5 um 
  A = POLY_EDGE_45 NOT INSIDE EDGE POFUSE
  INT A < PO_W_5 ABUT < 90 REGION
  EFUSE = POi AND POFUSE
  INT EFUSE < PO_W_5_F ABUT<90 SINGULAR REGION
}

PO.S.16 { @ Space to 45 degree FIELD poly >= ^PO_S_16 um 
  X = EXPAND EDGE POLY_EDGE_45 OUTSIDE BY PO_S_16
  X AND POLY
}


PO.S.2.1 { @ Gate space [either one channel length > ^PO_S_2_1_W um] >= ^PO_S_2_1 um
  GATE_LL = LENGTH GATE_L > PO_S_2_1_W
  GATE_F = GATE WITH EDGE GATE_LL
  GATE_WW = POLY COIN INSIDE EDGE GATE_F
  EXT GATE_W GATE_WW < PO_S_2_1 ABUT < 90 REGION
}

PO.S.3 { @ Min. two 1.8V,2.5V or 3.3V POLY space on OD w/o contact >= ^PO_S_3 um 
  EXT HV_GATE_W < PO_S_3 ABUT < 90 REGION
}

PO.S.4 { @ Field PO space to OD >= ^PO_S_4 um 
  EXT POLY OD < PO_S_4 ABUT < 89.5 SINGULAR REGION
}

PO.S.4.1 { @ Gate space when the area enclosed by (L-shape OD & PO < ^PO_S_4_1_A um2) >= ^PO_S_4_1 um
     EXT GATE < PO_S_4_1 ABUT < 90 REGION CORNER TO CORNER 
}

S_GATE_W1 = LENGTH GATE_W < PO_S_5_W
EX_GATEW_EDGE = EXPAND EDGE S_GATE_W1 INSIDE BY GRID EXTEND BY OD_S_1
EX_GATEW_EDGE_T = EX_GATEW_EDGE COIN INSIDE EDGE POLY 

PO.S.5 { @ Space to L-shape OD when PO & OD are in same MOS(channel width < ^PO_S_5_W ) ^PO_S_5 um
   EXT OD EX_GATEW_EDGE_T < PO_S_5 ABUT < 90 OPPOSITE REGION
}

SU_GATE = GATE WITH EDGE S_GATE_W1	// Use the same setting of PO_S_5_W for PO_S_6_W
OD_GATE_EDGE = OD COIN INSIDE EDGE SU_GATE
EX_ODGATE_EDGE = EXPAND EDGE OD_GATE_EDGE INSIDE BY GRID EXTEND BY PO_S_1
EX_ODGATE_EDGE_T = (OD COIN INSIDE EDGE EX_ODGATE_EDGE) TOUCH INSIDE EDGE OD_GATE_EDGE

PO.S.6 { @ L-shape PO space to OD when PO and OD are in same MOS (channel width < ^PO_S_6_W um) ^PO_S_6 um 
    EXT POLY EX_ODGATE_EDGE_T < PO_S_6 ABUT < 90 OPPOSITE REGION
}

PO.S.7 { @ Space if at least one PO width is > 0.13 um, and the PO parallel run length is > 0.18 um (individual projection). >= 0.18 
  Wide_POLY = (SIZE POLY BY PO_S_7_W /2 UNDEROVER TRUNCATE PO_S_7_W /2) AND POLY
  X = EXT Wide_POLY POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
  Y = ENCLOSE RECTANGLE X PO_S_1 - GRID PO_S_7_L + GRID
  WideEdge = Wide_POLY COIN OUTSIDE EDGE Y
  A = PATH LENGTH WideEdge > PO_S_7_L
  B = EXPAND EDGE A BY 0.001
  C = EXTENTS B 
  D = ENCLOSE RECTANGLE C 0.001 PO_S_7_L + GRID ORTHOGONAL ONLY
  E = A INSIDE EDGE D
  EXT E POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
}
PO.S.9 { @ Space of {PO AND RPO} >= 0.25 
  A = POLY INSIDE EDGE RPO
  EXT A < PO_S_9 ABUT < 90 REGION
}
PO.S.10 { @ Space at PO line-end (W<Q1=0.090) in a dense-line-end configuration: If PO has parallel run length with opposite PO (measured with T1=0.035 extension) along 2 adjacent edges of PO [any one edge <Q1 distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.06 um(R)) >= 0.14 
  A = CONVEX EDGE POLY ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < PO_S_10_Q
  B = EXT [A] POLY < PO_S_10 ABUT < 90 OPPOSITE EXTENDED PO_S_10_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [POLY] < PO_S_10_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= PO_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY PO_S_10_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O POLY < PO_S_10 ABUT < 90 OPPOSITE REGION
}


PO.EX.1 { @ Extension on OD (end-cap) >= 0.14 
  (ENC OD POLY < PO_EX_1 ABUT < 89.5 OPPOSITE SINGULAR REGION) NOT INSIDE LOGO
}
PO.EX.2 { @ OD extension on PO >= 0.115 
  (ENC POLY OD < PO_EX_2 ABUT < 89.5 SINGULAR REGION) NOT INSIDE LOGO
}
PO.EX.3 { @ Extension on OD (end-cap) when the PO space to L-shape OD (in the same MOS) is < 0.1 um, and the channel width (W) is >= 0.15 um. >= 0.16 
  A = LENGTH GATE_W >= PO_EX_3_W
  B = EXPAND EDGE A INSIDE BY GRID EXTEND BY PO_EX_3
  C = EXPAND EDGE A OUTSIDE BY GRID EXTEND BY PO_EX_3 
  D = B COIN OUTSIDE EDGE C
  E = EXT D OD < PO_EX_3_S ABUT < 90 OPPOSITE REGION
  F = E COIN OUTSIDE EDGE FPO1
  G = EXPAND EDGE F OUTSIDE BY GRID
  H = GATE_L TOUCH OUTSIDE EDGE G
  I = EXPAND EDGE H OUTSIDE BY PO_EX_3
  J = I INTERACT E
  (J NOT POLY) NOT INSIDE LOGO
}  
    
PO.L.1 { @ Maximum PO length between 2 contacts, as well as the length bewteen one contact and the end of PO gate, when the PO width  < ^PO_L_1_W um (except RTMOM region) <=  ^PO_L_1 um 
  LONGP = AREA ILP1 > PO_W_1 * PO_L_1	
  X = LONGP INTERACT COPO
  CHECK_COPO = COPO INTERACT X
  A = SIZE CHECK_COPO BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  P2P = X INTERACT A > 1
  BAD = P2P NOT A
  BAD_EDGE = BAD COIN INSIDE EDGE POLY
  ERR = INT BAD_EDGE < PO_L_1_W ABUT < 90 REGION
  X1 = (X INTERACT ERR) NOT GATE
  CHECK_COPO1 = CHECK_COPO INTERACT X1
  A1 = SIZE CHECK_COPO1 BY PO_L_1 / 2 INSIDE OF X1 STEP PO_S_1*0.7
  P2P1 = X1 INTERACT A1 > 1
  BAD1 = (P2P1 NOT A1) INTERACT A1 > 1
  BAD_EDGE1 = BAD1 COIN INSIDE EDGE POLY
  ERR1 = INT BAD_EDGE1 < PO_L_1_W ABUT < 90 REGION
  X1 INTERACT ERR1
  NARROW_GATE = (GATE WITH EDGE (LENGTH GATE_L < PO_L_1_W)) AND X
  B = SIZE A BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  (NARROW_GATE NOT B) NOT INSIDE RTMOMDMY
}

PO.A.1 { @ Area >= 0.042 
  (AREA POLYs < PO_A_1) NOT INSIDE SRAM_EXCLUDE
}
PO.A.1.1 { @ Area {PO not interacting with Gate} >= 0.051 
  POLY_NOT_GATE = POLYs NOT INTERACT GATE   
  (AREA POLY_NOT_GATE < PO_A_1_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE PO_A_2pre ((PO_A_2 + (PO_S_1 * PO_S_1 * 3.142))/(2 * PO_S_1))*((PO_A_2 + (PO_S_1 * PO_S_1 * 3.142))/(2 * PO_S_1))/3.141
PO.A.2 { @ Enclosed area >= 0.094 
  A = HOLES POLY INNER < PO_A_2pre
  B = A NOT POLY
  AREA B < PO_A_2
}

#IFDEF FULL_CHIP
PO.DN.1L { @ Min. POLY density across full chip >= 14%
  DENSITY ALL_POLY CHIP < PO_DN_1_L INSIDE OF LAYER CHIPx PRINT PO.DN.1L.density
  [ AREA(ALL_POLY)/AREA(CHIP) ]
  
}
PO.DN.1H { @ Max. poly density across full chip <= 40%
  DENSITY ALL_POLY CHIP > PO_DN_1_H INSIDE OF LAYER CHIPx PRINT PO.DN.1H.density
  [ AREA(ALL_POLY)/AREA(CHIP) ]
 
}
#ENDIF

ALL_POD = ALL_OD OR ALL_POLY
PODEXC  = ((ODBLK OR POBLK) OR NWDMY) OR DEN_EXC
PODx    = ALL_POD NOT PODEXC
CHIP_NOT_PODEXC = CHIP NOT PODEXC

#IFDEF CHECK_LOW_DENSITY
PO.DN.2 { @ {OD OR DOD OR PO OR DPO } local density (minimun) over window 20um x 20um stepping 10um >= 0.1%
  ERR_WIN = DENSITY ALL_POD CHIP < PO_DN_2 WINDOW PO_DN_2_W STEP PO_DN_2_S INSIDE OF LAYER CHIPx BACKUP  
          [ AREA(ALL_POD)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT PODEXC) >= PO_DN_2_E
  DENSITY F ALL_POD CHIP < PO_DN_2 WINDOW PO_DN_2_W STEP PO_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT PO.DN.2.density 
          [ !AREA(F)+AREA(ALL_POD)/AREA(CHIP) ]
}
#ENDIF

POx    = ALL_POLY NOT DEN_EXC
PO_EXC    = POi NOT DEN_EXC
CHIP_NOT_POEXC = CHIP NOT DEN_EXC
CHECK_POBLK = POBLK NOT TCDDMY
CHIP_POBLK = CHIP_NOT_POEXC AND CHECK_POBLK
PO_POBLK = POx AND CHECK_POBLK

PO.DN.3 { @ PO density within POBLK except TCDDMY 14 %  
  A = DENSITY PO_POBLK CHIP_POBLK < PO_DN_3 PRINT PO.DN.3.density   
  [ AREA(PO_POBLK)/AREA(CHIP_POBLK) ]
  A AND CHECK_POBLK
}



PO.R.1 { @ GATE must be a rectangle orthogonal to grid. (Both bent GATE and Gate to have jog are not allowed).   
  (NOT RECTANGLE GATE ORTHOGONAL ONLY) NOT INSIDE LOGO
}


// PO.R.2 can not be checked by DRC


PO.R.4 { @ PO intersecting OD must form two or more diffusions except RTMOM region (RTMOMDMY, CAD layer: 155;21).   
  GATEW = GATE INSIDE EDGE OD
  X = GATE NOT WITH EDGE GATEW == 2
  A = INT GATEW < GRID ABUT == 90 INTERSECTING ONLY REGION
  ((X OR (GATE INTERACT A)) NOT LOGO) NOT RTMOMDMY  
}  

PO.S.15 { @ Large PO to gate [channel length <=0.08 um] space. The large PO is defined as PO area >=630 um and interact with regions of density > 70% flagged by 30 um x 30 um (stepping 15 um) window density check. DPO will be excluded from density check. 1.0  
  A = AREA PO_EXC >= PO_S_15_A
  B = EXTENTS A
  C = SIZE B BY 15
  D = DENSITY PO_EXC > PO_S_15_DN INSIDE OF LAYER C WINDOW 30 STEP 15 BACKUP //PRINT PO.S.15.density
  E = A INTERACT D 
  GATE_W_S80 = INT [GATE_W] <= PO_S_15_L
  GATE_S80 = GATE WITH EDGE GATE_W_S80
  EXT E GATE_S80 < PO_S_15 ABUT<90 REGION 
}

PO.R.6 { @ H-gate forbidden with channel length (V) < 0.11 mm, PO center bar length (U) < 0.425 mm, all four H-legs length (X) > 0.065 mm, and all four H-legs width (Y) < 0.255 mm.   
  A1 = CONVEX EDGE POLY ANGLE1 == 270 ANGLE2 == 270 
  A = LENGTH A1 >= PO_S_1 < PO_R_6_U     
  B = A INSIDE EDGE OD
  C = POLY TOUCH EDGE B
  D = INTERNAL [POLY] < PO_R_6_V OPPOSITE 
  E = POLY TOUCH EDGE D
  F = C COINCIDENT EDGE E
  G = EXPAND EDGE F INSIDE BY PO_R_6_V/2
  H = INTERNAL [G] > PO_R_6_V/2 <= PO_R_6_V OPPOSITE 
  I = EXPAND EDGE H INSIDE BY GRID EXTEND BY GRID
  J = INTERNAL [POLY] < PO_R_6_W OPPOSITE 
  K = LENGTH J > PO_R_6_X
  L = POLY INSIDE EDGE OD
  M = POLY TOUCH EDGE L
  O = K NOT COINCIDENT EDGE M
  P = EXPAND EDGE O INSIDE BY GRID EXTEND BY GRID
  Q = EXPAND EDGE O INSIDE BY GRID EXTEND BY -(2*GRID)
  R = P NOT Q
  S = I OR R
  T = CONVEX EDGE S ANGLE1 == 270 ANGLE2 == 270 
  U = EXPAND EDGE T INSIDE BY PO_R_6_V/2
  V = INTERNAL U > PO_R_6_V/2 <= PO_R_6_V OPPOSITE REGION
  COPY V
}

#IFDEF FULL_CHIP

GATEi  = POi AND ODi
GATEu  = STAMP GATEi BY POu
NSDu_g  = NSDu INTERACT POu 
PSDu_g  = PSDu INTERACT POu 


Float_GATE = NET AREA RATIO GATEu PSTPu NSTPu PSDu_g NSDu_g CBu CB2u UBMnu UBMdu COu > 0 
	[!AREA(PSTPu)*!AREA(NSTPu)*!AREA(PSDu_g)*!AREA(NSDu_g)*!AREA(CBu)*!AREA(CB2u)*!AREA(UBMnu)*!AREA(UBMdu)+!AREA(COu)]
Float_NSD = NET AREA RATIO NSDu_g PSDu_g GATEu PSTPu NSTPu CBu CB2u UBMnu UBMdu > 0
	[~(COUNT(NSDu_g)-1)*!AREA(PSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(CBu)*!AREA(CB2u)*!AREA(UBMnu)*!AREA(UBMdu)]
Float_PSD = NET AREA RATIO PSDu_g NSDu_g GATEu PSTPu NSTPu CBu CB2u UBMnu UBMdu > 0
	[~(COUNT(PSDu_g)-1)*!AREA(NSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(CBu)*!AREA(CB2u)*!AREA(UBMnu)*!AREA(UBMdu)]

effective_NSD = NSDu_g NOT Float_NSD
effective_PSD = PSDu_g NOT Float_PSD

Float_NSD_a = Float_NSD NOT ((Float_NSD OR GATE) TOUCH effective_NSD == 2)
Float_PSD_a = Float_PSD NOT ((Float_PSD OR GATE) TOUCH effective_PSD == 2)    

Float_GATE_check = Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a) 

PO.R.8{@ It is prohibited for Floating Gate if the effective source/drain is not connected together 
    Float_GATE_check INTERACT NSDu > 1 BY NET
    Float_GATE_check INTERACT PSDu > 1 BY NET     
}

#ENDIF

#IFDEF GP
PO.FU.R.8 {@ FUSELINK must exist and be inside POFUSE if POFUSE is exist.
    FUSELINK NOT INSIDE POFUSE
    POFUSE NOT INTERACT FUSELINK
}
#ELSE
#IFDEF HALF_NODE
#IFDEF LP
PO.FU.R.8 {@ FUSELINK must exist and be inside POFUSE if POFUSE is exist.
    FUSELINK NOT INSIDE POFUSE
    POFUSE NOT INTERACT FUSELINK
}
#ENDIF
#ENDIF
#ENDIF



//DUMMY POLY RULE
//================

DPO.W.1 { @ Width >= 0.4 
  INT DPO < DPO_W_1 ABUT < 90 SINGULAR REGION
}
DPO.S.1 { @ Space >= 0.3 
  EXT DPO < DPO_S_1 ABUT < 90 SINGULAR REGION
}
DPO.S.2 { @ Space to OD (Overlap is not allowed) >= 0.2 
  EXT ODi DPO < DPO_S_2 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DPO.S.3 { @ Space to PO (Overlap is not allowed) >= 0.5 
  EXT POi DPO < DPO_S_3 ABUT < 90 SINGULAR REGION INSIDE ALSO
}
DPO.S.5 { @ Space to FW (Overlap is not allowed) >= 1.2 
  EXT FWi DPO < DPO_S_5 ABUT < 90 SINGULAR REGION
  FWi AND DPO
}
// for solid L-mark (old)
DPO.S.6 { @ Space to LMARK (Overlap is not allowed) >= ^DPO_S_6 um
  EXT LMARK_SOLID DPO < DPO_S_6 ABUT < 90 SINGULAR REGION
  LMARK_SOLID AND DPO
}
// for hollow L-mark (new)
DPO.S.6.1 { @ Space to L-slot (Overlap is not allowed) >= ^DPO_S_6_1 um
  EXT LSLOT DPO < DPO_S_6_1 ABUT < 90 SINGULAR REGION
  LSLOT AND DPO
}

DPO.S.8 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DPO
}
DPO.S.9 { @ Space to INDDMY (Overlap is not allowed) >= 1.2 
  EXT INDDMY DPO < DPO_S_9 ABUT < 90 SINGULAR REGION
  INDDMY AND DPO
}

#IFDEF FULL_CHIP
DPO.EN.1 { @ Enclosure by chip edge >= 0.6 
  DPO NOT (SIZE CHIP_CHAMFERED BY -DPO_EN_1)
}
DPO.R.1 { @ DPO is must. DPO must be an individual CAD layer (datatype 1 as default, like 17;1)
  CHIPx NOT INTERACT DPO
}
#ENDIF

// DPO.R.2 is checked by CSR.R.1

DPO.R.3 { @ Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed.   
  NOT RECTANGLE DPO ORTHOGONAL ONLY
  HOLES DPO
}


Normal_TCD = RECTANGLE TCDDMY ==12 BY ==12 ORTHOGONAL ONLY
Small_TCD = RECTANGLE TCDDMY == 9.245 BY == 9.245 ORTHOGONAL ONLY 

DTCD.W.1 {@ Width of TCDDMY  = 12 or 9.245
   (TCDDMY NOT Normal_TCD) NOT Small_TCD
}


DTCD.R.1 {@ TCDDMY should contain OD/PO/PP/NP/POBLK/ODBLK layer
   TCDDMY OUTSIDE ODi
   TCDDMY OUTSIDE POi    
   Normal_TCD OUTSIDE PPi
   TCDDMY OUTSIDE NPi
   TCDDMY OUTSIDE POBLK
   TCDDMY OUTSIDE ODBLK
}

DTCD.R.2{@ OD/PO/PP/NP/POBLK/ODBLK layout in the TCDDMY must exactly same as them in tsmc's utility.
  6_0_n_rec_1 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 11.43 RIGHT BY (12-11.55) TOP BY (12-11.51)
  6_0_n_rec_2 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 11.24 RIGHT BY (12-11.55) TOP BY (12-11.32)
  6_0_n_rec_3 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 11.05 RIGHT BY (12-11.55) TOP BY (12-11.13)
  6_0_n_rec_4 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 10.86 RIGHT BY (12-11.55) TOP BY (12-10.94)
  6_0_n_rec_5 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 10.67 RIGHT BY (12-11.55) TOP BY (12-10.75)
  6_0_n_rec_6 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 10.48 RIGHT BY (12-11.55) TOP BY (12-10.56)
  6_0_n_rec_7 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 10.29 RIGHT BY (12-11.55) TOP BY (12-10.37)
  6_0_n_rec_8 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 10.1 RIGHT BY (12-11.55) TOP BY (12-10.18)
  6_0_n_rec_9 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 9.91 RIGHT BY (12-11.55) TOP BY (12-9.99)
  6_0_n_rec_10 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 9.72 RIGHT BY (12-11.55) TOP BY (12-9.8)
  6_0_n_rec_11 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 9.34 RIGHT BY (12-11.55) TOP BY (12-9.42)
  6_0_n_rec_12 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 9.15 RIGHT BY (12-11.55) TOP BY (12-9.23)
  6_0_n_rec_13 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 8.77 RIGHT BY (12-11.55) TOP BY (12-8.85)
  6_0_n_rec_14 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 8.58 RIGHT BY (12-11.55) TOP BY (12-8.66)
  6_0_n_rec_15 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 8.39 RIGHT BY (12-11.55) TOP BY (12-8.47)
  6_0_n_rec_16 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 8.2 RIGHT BY (12-11.55) TOP BY (12-8.28)
  6_0_n_rec_17 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 8.01 RIGHT BY (12-11.55) TOP BY (12-8.09)
  6_0_n_rec_18 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 7.82 RIGHT BY (12-11.55) TOP BY (12-7.9)
  6_0_n_rec_19 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 7.63 RIGHT BY (12-11.55) TOP BY (12-7.71)
  6_0_n_rec_20 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 7.44 RIGHT BY (12-11.55) TOP BY (12-7.52)
  6_0_n_rec_21 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 7.25 RIGHT BY (12-11.55) TOP BY (12-7.33)
  6_0_n_rec_22 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 7.06 RIGHT BY (12-11.55) TOP BY (12-7.14)
  6_0_n_rec_23 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 6.87 RIGHT BY (12-11.55) TOP BY (12-6.95)
  6_0_n_rec_24 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 6.68 RIGHT BY (12-11.55) TOP BY (12-6.76)
  6_0_n_rec_25 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 6.49 RIGHT BY (12-11.55) TOP BY (12-6.57)
  6_0_n_rec_26 = SHRINK Normal_TCD LEFT BY 6.255 BOTTOM BY 0.5 RIGHT BY (12-11.255) TOP BY (12-5.5)
  6_0_n_rec_27 = SHRINK Normal_TCD LEFT BY 6.25 BOTTOM BY 8.96 RIGHT BY (12-11.85) TOP BY (12-9.04)
  6_0_n_rec_28 = SHRINK Normal_TCD LEFT BY 5.555 BOTTOM BY 10.01 RIGHT BY (12-5.995) TOP BY (12-11.23)
  6_0_n_rec_29 = SHRINK Normal_TCD LEFT BY 5.555 BOTTOM BY 6.77 RIGHT BY (12-5.995) TOP BY (12-7.99)
  6_0_n_rec_30 = SHRINK Normal_TCD LEFT BY 4.775 BOTTOM BY 10.01 RIGHT BY (12-5.215) TOP BY (12-11.23)
  6_0_n_rec_31 = SHRINK Normal_TCD LEFT BY 4.775 BOTTOM BY 9.17 RIGHT BY (12-5.995) TOP BY (12-9.61)
  6_0_n_rec_32 = SHRINK Normal_TCD LEFT BY 4.775 BOTTOM BY 8.39 RIGHT BY (12-5.995) TOP BY (12-8.83)
  6_0_n_rec_33 = SHRINK Normal_TCD LEFT BY 4.775 BOTTOM BY 6.77 RIGHT BY (12-5.215) TOP BY (12-7.99)
  6_0_n_rec_34 = SHRINK Normal_TCD LEFT BY 3.935 BOTTOM BY 10.01 RIGHT BY (12-4.375) TOP BY (12-11.23)
  6_0_n_rec_35 = SHRINK Normal_TCD LEFT BY 3.935 BOTTOM BY 6.77 RIGHT BY (12-4.375) TOP BY (12-7.99)
  6_0_n_rec_36 = SHRINK Normal_TCD LEFT BY 3.155 BOTTOM BY 10.01 RIGHT BY (12-3.595) TOP BY (12-11.23)
  6_0_n_rec_37 = SHRINK Normal_TCD LEFT BY 3.155 BOTTOM BY 9.17 RIGHT BY (12-4.375) TOP BY (12-9.61)
  6_0_n_rec_38 = SHRINK Normal_TCD LEFT BY 3.155 BOTTOM BY 8.39 RIGHT BY (12-4.375) TOP BY (12-8.83)
  6_0_n_rec_39 = SHRINK Normal_TCD LEFT BY 3.155 BOTTOM BY 6.77 RIGHT BY (12-3.595) TOP BY (12-7.99)
  6_0_n_rec_40 = SHRINK Normal_TCD LEFT BY 1.8 BOTTOM BY 6.3 RIGHT BY (12-2.8) TOP BY (12-7.3)
  6_0_n_rec_41 = SHRINK Normal_TCD LEFT BY 1.535 BOTTOM BY 9.17 RIGHT BY (12-2.755) TOP BY (12-9.61)
  6_0_n_rec_42 = SHRINK Normal_TCD LEFT BY 1.535 BOTTOM BY 8.39 RIGHT BY (12-2.755) TOP BY (12-8.83)
  6_0_n_rec_43 = SHRINK Normal_TCD LEFT BY 0.745 BOTTOM BY 0.5 RIGHT BY (12-5.745) TOP BY (12-5.5)
  6_0_n_rec_44 = SHRINK Normal_TCD LEFT BY 0.3 BOTTOM BY 7.8 RIGHT BY (12-1.3) TOP BY (12-8.8)
  6_0_n_rec_45 = SHRINK Normal_TCD LEFT BY 0.3 BOTTOM BY 6.3 RIGHT BY (12-1.3) TOP BY (12-7.3)
  6_0_n_rec_46 = SHRINK Normal_TCD LEFT BY 6.55 BOTTOM BY 9.53 RIGHT BY (12-11.55) TOP BY (12-9.61)
  17_0_n_rec_1 = SHRINK Normal_TCD LEFT BY 4.635 BOTTOM BY 7.35 RIGHT BY (12-6.135) TOP BY (12-7.41)
  17_0_n_rec_2 = SHRINK Normal_TCD LEFT BY 5.355 BOTTOM BY 6.63 RIGHT BY (12-5.415) TOP BY (12-8.13)
  17_0_n_rec_3 = SHRINK Normal_TCD LEFT BY 3.735 BOTTOM BY 6.63 RIGHT BY (12-3.795) TOP BY (12-8.13)
  17_0_n_rec_4 = SHRINK Normal_TCD LEFT BY 3.015 BOTTOM BY 7.35 RIGHT BY (12-4.515) TOP BY (12-7.41)
  17_0_n_rec_5 = SHRINK Normal_TCD LEFT BY 1.395 BOTTOM BY 8.97 RIGHT BY (12-2.895) TOP BY (12-9.03)
  17_0_n_rec_6 = SHRINK Normal_TCD LEFT BY 2.115 BOTTOM BY 8.25 RIGHT BY (12-2.175) TOP BY (12-9.75)
  17_0_n_rec_7 = SHRINK Normal_TCD LEFT BY 3.735 BOTTOM BY 8.25 RIGHT BY (12-3.795) TOP BY (12-9.75)
  17_0_n_rec_8 = SHRINK Normal_TCD LEFT BY 3.015 BOTTOM BY 8.97 RIGHT BY (12-4.515) TOP BY (12-9.03)
  17_0_n_rec_9 = SHRINK Normal_TCD LEFT BY 4.635 BOTTOM BY 8.97 RIGHT BY (12-6.135) TOP BY (12-9.03)
  17_0_n_rec_10 = SHRINK Normal_TCD LEFT BY 5.355 BOTTOM BY 8.25 RIGHT BY (12-5.415) TOP BY (12-9.75)
  17_0_n_rec_11 = SHRINK Normal_TCD LEFT BY 5.355 BOTTOM BY 9.87 RIGHT BY (12-5.415) TOP BY (12-11.37)
  17_0_n_rec_12 = SHRINK Normal_TCD LEFT BY 4.635 BOTTOM BY 10.59 RIGHT BY (12-6.135) TOP BY (12-10.65)
  17_0_n_rec_13 = SHRINK Normal_TCD LEFT BY 3.735 BOTTOM BY 9.87 RIGHT BY (12-3.795) TOP BY (12-11.37)
  17_0_n_rec_14 = SHRINK Normal_TCD LEFT BY 3.015 BOTTOM BY 10.59 RIGHT BY (12-4.515) TOP BY (12-10.65)
  17_0_n_rec_15 = SHRINK Normal_TCD LEFT BY 11.61 BOTTOM BY 0.25 RIGHT BY (12-11.7) TOP BY (12-5.75)
  17_0_n_rec_16 = SHRINK Normal_TCD LEFT BY 11.315 BOTTOM BY 0.25 RIGHT BY (12-11.405) TOP BY (12-5.75)
  17_0_n_rec_17 = SHRINK Normal_TCD LEFT BY 10.845 BOTTOM BY 0.25 RIGHT BY (12-10.905) TOP BY (12-5.75)
  17_0_n_rec_18 = SHRINK Normal_TCD LEFT BY 10.58 BOTTOM BY 0.25 RIGHT BY (12-10.64) TOP BY (12-5.75)
  17_0_n_rec_19 = SHRINK Normal_TCD LEFT BY 10.315 BOTTOM BY 0.25 RIGHT BY (12-10.375) TOP BY (12-5.75)
  17_0_n_rec_20 = SHRINK Normal_TCD LEFT BY 10.05 BOTTOM BY 0.25 RIGHT BY (12-10.11) TOP BY (12-5.75)
  17_0_n_rec_21 = SHRINK Normal_TCD LEFT BY 9.785 BOTTOM BY 0.25 RIGHT BY (12-9.845) TOP BY (12-5.75)
  17_0_n_rec_22 = SHRINK Normal_TCD LEFT BY 9.52 BOTTOM BY 0.25 RIGHT BY (12-9.58) TOP BY (12-5.75)
  17_0_n_rec_23 = SHRINK Normal_TCD LEFT BY 9.255 BOTTOM BY 0.25 RIGHT BY (12-9.315) TOP BY (12-5.75)
  17_0_n_rec_24 = SHRINK Normal_TCD LEFT BY 8.99 BOTTOM BY 0.25 RIGHT BY (12-9.05) TOP BY (12-5.75)
  17_0_n_rec_25 = SHRINK Normal_TCD LEFT BY 8.725 BOTTOM BY 0.15 RIGHT BY (12-8.785) TOP BY (12-6)
  17_0_n_rec_26 = SHRINK Normal_TCD LEFT BY 8.46 BOTTOM BY 0.25 RIGHT BY (12-8.52) TOP BY (12-5.75)
  17_0_n_rec_27 = SHRINK Normal_TCD LEFT BY 8.195 BOTTOM BY 0.25 RIGHT BY (12-8.255) TOP BY (12-5.75)
  17_0_n_rec_28 = SHRINK Normal_TCD LEFT BY 7.93 BOTTOM BY 0.25 RIGHT BY (12-7.99) TOP BY (12-5.75)
  17_0_n_rec_29 = SHRINK Normal_TCD LEFT BY 7.665 BOTTOM BY 0.25 RIGHT BY (12-7.725) TOP BY (12-5.75)
  17_0_n_rec_30 = SHRINK Normal_TCD LEFT BY 7.4 BOTTOM BY 0.25 RIGHT BY (12-7.46) TOP BY (12-5.75)
  17_0_n_rec_31 = SHRINK Normal_TCD LEFT BY 7.135 BOTTOM BY 0.25 RIGHT BY (12-7.195) TOP BY (12-5.75)
  17_0_n_rec_32 = SHRINK Normal_TCD LEFT BY 6.87 BOTTOM BY 0.25 RIGHT BY (12-6.93) TOP BY (12-5.75)
  17_0_n_rec_33 = SHRINK Normal_TCD LEFT BY 6.605 BOTTOM BY 0.25 RIGHT BY (12-6.665) TOP BY (12-5.75)
  17_0_n_rec_34 = SHRINK Normal_TCD LEFT BY 5.335 BOTTOM BY 0.25 RIGHT BY (12-5.395) TOP BY (12-5.75)
  17_0_n_rec_35 = SHRINK Normal_TCD LEFT BY 5.07 BOTTOM BY 0.25 RIGHT BY (12-5.13) TOP BY (12-5.75)
  17_0_n_rec_36 = SHRINK Normal_TCD LEFT BY 4.805 BOTTOM BY 0.25 RIGHT BY (12-4.865) TOP BY (12-5.75)
  17_0_n_rec_37 = SHRINK Normal_TCD LEFT BY 4.54 BOTTOM BY 0.25 RIGHT BY (12-4.6) TOP BY (12-5.75)
  17_0_n_rec_38 = SHRINK Normal_TCD LEFT BY 4.275 BOTTOM BY 0.25 RIGHT BY (12-4.335) TOP BY (12-5.75)
  17_0_n_rec_39 = SHRINK Normal_TCD LEFT BY 4.01 BOTTOM BY 0.25 RIGHT BY (12-4.07) TOP BY (12-5.75)
  17_0_n_rec_40 = SHRINK Normal_TCD LEFT BY 3.745 BOTTOM BY 0.25 RIGHT BY (12-3.805) TOP BY (12-5.75)
  17_0_n_rec_41 = SHRINK Normal_TCD LEFT BY 3.48 BOTTOM BY 0.25 RIGHT BY (12-3.54) TOP BY (12-5.75)
  17_0_n_rec_42 = SHRINK Normal_TCD LEFT BY 3.215 BOTTOM BY 0.15 RIGHT BY (12-3.275) TOP BY (12-6)
  17_0_n_rec_43 = SHRINK Normal_TCD LEFT BY 2.95 BOTTOM BY 0.25 RIGHT BY (12-3.01) TOP BY (12-5.75)
  17_0_n_rec_44 = SHRINK Normal_TCD LEFT BY 2.685 BOTTOM BY 0.25 RIGHT BY (12-2.745) TOP BY (12-5.75)
  17_0_n_rec_45 = SHRINK Normal_TCD LEFT BY 2.42 BOTTOM BY 0.25 RIGHT BY (12-2.48) TOP BY (12-5.75)
  17_0_n_rec_46 = SHRINK Normal_TCD LEFT BY 2.155 BOTTOM BY 0.25 RIGHT BY (12-2.215) TOP BY (12-5.75)
  17_0_n_rec_47 = SHRINK Normal_TCD LEFT BY 1.89 BOTTOM BY 0.25 RIGHT BY (12-1.95) TOP BY (12-5.75)
  17_0_n_rec_48 = SHRINK Normal_TCD LEFT BY 1.8 BOTTOM BY 10.7 RIGHT BY (12-2.8) TOP BY (12-11.7)
  17_0_n_rec_49 = SHRINK Normal_TCD LEFT BY 1.625 BOTTOM BY 0.25 RIGHT BY (12-1.685) TOP BY (12-5.75)
  17_0_n_rec_50 = SHRINK Normal_TCD LEFT BY 1.36 BOTTOM BY 0.25 RIGHT BY (12-1.42) TOP BY (12-5.75)
  17_0_n_rec_51 = SHRINK Normal_TCD LEFT BY 1.095 BOTTOM BY 0.25 RIGHT BY (12-1.155) TOP BY (12-5.75)
  17_0_n_rec_52 = SHRINK Normal_TCD LEFT BY 0.3 BOTTOM BY 10.7 RIGHT BY (12-1.3) TOP BY (12-11.7)
  17_0_n_rec_53 = SHRINK Normal_TCD LEFT BY 0.3 BOTTOM BY 9.2 RIGHT BY (12-1.3) TOP BY (12-10.2)
  17_0_n_rec_54 = SHRINK Normal_TCD LEFT BY 0.3 BOTTOM BY 0.25 RIGHT BY (12-0.595) TOP BY (12-5.75)
  25_0_n_rec_1 = SHRINK Normal_TCD LEFT BY 6 BOTTOM BY 0 RIGHT BY (12-12) TOP BY (12-6)
  26_0_n_rec_1 = SHRINK Normal_TCD LEFT BY 0 BOTTOM BY 0 RIGHT BY (12-6) TOP BY (12-6)
  26_0_n_rec_2 = SHRINK Normal_TCD LEFT BY 0 BOTTOM BY 6 RIGHT BY (12-12) TOP BY (12-12)
  150_20_n_rec_1 = SHRINK Normal_TCD LEFT BY 0 BOTTOM BY 0 RIGHT BY (12-12) TOP BY (12-12)
  150_21_n_rec_1 = SHRINK Normal_TCD LEFT BY 0 BOTTOM BY 0 RIGHT BY (12-12) TOP BY (12-12)
  Normal_TCD_150_20 = COPY  150_20_n_rec_1 
  Normal_TCD_150_21 = COPY  150_21_n_rec_1 
  Normal_TCD_17_0 = COPY (OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR 17_0_n_rec_1 17_0_n_rec_2) 17_0_n_rec_3) 17_0_n_rec_4) 17_0_n_rec_5) 17_0_n_rec_6) 17_0_n_rec_7) 17_0_n_rec_8) 17_0_n_rec_9) 17_0_n_rec_10) 17_0_n_rec_11) 17_0_n_rec_12) 17_0_n_rec_13) 17_0_n_rec_14) 17_0_n_rec_15) 17_0_n_rec_16) 17_0_n_rec_17) 17_0_n_rec_18) 17_0_n_rec_19) 17_0_n_rec_20) 17_0_n_rec_21) 17_0_n_rec_22) 17_0_n_rec_23) 17_0_n_rec_24) 17_0_n_rec_25) 17_0_n_rec_26) 17_0_n_rec_27) 17_0_n_rec_28) 17_0_n_rec_29) 17_0_n_rec_30) 17_0_n_rec_31) 17_0_n_rec_32) 17_0_n_rec_33) 17_0_n_rec_34) 17_0_n_rec_35) 17_0_n_rec_36) 17_0_n_rec_37) 17_0_n_rec_38) 17_0_n_rec_39) 17_0_n_rec_40) 17_0_n_rec_41) 17_0_n_rec_42) 17_0_n_rec_43) 17_0_n_rec_44) 17_0_n_rec_45) 17_0_n_rec_46) 17_0_n_rec_47) 17_0_n_rec_48) 17_0_n_rec_49) 17_0_n_rec_50) 17_0_n_rec_51) 17_0_n_rec_52) 17_0_n_rec_53) 17_0_n_rec_54) 
  Normal_TCD_25_0 = COPY  25_0_n_rec_1 
  Normal_TCD_26_0 = COPY (OR 26_0_n_rec_1 26_0_n_rec_2) 
  Normal_TCD_6_0 = COPY (OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR 6_0_n_rec_1 6_0_n_rec_2) 6_0_n_rec_3) 6_0_n_rec_4) 6_0_n_rec_5) 6_0_n_rec_6) 6_0_n_rec_7) 6_0_n_rec_8) 6_0_n_rec_9) 6_0_n_rec_10) 6_0_n_rec_11) 6_0_n_rec_12) 6_0_n_rec_13) 6_0_n_rec_14) 6_0_n_rec_15) 6_0_n_rec_16) 6_0_n_rec_17) 6_0_n_rec_18) 6_0_n_rec_19) 6_0_n_rec_20) 6_0_n_rec_21) 6_0_n_rec_22) 6_0_n_rec_23) 6_0_n_rec_24) 6_0_n_rec_25) 6_0_n_rec_26) 6_0_n_rec_27) 6_0_n_rec_28) 6_0_n_rec_29) 6_0_n_rec_30) 6_0_n_rec_31) 6_0_n_rec_32) 6_0_n_rec_33) 6_0_n_rec_34) 6_0_n_rec_35) 6_0_n_rec_36) 6_0_n_rec_37) 6_0_n_rec_38) 6_0_n_rec_39) 6_0_n_rec_40) 6_0_n_rec_41) 6_0_n_rec_42) 6_0_n_rec_43) 6_0_n_rec_44) 6_0_n_rec_45) 6_0_n_rec_46) 
  Normal_TCD_OD = ODi AND Normal_TCD
  Normal_TCD_PO = POi AND Normal_TCD
  Normal_TCD_PP = PPi AND Normal_TCD
  Normal_TCD_NP = NPi AND Normal_TCD
  Normal_TCD_ODBLK = ODBLK AND Normal_TCD 
  Normal_TCD_POBLK = POBLK AND Normal_TCD
  Normal_TCD_OD XOR Normal_TCD_6_0
  Normal_TCD_PO XOR Normal_TCD_17_0
  Normal_TCD_PP XOR Normal_TCD_25_0
  Normal_TCD_NP XOR Normal_TCD_26_0
  Normal_TCD_ODBLK XOR Normal_TCD_150_20
  Normal_TCD_POBLK XOR Normal_TCD_150_21
  
  6_0_s_rec_1 = SHRINK Small_TCD LEFT BY 6.585 BOTTOM BY 5.035 RIGHT BY (9.245-7.805) TOP BY (9.245-5.475)
  6_0_s_rec_2 = SHRINK Small_TCD LEFT BY 6.585 BOTTOM BY 4.255 RIGHT BY (9.245-7.805) TOP BY (9.245-4.695)
  6_0_s_rec_3 = SHRINK Small_TCD LEFT BY 6.585 BOTTOM BY 3.415 RIGHT BY (9.245-7.805) TOP BY (9.245-3.855)
  6_0_s_rec_4 = SHRINK Small_TCD LEFT BY 6.585 BOTTOM BY 2.635 RIGHT BY (9.245-7.805) TOP BY (9.245-3.075)
  6_0_s_rec_5 = SHRINK Small_TCD LEFT BY 6.585 BOTTOM BY 1.795 RIGHT BY (9.245-7.805) TOP BY (9.245-2.235)
  6_0_s_rec_6 = SHRINK Small_TCD LEFT BY 6.585 BOTTOM BY 1.015 RIGHT BY (9.245-7.805) TOP BY (9.245-1.455)
  6_0_s_rec_7 = SHRINK Small_TCD LEFT BY 0.745 BOTTOM BY 0.745 RIGHT BY (9.245-5.745) TOP BY (9.245-5.745)
  17_0_s_rec_1 = SHRINK Small_TCD LEFT BY 7.165 BOTTOM BY 0.875 RIGHT BY (9.245-7.225) TOP BY (9.245-2.375)
  17_0_s_rec_2 = SHRINK Small_TCD LEFT BY 6.445 BOTTOM BY 1.595 RIGHT BY (9.245-7.945) TOP BY (9.245-1.655)
  17_0_s_rec_3 = SHRINK Small_TCD LEFT BY 6.445 BOTTOM BY 3.215 RIGHT BY (9.245-7.945) TOP BY (9.245-3.275)
  17_0_s_rec_4 = SHRINK Small_TCD LEFT BY 7.165 BOTTOM BY 2.495 RIGHT BY (9.245-7.225) TOP BY (9.245-3.995)
  17_0_s_rec_5 = SHRINK Small_TCD LEFT BY 7.165 BOTTOM BY 4.115 RIGHT BY (9.245-7.225) TOP BY (9.245-5.615)
  17_0_s_rec_6 = SHRINK Small_TCD LEFT BY 6.445 BOTTOM BY 4.835 RIGHT BY (9.245-7.945) TOP BY (9.245-4.895)
  17_0_s_rec_7 = SHRINK Small_TCD LEFT BY 7.945 BOTTOM BY 7.945 RIGHT BY (9.245-8.945) TOP BY (9.245-8.945)
  17_0_s_rec_8 = SHRINK Small_TCD LEFT BY 7.945 BOTTOM BY 6.445 RIGHT BY (9.245-8.945) TOP BY (9.245-7.445)
  17_0_s_rec_9 = SHRINK Small_TCD LEFT BY 6.445 BOTTOM BY 6.445 RIGHT BY (9.245-7.445) TOP BY (9.245-7.445)
  17_0_s_rec_10 = SHRINK Small_TCD LEFT BY 5.895 BOTTOM BY 0.495 RIGHT BY (9.245-6.19) TOP BY (9.245-5.995)
  17_0_s_rec_11 = SHRINK Small_TCD LEFT BY 5.335 BOTTOM BY 0.495 RIGHT BY (9.245-5.395) TOP BY (9.245-5.995)
  17_0_s_rec_12 = SHRINK Small_TCD LEFT BY 5.07 BOTTOM BY 0.495 RIGHT BY (9.245-5.13) TOP BY (9.245-5.995)
  17_0_s_rec_13 = SHRINK Small_TCD LEFT BY 4.805 BOTTOM BY 0.495 RIGHT BY (9.245-4.865) TOP BY (9.245-5.995)
  17_0_s_rec_14 = SHRINK Small_TCD LEFT BY 4.54 BOTTOM BY 0.495 RIGHT BY (9.245-4.6) TOP BY (9.245-5.995)
  17_0_s_rec_15 = SHRINK Small_TCD LEFT BY 4.275 BOTTOM BY 0.495 RIGHT BY (9.245-4.335) TOP BY (9.245-5.995)
  17_0_s_rec_16 = SHRINK Small_TCD LEFT BY 4.01 BOTTOM BY 0.495 RIGHT BY (9.245-4.07) TOP BY (9.245-5.995)
  17_0_s_rec_17 = SHRINK Small_TCD LEFT BY 3.745 BOTTOM BY 0.495 RIGHT BY (9.245-3.805) TOP BY (9.245-5.995)
  17_0_s_rec_18 = SHRINK Small_TCD LEFT BY 3.48 BOTTOM BY 0.495 RIGHT BY (9.245-3.54) TOP BY (9.245-5.995)
  17_0_s_rec_19 = SHRINK Small_TCD LEFT BY 3.215 BOTTOM BY 0.245 RIGHT BY (9.245-3.275) TOP BY (9.245-6.245)
  17_0_s_rec_20 = SHRINK Small_TCD LEFT BY 2.95 BOTTOM BY 0.495 RIGHT BY (9.245-3.01) TOP BY (9.245-5.995)
  17_0_s_rec_21 = SHRINK Small_TCD LEFT BY 2.685 BOTTOM BY 0.495 RIGHT BY (9.245-2.745) TOP BY (9.245-5.995)
  17_0_s_rec_22 = SHRINK Small_TCD LEFT BY 2.42 BOTTOM BY 0.495 RIGHT BY (9.245-2.48) TOP BY (9.245-5.995)
  17_0_s_rec_23 = SHRINK Small_TCD LEFT BY 2.155 BOTTOM BY 0.495 RIGHT BY (9.245-2.215) TOP BY (9.245-5.995)
  17_0_s_rec_24 = SHRINK Small_TCD LEFT BY 1.89 BOTTOM BY 0.495 RIGHT BY (9.245-1.95) TOP BY (9.245-5.995)
  17_0_s_rec_25 = SHRINK Small_TCD LEFT BY 1.625 BOTTOM BY 0.495 RIGHT BY (9.245-1.685) TOP BY (9.245-5.995)
  17_0_s_rec_26 = SHRINK Small_TCD LEFT BY 1.36 BOTTOM BY 0.495 RIGHT BY (9.245-1.42) TOP BY (9.245-5.995)
  17_0_s_rec_27 = SHRINK Small_TCD LEFT BY 1.095 BOTTOM BY 0.495 RIGHT BY (9.245-1.155) TOP BY (9.245-5.995)
  17_0_s_rec_28 = SHRINK Small_TCD LEFT BY 0.3 BOTTOM BY 0.495 RIGHT BY (9.245-0.595) TOP BY (9.245-5.995)
  26_0_s_rec_1 = SHRINK Small_TCD LEFT BY 0 BOTTOM BY 0 RIGHT BY (9.245-9.245) TOP BY (9.245-9.245)
  150_20_s_rec_1 = SHRINK Small_TCD LEFT BY 0 BOTTOM BY 0 RIGHT BY (9.245-9.245) TOP BY (9.245-9.245)
  150_21_s_rec_1 = SHRINK Small_TCD LEFT BY 0 BOTTOM BY 0 RIGHT BY (9.245-9.245) TOP BY (9.245-9.245)
  Small_TCD_150_20 = COPY  150_20_s_rec_1 
  Small_TCD_150_21 = COPY  150_21_s_rec_1 
  Small_TCD_17_0 = COPY (OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR(OR 17_0_s_rec_1 17_0_s_rec_2) 17_0_s_rec_3) 17_0_s_rec_4) 17_0_s_rec_5) 17_0_s_rec_6) 17_0_s_rec_7) 17_0_s_rec_8) 17_0_s_rec_9) 17_0_s_rec_10) 17_0_s_rec_11) 17_0_s_rec_12) 17_0_s_rec_13) 17_0_s_rec_14) 17_0_s_rec_15) 17_0_s_rec_16) 17_0_s_rec_17) 17_0_s_rec_18) 17_0_s_rec_19) 17_0_s_rec_20) 17_0_s_rec_21) 17_0_s_rec_22) 17_0_s_rec_23) 17_0_s_rec_24) 17_0_s_rec_25) 17_0_s_rec_26) 17_0_s_rec_27) 17_0_s_rec_28) 
  Small_TCD_26_0 = COPY  26_0_s_rec_1 
  Small_TCD_6_0 = COPY (OR(OR(OR(OR(OR(OR 6_0_s_rec_1 6_0_s_rec_2) 6_0_s_rec_3) 6_0_s_rec_4) 6_0_s_rec_5) 6_0_s_rec_6) 6_0_s_rec_7) 
  Small_TCD_OD = ODi AND Small_TCD
  Small_TCD_PO = POi AND Small_TCD
  Small_TCD_NP = NPi AND Small_TCD
  Small_TCD_ODBLK = ODBLK AND Small_TCD 
  Small_TCD_POBLK = POBLK AND Small_TCD
  Small_TCD_OD XOR Small_TCD_6_0
  Small_TCD_PO XOR Small_TCD_17_0
  Small_TCD_NP XOR Small_TCD_26_0
  Small_TCD_ODBLK XOR Small_TCD_150_20
  Small_TCD_POBLK XOR Small_TCD_150_21

}    


DTCD.R.3 {@ TCDDMY overlap of DOD, DPO, NW, OD2, DCO, NT_N, POFUSE, RPO, RH, VAR, mVTL, VTH_P, VTH_N, VTL_P, VTL_N, SRM, SRAMDMY, FW, LMARK, INDDMY, LOGO, or MOMDMY is not allowed.
   TCDDMY AND DOD
   TCDDMY AND DPO    
   TCDDMY AND NWi
   TCDDMY AND OD2i
   TCDDMY AND DCOi
   TCDDMY AND NT_Ni
   TCDDMY AND POFUSE
   TCDDMY AND RPOi
   TCDDMY AND RH
   TCDDMY AND VARi
   TCDDMY AND mVTLi
   TCDDMY AND VTH_Pi
   TCDDMY AND VTH_Ni
   TCDDMY AND VTL_Pi
   TCDDMY AND VTL_Ni
   TCDDMY AND SRM
   TCDDMY AND SRAMDMY
   TCDDMY AND FWi
   TCDDMY AND LMARK
   TCDDMY AND INDDMY
   TCDDMY AND LOGO
   TCDDMY AND MOMDMY_ALL
}




//VTH_N CHECKS
//============

VTH_N.W.1 { @ Width >= 0.18 
  (INT VTHNs < VTH_N_W_1 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE 
}
VTH_N.S.1 { @ Space >= 0.18 
  EXT VTHN < VTH_N_S_1 ABUT < 90 REGION 
}
VTH_N.S.2_VTH_N.S.2.1 { @ Space to gate in PO endcap direction >= ^VTH_N_S_2 
@ Space to gate in S/D direction >= ^VTH_N_S_2_1
  A = GATE NOT INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_N_S_2_1 - VTH_N_S_2)) OR A
  C = SIZE B BY VTH_N_S_2
  VTHN AND C
}
VTH_N.S.3 { @ Space to unsilicided OD >= 0.22 
  EXT VTHN AYRE < VTH_N_S_3 ABUT < 90 SINGULAR
  AND VTHN AYRE    
}  
VTH_N.EN.1_VTH_N.EN.2 { @ Enclosure of gate in S/D direction >= ^VTH_N_EN_1  
@ Enclosure of gate in PO endcap direction >= ^VTH_N_EN_2
  A = GATE INTERACT VTHN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_N_EN_1 - VTH_N_EN_2)) OR A
  C = SIZE B BY VTH_N_EN_2
  C NOT VTHN
}
VTH_N.A.1 { @ Area >= 0.27 
  (AREA VTHNs < VTH_N_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTH_N_A_2pre ((VTH_N_A_2 + (VTH_N_S_1 * VTH_N_S_1 * 3.142))/(2 * VTH_N_S_1))*((VTH_N_A_2 + (VTH_N_S_1 * VTH_N_S_1 * 3.142))/(2 * VTH_N_S_1))/3.141

VTH_N.A.2 { @ Enclosed area >= 0.27 
  A = HOLES VTHN INNER < VTH_N_A_2pre
  B = A NOT VTHN
  AREA B < VTH_N_A_2
}

VTH_N.R.1 { @ Overlap of P+ACTIVE, VTL_N, NT_N, or OD2 is not allowed.   
  VTHN AND OD2
  VTHN AND NTN
  VTHN AND PACT
  VTHN AND VTLN
}

VTH_N.R.2 { @ Point touch of corners are allowed.[width >= ^VTH_N_R_2 um]  
   A = EXT VTHN < GRID SINGULAR INTERSECTING ONLY REGION 
   B = (SIZE A BY GRID) AND VTHN 
   C = ( SIZE VTHN BY (VTH_N_R_2 - 0.002)/ 2 UNDEROVER TRUNCATE (VTH_N_R_2 - 0.002)/2 ) AND VTHN
   B NOT C
}


//VTH_P CHECKS
//============

VTH_P.W.1 { @ Width >= 0.18 
  (INT VTHPs < VTH_P_W_1 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE 
}
VTH_P.S.1 { @ Space >= 0.18 
  EXT VTHP < VTH_P_S_1 ABUT < 90 REGION 
}
VTH_P.S.2_VTH_P.S.2.1 { @ Space to gate in PO endcap direction >= ^VTH_P_S_2 
@ Space to gate in S/D direction >= ^VTH_P_S_2_1
  A = GATE NOT INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_P_S_2_1 - VTH_P_S_2)) OR A
  C = SIZE B BY VTH_P_S_2
  VTHP AND C
}
VTH_P.S.3 { @ Space to unsilicided OD >= 0.22 
  EXT VTHP AYRE < VTH_P_S_3 ABUT < 90 SINGULAR
  AND VTHP AYRE    
}  
VTH_P.EN.1_VTH_P.EN.2 { @ Enclosure of gate in S/D direction >= ^VTH_P_EN_1  
@ Enclosure of gate in PO endcap direction >= ^VTH_P_EN_2
  A = GATE INTERACT VTHP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTH_P_EN_1 - VTH_P_EN_2)) OR A
  C = SIZE B BY VTH_P_EN_2
  C NOT VTHP
}
VTH_P.A.1 { @ Area >= 0.27 
  (AREA VTHPs < VTH_P_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTH_P_A_2pre ((VTH_P_A_2 + (VTH_P_S_1 * VTH_P_S_1 * 3.142))/(2 * VTH_P_S_1))*((VTH_P_A_2 + (VTH_P_S_1 * VTH_P_S_1 * 3.142))/(2 * VTH_P_S_1))/3.141

VTH_P.A.2 { @ Enclosed area >= 0.27 
  A = HOLES VTHP INNER < VTH_P_A_2pre
  B = A NOT VTHP
  AREA B < VTH_P_A_2
}

VTH_P.R.1 { @ Overlap of N+ACTIVE (including varactor gate), VTL_P, NT_N, or OD2 is not allowed.   
  VTHP AND OD2
  VTHP AND NTN
  VTHP AND NACT
  VTHP AND VTLP
}

VTH_P.R.2 { @ Point touch of corners are allowed.[width >= ^VTH_P_R_2 um]  
   A = EXT VTHP < GRID SINGULAR INTERSECTING ONLY REGION 
   B = (SIZE A BY GRID) AND VTHP 
   C = ( SIZE VTHP BY (VTH_P_R_2 - 0.002)/ 2 UNDEROVER TRUNCATE (VTH_P_R_2 - 0.002)/2 ) AND VTHP
   B NOT C
}


//VTL_N CHECKS
//============

VTL_N.W.1 { @ Width >= 0.18 
  (INT VTLNs < VTL_N_W_1 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE 
}
VTL_N.S.1 { @ Space >= 0.18 
  EXT VTLN < VTL_N_S_1 ABUT < 90 REGION 
}
VTL_N.S.2_VTL_N.S.2.1 { @ Space to gate in PO endcap direction >= ^VTL_N_S_2 
@ Space to gate in S/D direction >= ^VTL_N_S_2_1
  A = GATE NOT INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_N_S_2_1 - VTL_N_S_2)) OR A
  C = SIZE B BY VTL_N_S_2
  VTLN AND C
}
VTL_N.S.3 { @ Space to unsilicided OD >= 0.22 
  EXT VTLN AYRE < VTL_N_S_3 ABUT < 90 SINGULAR
  AND VTLN AYRE    
}  
VTL_N.EN.1_VTL_N.EN.2 { @ Enclosure of gate in S/D direction >= ^VTL_N_EN_1  
@ Enclosure of gate in PO endcap direction >= ^VTL_N_EN_2
  A = GATE INTERACT VTLN
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_N_EN_1 - VTL_N_EN_2)) OR A
  C = SIZE B BY VTL_N_EN_2
  C NOT VTLN
}
VTL_N.A.1 { @ Area >= 0.27 
  (AREA VTLNs < VTL_N_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTL_N_A_2pre ((VTL_N_A_2 + (VTL_N_S_1 * VTL_N_S_1 * 3.142))/(2 * VTL_N_S_1))*((VTL_N_A_2 + (VTL_N_S_1 * VTL_N_S_1 * 3.142))/(2 * VTL_N_S_1))/3.141

VTL_N.A.2 { @ Enclosed area >= 0.27 
  A = HOLES VTLN INNER < VTL_N_A_2pre
  B = A NOT VTLN
  AREA B < VTL_N_A_2
}

VTL_N.R.1 { @ Overlap of P+ACTIVE, VTH_N, NT_N, or OD2 is not allowed.   
  VTLN AND OD2
  VTLN AND NTN
  VTLN AND PACT
  VTLN AND VTHN
}

VTL_N.R.2 { @ Point touch of corners are allowed.[width >= ^VTL_N_R_2 um]  
   A = EXT VTLN < GRID SINGULAR INTERSECTING ONLY REGION 
   B = (SIZE A BY GRID) AND VTLN 
   C = ( SIZE VTLN BY (VTL_N_R_2 - 0.002)/ 2 UNDEROVER TRUNCATE (VTL_N_R_2 - 0.002)/2 ) AND VTLN
   B NOT C
}


//VTL_P CHECKS
//============

VTL_P.W.1 { @ Width >= 0.18 
  (INT VTLPs < VTL_P_W_1 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE 
}
VTL_P.S.1 { @ Space >= 0.18 
  EXT VTLP < VTL_P_S_1 ABUT < 90 REGION 
}
VTL_P.S.2_VTL_P.S.2.1 { @ Space to gate in PO endcap direction >= ^VTL_P_S_2 
@ Space to gate in S/D direction >= ^VTL_P_S_2_1
  A = GATE NOT INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_P_S_2_1 - VTL_P_S_2)) OR A
  C = SIZE B BY VTL_P_S_2
  VTLP AND C
}
VTL_P.S.3 { @ Space to unsilicided OD >= 0.22 
  EXT VTLP AYRE < VTL_P_S_3 ABUT < 90 SINGULAR
  AND VTLP AYRE    
}  
VTL_P.EN.1_VTL_P.EN.2 { @ Enclosure of gate in S/D direction >= ^VTL_P_EN_1  
@ Enclosure of gate in PO endcap direction >= ^VTL_P_EN_2
  A = GATE INTERACT VTLP
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (VTL_P_EN_1 - VTL_P_EN_2)) OR A
  C = SIZE B BY VTL_P_EN_2
  C NOT VTLP
}
VTL_P.A.1 { @ Area >= 0.27 
  (AREA VTLPs < VTL_P_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTL_P_A_2pre ((VTL_P_A_2 + (VTL_P_S_1 * VTL_P_S_1 * 3.142))/(2 * VTL_P_S_1))*((VTL_P_A_2 + (VTL_P_S_1 * VTL_P_S_1 * 3.142))/(2 * VTL_P_S_1))/3.141

VTL_P.A.2 { @ Enclosed area >= 0.27 
  A = HOLES VTLP INNER < VTL_P_A_2pre
  B = A NOT VTLP
  AREA B < VTL_P_A_2
}

VTL_P.R.1 { @ Overlap of N+ACTIVE (including varactor gate), VTH_P, NT_N, or OD2 is not allowed.   
  VTLP AND OD2
  VTLP AND NTN
  VTLP AND NACT
  VTLP AND VTHP
}

VTL_P.R.2 { @ Point touch of corners are allowed.[width >= ^VTL_P_R_2 um]  
   A = EXT VTLP < GRID SINGULAR INTERSECTING ONLY REGION 
   B = (SIZE A BY GRID) AND VTLP 
   C = ( SIZE VTLP BY (VTL_P_R_2 - 0.002)/ 2 UNDEROVER TRUNCATE (VTL_P_R_2 - 0.002)/2 ) AND VTLP
   B NOT C
}





//mVTL  CHECKS
//============


mVTL.EN.1 { @ Enclosure of gate >= 0.05um
  ENC GATE mVTL < mVTL_EN_1 ABUT < 90 SINGULAR REGION 
  (GATE INTERACT mVTL) NOT mVTL 
}

mVTL.S.1 { @ Space to  gate >= 0.05um
  EXT mVTL GATE < mVTL_S_1 ABUT < 90 SINGULAR REGION 
}

mVTL.R.1 { @ Overlap of VTH_N,VTH_P,VTL_N,VTL_P, NT_N, or OD2 is not allowed. 
  mVTL AND VTHN
  mVTL AND VTHP
  mVTL AND VTLN
  mVTL AND VTLP
  mVTL AND NTN
  mVTL AND OD2
}



//PP CHECKS
//=========


ODIMP = OD COINCIDENT INSIDE EDGE IMP
PP_BEDGE = PP INSIDE EDGE OD   


PP.W.1 { @ Width >= 0.18 
  (INT PP < PP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
PP.S.1 { @ Space >= 0.18 
  (EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
PP.S.2 { @ Space to N+ACTIVE (non-butted) >= 0.13 
  EXT PP NACT < PP_S_2 ABUT < 90 > 0 SINGULAR REGION
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}

// PP.S.3 is checked by PP.S.2 and PP.R.2

PP.S.4 { @ Space to NW STRAP (non-butted) >= 0.02 
  EXT PP NSTP < PP_S_4 ABUT < 90 > 0 SINGULAR REGION
  X = EXT PP [NSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
PP.S.5 { @ {PP edge on OD} space to NMOS GATE >= 0.32 
  EXT GATEN_W PP_BEDGE < PP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEN = EXPAND EDGE GATEN_W OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J

PP.S.6 { @ Butted PW STRAP space to PO in the same OD [the butted N+ACTIVE extending 0 < J1 < 0.16 mm] >= 0.32 
  A = EX_GATEN AND BUTT_PSTP
  B = EX_GATEN AND NACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEN_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J
  C AND F
}
PP.S.7 { @ Space to N-type unsilicided OD/PO >= 0.20 
  EXT PP NYRE < PP_S_7 ABUT < 90 SINGULAR REGION
}
PP.EN.1 { @ {NP OR PP} enclosure of PO (except DPO) >= 0.15 
  ENC POLY IMP < PP_EN_1 ABUT < 90 SINGULAR REGION
  ((POLY NOT SRAM_EXCLUDE) NOT LOGO) NOT IMP
}
PP.EX.1 { @ Extension on P+ACTIVE >= 0.13 
  ENC PACT PP < PP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PACT] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND PACT
}
PP.EX.2 { @ Extension on PW STRAP >= 0.02 
  PSTP_CHECK = PSTP NOT SRCSR 
  ENC PSTP_CHECK PP < PP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PSTP_CHECK] PP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND PSTP_CHECK  
}
PP.EX.3 { @ Extension on P-type unsilicided OD/PO >= 0.20 
  ENC AYRE PP < PP_EX_3 ABUT < 90 SINGULAR
}
PP.EX.4 { @ {PP edge on OD} extension on PMOS GATE >= 0.32 
  ENC GATEP_W PP_BEDGE < PP_EX_4 ABUT < 90 OPPOSITE REGION
}
PP.O.1 { @ Overlap of OD >= 0.13 
  INT OD PP < PP_O_1 ABUT < 90 > 0 SINGULAR REGION
}
PP.A.1 { @ Area >= ^PP_A_1 um2
  AREA PP < PP_A_1
}

VARIABLE PP_A_2pre ((PP_A_2 + (PP_S_1 * PP_S_1 * 3.142))/(2 * PP_S_1))*((PP_A_2 + (PP_S_1 * PP_S_1 * 3.142))/(2 * PP_S_1))/3.141

PP.A.2 { @ Enclosed area >= ^PP_A_2 um2
  A = HOLES PP INNER < PP_A_2pre
  B = A NOT PP
  (AREA B < PP_A_2) NOT INSIDE SRAM_EXCLUDE
}
PP.A.3 { @ Area of butted PW STRAP >= 0.04 
  AREA BUTT_PSTP < PP_A_3
}  

PP.R.1 { @ PP must fully cover {PMOS GATE SIZING 0.16 mm} >= 0.16 
   EXGATE_PP = SIZE GATE_PP BY PP_R_1
   EXGATE_PP NOT PP
}
PP.R.2 { @ Overlap of NP is not allowed   
  PP AND NP
}

// PP.R.3 is checked by OD.R.1
// PP.R.4 is checked by PP.EN.1



//NP CHECKS
//=========

NP_BEDGE = NP INSIDE EDGE OD   

NP.W.1 { @ Width >= 0.18 
  (INT NP < NP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NP.S.1 { @ Space >= 0.18 
  (EXT NP < NP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NP.S.2 { @ Space to P+ACTIVE (non-butted) >= 0.13 
  EXT NP PACT < NP_S_2 ABUT < 90 > 0 SINGULAR REGION
  X = EXT NP [PACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}

// NP.S.3 is checked by NP.S.2 and PP.R.2

NP.S.4 { @ Space to PW STRAP (non-butted) >= 0.02 
  EXT NP PSTP < NP_S_4 ABUT < 90 > 0 SINGULAR REGION
  X = EXT NP [PSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
NP.S.5 { @ {NP edge on OD} space to PMOS GATE >= 0.32 
  EXT GATEP_W NP_BEDGE < NP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEP = EXPAND EDGE GATEP_W OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J

NP.S.6 { @ Butted NW STRAP space to PO in the same OD [the butted P+ACTIVE extending 0 < J1 < 0.16 um] >= 0.32 
  A = EX_GATEP AND BUTT_NSTP
  B = EX_GATEP AND PACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEP_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J
  C AND F
}
NP.S.7 { @ Space to P-type unsilicided OD/PO >= 0.20 
  EXT NP PYRE < NP_S_7 ABUT < 90 SINGULAR REGION
}

// NP.EN.1 is checked by PP.EN.1

NP.EX.1 { @ Extension on N+ACTIVE >= 0.13 
  A = NACT NOT ODWR
  ENC A NP < NP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [A] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND NACT
}
NP.EX.2 { @ Extension on NW STRAP >= 0.02 
  ENC NSTP NP < NP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [NSTP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP INSIDE BY 0.001) AND NSTP
}
NP.EX.3 { @ Extension on N-type unsilicided OD/PO >= 0.20 
  ENC AYRE NP < NP_EX_3 ABUT < 90 SINGULAR REGION
}
NP.EX.4 { @ {NP edge on OD} extension on NMOS GATE >= 0.32 
  ENC GATEN_W NP_BEDGE < NP_EX_4 ABUT < 90 OPPOSITE REGION
}
NP.O.1 { @ Overlap of OD >= 0.13 
  INT OD NP < NP_O_1  ABUT < 90 > 0 SINGULAR REGION
}
NP.A.1 { @ Area >= ^NP_A_1 um2
  AREA NP < NP_A_1
}
VARIABLE NP_A_2pre ((NP_A_2 + (NP_S_1 * NP_S_1 * 3.142))/(2 * NP_S_1))*((NP_A_2 + (NP_S_1 * NP_S_1 * 3.142))/(2 * NP_S_1))/3.141
NP.A.2 { @ Enclosed area >= ^NP_A_2 um2
  A = HOLES NP INNER < NP_A_2pre 
  B = A NOT NP
  (AREA B < NP_A_2) NOT INSIDE SRAM_EXCLUDE
}
NP.A.3 { @ Area of butted NW STRAP >= 0.04 
  AREA BUTT_NSTP < NP_A_3
}  

NP.R.1 { @ NP must fully cover {NMOS GATE SIZING 0.16 um} >= 0.16 
   EXGATE_NP = SIZE GATE_NP BY NP_R_1
   EXGATE_NP NOT NP
}

// NP.R.2 is checked by PP.R.2
// NP.R.3 is checked by OD.R.1
// NP.R.4 is checked by PP.EN.1



//LOGICAL OPERATION RULE
//======================

VARIABLE  NLDDN1V_SU  0.085
VARIABLE  NLDDN1V_SD  0.17
VARIABLE  NLDDN2V_SU  0.085
VARIABLE  NLDDN2V_SD  0.17
VARIABLE  VTLN_SU     0.085
VARIABLE  VTLN_SD     0.17
VARIABLE  PLDDP1V_SU  0.085
VARIABLE  PLDDP1V_SD  0.17
VARIABLE  PLDDP2V_SU  0.085
VARIABLE  PLDDP2V_SD  0.17
VARIABLE  VTLP_SU     0.085
VARIABLE  VTLP_SD     0.17

VTLND = COPY VTLN 
VTLPD = COPY VTLP 


NP_NOT_NW = NP NOT NWEL
NLDDN1 = (((NP_NOT_NW NOT OD2) NOT RH) NOT BJTDMY) NOT VAR

NLDDN_CORE1 = NLDDN1 NOT DCO
NLDDN_CORE2 = NLDDN1 AND DCO
NLDDN1V_CORE1 = SIZE (SIZE (SIZE NLDDN_CORE1 BY NLDDN1V_SU) BY -NLDDN1V_SD) BY NLDDN1V_SU
NLDDN1V_CORE2 = SIZE (SIZE (SIZE NLDDN_CORE2 BY NLDDN1V_SU) BY -NLDDN1V_SD) BY NLDDN1V_SU

NLDDN2 = ((((NP_NOT_NW AND OD2) NOT RH) NOT BJTDMY) NOT VAR) NOT DCO
NLDDN2V = SIZE (SIZE (SIZE NLDDN2 BY NLDDN2V_SU) BY -NLDDN2V_SD) BY NLDDN2V_SU

VTL_N_LD = SIZE (SIZE (SIZE (((OD2 OR DCO) OR NWEL) OR VTLND) BY VTLN_SU) BY -VTLN_SD) BY VTLN_SU

PP_AND_NW = PP AND NWEL
PLDDP1 = (((PP_AND_NW NOT OD2) NOT RH) NOT BJTDMY) NOT VAR

PLDDP_CORE1 = PLDDP1 NOT DCO
PLDDP_CORE2 = PLDDP1 AND DCO
PLDDP1V_CORE1 = SIZE (SIZE (SIZE PLDDP_CORE1 BY PLDDP1V_SU) BY -PLDDP1V_SD) BY PLDDP1V_SU
PLDDP1V_CORE2 = SIZE (SIZE (SIZE PLDDP_CORE2 BY PLDDP1V_SU) BY -PLDDP1V_SD) BY PLDDP1V_SU

PLDDP2 = ((((PP_AND_NW AND OD2) NOT RH) NOT BJTDMY) NOT VAR ) NOT DCO
PLDDP2V = SIZE (SIZE (SIZE PLDDP2 BY PLDDP2V_SU) BY -PLDDP2V_SD) BY PLDDP2V_SU

VTL_P_LD = SIZE (SIZE (SIZE (((NWEL NOT OD2) NOT VTLPD) NOT DCO) BY VTLP_SU) BY -VTLP_SD) BY VTLP_SU

LDN.EX.1 { @ NP extension on NW  >= ^LDN_EX_1 
@ LDN.EX.2  NP extension on {OD2 OR DCO} >= ^LDN_EX_1 
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_EX_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_EX_1
  A = INT NLDDN1V_CORE1 < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V_CORE1 < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  C = SIZE DCO BY 0.005
  D = INT C <= 0.015 REGION
  E = (INT NLDDN1V_CORE1 < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  E NOT INTERACT D 
  (INT NLDDN1V_CORE1 < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  F = (EXT NLDDN1V_CORE1 < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  F NOT INTERACT D 
  (EXT NLDDN1V_CORE1 < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

LDN.EX.1.DCO { @ NP extension on NW  >= ^LDN_EX_1 
@ LDN.EX.2  NP extension on OD2 >= ^LDN_EX_1 
@ LDN.O.1   NP overlap of DCO   >= ^LDN_EX_1      
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_EX_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_EX_1
  A = INT NLDDN1V_CORE2 < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V_CORE2 < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  C = SIZE DCO BY 0.005
  D = INT C <= 0.015 REGION
  E = (INT NLDDN1V_CORE2 < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  E NOT INTERACT D 
  (INT NLDDN1V_CORE2 < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  F = (EXT NLDDN1V_CORE2 < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  F NOT INTERACT D 
  (EXT NLDDN1V_CORE2 < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}


LDN.O.1 { @ NP overlap of OD2  >= ^LDN_O_1. 
@ LDN.EX.1  NP extension on NW  >= ^LDN_O_1 
@ LDN.EX.3  NP extension on {RH OR BJTDMY} >= ^LDN_O_1
@ LDN.EX.4  NP extension on VAR >= ^LDN_O_1
  A = INT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDN.EX.1 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.2 is checked by LDN.EX.1 
// LDN.EX.3 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.4 is checked by LDN.EX.1 and LDN.O.1
// LDN.O.1  is checked by LDN.EX.1 and LDN.O.1 

LDP.EX.1 { @ PP extension on {OD2 OR DCO} >= ^LDP_EX_1
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_EX_1 
@ LDP.EX.3  PP extension on VAR  >= ^LDP_EX_1
@ LDP.O.1  PP overlap of NW  >= ^LDP_EX_1
  A = INT PLDDP1V_CORE1 < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V_CORE1 < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  C = SIZE DCO BY 0.005
  D = INT C <= 0.015 REGION
  E = (INT PLDDP1V_CORE1 < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  E NOT INTERACT D 
  (INT PLDDP1V_CORE1 < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  F = (EXT PLDDP1V_CORE1 < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  F NOT INTERACT D 
  (EXT PLDDP1V_CORE1 < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

LDP.EX.1.DCO { @ PP extension on OD2 >= ^LDP_EX_1
@ LDP.O.2  PP overlap of DCO >= ^LDP_EX_1  
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_EX_1 
@ LDP.EX.3  PP extension on VAR >= ^LDP_EX_1
@ LDP.O.1  PP overlap of NW >= ^LDP_EX_1
  A = INT PLDDP1V_CORE2 < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V_CORE2 < LDP_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  C = SIZE DCO BY 0.005
  D = INT C <= 0.015 REGION
  E = (INT PLDDP1V_CORE2 < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  E NOT INTERACT D 
  (INT PLDDP1V_CORE2 < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  F = (EXT PLDDP1V_CORE2 < LDP_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  F NOT INTERACT D 
  (EXT PLDDP1V_CORE2 < LDP_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

LDP.O.2 { @ PP overlap of OD2 >= ^LDP_O_2  
@ LDP.EX.2  PP extension on {RH OR BJTDMY} >= ^LDP_O_2 
@ LDP.EX.3  PP extension on VAR >= ^LDP_O_2
@ LDP.O.1  PP overlap of NW >= ^LDP_O_2
  A = INT PLDDP2V < LDP_O_2 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP2V < LDP_O_2 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.1 LDP_O_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.1 LDP_O_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP2V < LDP_O_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP2V < LDP_O_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDP.EX.2 is checked by LDP.EX.1 and LDP.O.2
// LDP.EX.3 is checked by LDP.EX.1 and LDP.O.2
// LDP.O.1  is checked by LDP.EX.1 and LDP.O.2
// LDP.O.2  is checked by LDP.EX.1 and LDP.O.2


VT.S.1 { @ VTL_N space to {OD2 OR NW OR DCO} >= ^VT_S_1 
  A = INT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
  B = EXT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.1 VT_S_1 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.1 VT_S_1 ORTHOGONAL ONLY
  INT VTL_N_LD < VT_S_1 ABUT < 90 CORNER  
  INT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0
  EXT VTL_N_LD < VT_S_1 ABUT < 90 CORNER  
  EXT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0
  C = SIZE VTLN BY GRID
  D = C AND OD2
  AREA D < 0.0005
  E = C AND NWEL
  AREA E < 0.0005  
  F = C AND DCO
  AREA F < 0.0005  

}

VT.EX.2 { @ NW extension on {OD2 OR VTL_P OR DCO} >= ^VT_EX_2
  A = INT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
  B = EXT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
  NOT ENCLOSE RECTANGLE A 0.1 VT_EX_2 ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE B 0.1 VT_EX_2 ORTHOGONAL ONLY
  INT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER  
  INT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0
  EXT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER  
  EXT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0
  C = SIZE VTLP BY GRID
  D = C NOT NWEL
  AREA D < 0.0005
  E = C AND OD2
  AREA E < 0.0005 
  F = C AND DCO
  AREA F < 0.0005  
 
}




#IFDEF LPG

//DCO CHECKS
//==========


DCO_EDGE_45 = ANGLE DCOs == 45

DCO.W.1 { @ Width >= 0.4 
   (INT DCOs < DCO_W_1 ABUT < 90 OPPOSITE REGION) NOT INSIDE SRAM_EXCLUDE
   (INT DCOs < DCO_W_1 ABUT < 90 CORNER REGION) NOT INSIDE SRAM_EXCLUDE // allow point-touch
   (INT DCOs < DCO_R_5 ABUT < 90  PROJ==0 REGION) NOT INSIDE SRAM_EXCLUDE
   A = EXT [DCOs] < 0.001 ABUT == 90 INTERSECTING ONLY
   (INT A > DCO_R_5+0.002 < DCO_W_1 ABUT < 90 PROJ==0 REGION) NOT INSIDE SRAM_EXCLUDE
   (INT DCO_EDGE_45 DCOs < DCO_W_1 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE
}
DCO.S.1 { @ Space >= 0.4 
    EXT DCO < DCO_S_1 ABUT < 90 OPPOSITE REGION
    EXT DCO < DCO_S_1 ABUT < 90 CORNER REGION // allow point-touch
    EXT DCO < DCO_R_5 ABUT < 90 PROJ==0 REGION
    A = INT [DCO] < 0.001 ABUT == 90 INTERSECTING ONLY
    EXT A > DCO_R_5+0.002 < DCO_S_1 ABUT < 90 PROJ==0 REGION
    (EXT DCO_EDGE_45 DCOs < DCO_S_1 ABUT < 90 REGION) NOT INSIDE SRAM_EXCLUDE
}


DCO.S.2 { @ Space to ACTIVE >= 0.055 
  EXT DCO DACT < DCO_S_2 ABUT < 90 SINGULAR REGION
}
DCO.S.3_DCO.S.4 { @ Space to LP(core 1.2V) gate in S/D direction >= ^DCO_S_3 
  @ Space to LP(core 1.2V) gate in end-cap direction >= ^DCO_S_4             
  A = GATE NOT INTERACT DCO
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_S_3 - DCO_S_4 )) OR A
  C = SIZE B BY DCO_S_4
  DCO AND C
}
DCO.S.5 { @ Space to NW. Space = 0 is allowed. >= 0.18 
  EXT DCO NWEL < DCO_S_5 ABUT < 90 > 0 SINGULAR REGION
}
DCO.S.6 { @ Space to OD2. Space = 0 is allowed. >= 0.4 
  EXT DCO OD2 < DCO_S_6 ABUT < 90 > 0 SINGULAR REGION
}



DCO.EN.1_DCO.EN.2 { @ Enclosure of G(core 1.0V) gate in S/D direction >= ^DCO_EN_1 
  @ Enclosure of G(core 1.0V) gate in end-cap direction >= ^DCO_EN_2  
  A = GATE INTERACT DCO
  X = A INSIDE EDGE OD
  B = (EXPAND EDGE X OUTSIDE BY (DCO_EN_1 - DCO_EN_2 )) OR A
  C = SIZE B BY DCO_EN_2
  C NOT DCO
}
DCO.EX.1 { @ NW extension on DCO. Extension = 0 is allowed. >= 0.18 
  ENC DCO NWEL < DCO_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
DCO.EX.2 { @ Extension on NW. Extension = 0 is allowed. >= 0.18 
  ENC NWEL DCO < DCO_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
DCO.EX.3 { @ Extension on ACTIVE [without Gate] >= 0.055 
  ENC DACT DCO < DCO_EX_3 ABUT < 90 SINGULAR REGION
  (DACT NOT INTERACT GATE) CUT DCO
}
DCO.A.1 { @ Area >= 1.2 
   (AREA DCOs < DCO_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE DCO_A_2pre ((DCO_A_2 + (DCO_S_1 * DCO_S_1 * 3.142))/(2 * DCO_S_1))*((DCO_A_2 + (DCO_S_1 * DCO_S_1 * 3.142))/(2 * DCO_S_1))/3.141
DCO.A.2 { @ Enclosed area >= 1.2 
  A = HOLES DCO INNER < DCO_A_2pre
  B = A NOT DCO
  AREA B < DCO_A_2
}

DCO.O.1 { @ Overlap of NW. Overlap = 0 is allowed. >= 0.18 
  X = DCOs AND NWEL
 (INT X < DCO_O_1 ABUT < 89.5 REGION) NOT INSIDE SRAM_EXCLUDE
}

//DCO.R.1 can't be not check.

DCO.R.2 { @ Overlap of OD2 is no allowed.
  DCO AND OD2
}

DCO.R.3 { @ RH cut DCO is no allowed.
  RH CUT DCO
}

//DCO.R.4 and DCO.R.5 are checked by DCO.W.1/DCO.S.1
#ENDIF


//RPO CHECKS
//==========

NOGT       = GATE NOT SDI
FPO1A      = (FPO1 NOT ESD1DMY) NOT ESD2DMY
Wide_RPO   = RPO INTERACT (SIZE RPO BY - RPO_EX_1_1_W /2)

RPO.W.1 { @ Width >= 0.43 
  INT RPO < RPO_W_1 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Space >= 0.43 
  EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}
RPO.S.2 { @ Space to OD >= 0.22 
  EXT RPO OD < RPO_S_2 ABUT < 90 SINGULAR REGION
}
RPO.S.3 { @ Space to CO (overlap of CO is not allowed.) >= 0.22 
  EXT RPO CO < RPO_S_3 ABUT < 90 SINGULAR REGION
  RPO AND CO
}
RPO.S.4 { @ Space to GATE (overlap of GATE is not allowed except ESD circuit.) >= 0.38 
  EXT RPO NOGT < RPO_S_4 ABUT < 90 SINGULAR REGION
  RPO AND NOGT
}
RPO.S.5 { @ Space to PO >= 0.30 
  EXT RPO FPO1 < RPO_S_5 ABUT < 90 SINGULAR REGION
}
RPO.EX.1 { @ Extension on unsilicided OD/PO >= 0.22 
  ENC OD RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  RPO INSIDE OD
  RPO INSIDE FPO1A  
}

RPO.EX.2 { @ OD extension on RPO >= 0.22 
  ENC RPO OD < RPO_EX_2 ABUT < 90 SINGULAR REGION
}

RPO.EX.1.1 { @ Extension on unsilicided OD/PO [RPO width >10 um] >= 0.30 
  ENC OD Wide_RPO < RPO_EX_1_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A Wide_RPO < RPO_EX_1_1 ABUT < 90 SINGULAR REGION
}


RPO.A.1 { @ Area >= 1.00 
  (AREA RPOs < RPO_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE RPO_A_2pre ((RPO_A_2 + (RPO_S_1 * RPO_S_1 * 3.142))/(2 * RPO_S_1))*((RPO_A_2 + (RPO_S_1 * RPO_S_1 * 3.142))/(2 * RPO_S_1))/3.141
RPO.A.2 { @ Enclosed area >= 1.00 
  A = HOLES RPO INNER < RPO_A_2pre 
  B = A NOT RPO
  AREA B < RPO_A_2
}  
RPO.R.1 { @ Butted NP/PP on unsilicided OD/PO is not allowed.   
  X = (RPO AND POLY) OR (RPO AND OD)
  NX = X AND NP
  PX = X AND PP    
  Y  = NX INTERACT PX
  X INTERACT Y
}  

#IFDEF GUIDELINE_RES

RES.12g {@ {RPO AND PO} must be fully covered by RH except for BJT or ESD circuits
   PORESg NOT RH 
}

RES.13g {@ {RPO AND OD} must be fully covered by RH except for BJT or ESD circuits
   ODRES NOT RH 
}


#ENDIF


RES.8 { @ RH space to GATE (overlap is not allowed) >= ^RES_8 um
  EXT RH GATE < RES_8 ABUT < 90 SINGULAR REGION
  RH AND GATE
}
RES.10 { @ RPO intersecting (PO AND RH) must form two more POs (except BJT or ESD circuit)
   PORES_NOT_SDI_BJT = ( PORESg OUTSIDE BJTDMY ) OUTSIDE INDDMY
   X = PORES_NOT_SDI_BJT AND RH
   A = POLY NOT X
   X INTERACT A < 2
   X NOT INTERACT A
}
RES.11 { @ RPO intersecting (OD AND RH) must form two more ODs (except BJT or ESD circuit)
   ODRES_NOT_SDI_BJT = ODRES NOT SDI
   X = ODRES_NOT_SDI_BJT AND RH	
   A = OD NOT X
   X INTERACT A < 2 
   X NOT INTERACT A
}




//VAR CHECKS
//==========

VAR_GATE = GATE NOT OUTSIDE VAR
VAR_RF_GATE = VAR_GATE INSIDE RFDMY
VAR_BASE_GATE = VAR_GATE NOT INSIDE RFDMY
VAR_RF_GATE_W = GATE_W TOUCH INSIDE EDGE VAR_RF_GATE
VAR_RF_HV_GATE_W = VAR_RF_GATE_W INSIDE EDGE OD2
VAR_RF_LV_GATE_W = VAR_RF_GATE_W NOT INSIDE EDGE OD2
VAR_RF_GATE_L = GATE_L TOUCH INSIDE EDGE VAR_RF_GATE


VAR.W.1 { @ Length of {gate AND VAR} for baseband circuit >= ^VAR_W_1 um
  INT VAR_BASE_GATE < VAR_W_1 ABUT < 90 SINGULAR REGION
}


VAR.W.4 { @ Channel width of { gate AND VAR } for RF circuit >= ^VAR_W_4 um
  LENGTH VAR_RF_GATE_W < VAR_W_4 
}


VAR.S.1 { @ Space to Active >= 0.13
  EXT VAR DACT < VAR_S_1 ABUT < 90 SINGULAR REGION
}

VAR.EN.1 { @ Enclosure of OD >= 0.16
  ENC OD VAR < VAR_EN_1 ABUT < 90 SINGULAR REGION
  OD CUT VAR
}

VAR.R.1 { @ VAR layer must be drawn to fully cover the varactor devices.
  VAR_GATE NOT VAR
}

VAR.R.2 { @ Overlap of VTL_N, VTL_P, VTH_N, VTH_P, mVTL, NT_N, PW, or RPO is not allowed.
  VAR AND VTLN
  VAR AND VTLP
  VAR AND VTHN
  VAR AND VTHP
  VAR AND NTN
  VAR AND mVTL
  VAR NOT NWEL
  VAR AND RPO
}

VAR.R.3 { @ PP overlap of {gate AND VAR} is not allowed.
  VAR_GATE AND PP
}

VAR.R.4 { @ Overlap of {gate SIZING 0.16 um} is not allowed.
  VAR_E = SIZE VAR BY VAR_W_1 	// For filtering only
  VAR_EXG = (GATE INTERACT VAR_E) OUTSIDE VAR
  VAR_EXGS = SIZE VAR_EXG BY VAR_R_4
  VAR AND VAR_EXGS
}

VAR.R.5 { @ NP must fully cover ((((VAR AND GATE) SIZING 0.19) AND OD) SIZING 0.13)
  A = SIZE (VAR AND GATE) BY VAR_R_5_1
  B = SIZE (A AND OD) BY VAR_R_5_2
  B NOT NP
}  



#IFNDEF HALF_NODE
#IFDEF LP
//HVD_N CHECKS
//============

HVD_Nx = COPY HVD_N_nw
HVD_NMOS_DRAIN = SD INTERACT HVD_Nx
HVD_NGATE = HV_GATE INTERACT HVD_Nx

HVD_N.W.1 { @ Width >= ^HVD_N_W_1 um
   INT HVD_Nx < HVD_N_W_1 ABUT < 90 SINGULAR REGION
}

HVD_N.W.2 { @ Channel width of {GATE interact HVD_N} >= ^HVD_N_W_2 um
   HV_GATE_L = GATE_L INSIDE EDGE OD2
   A = HV_GATE_L COIN INSIDE EDGE HVD_NGATE 
   INT A < HVD_N_W_2 ABUT < 90 REGION
}

HVD_N.S.1 { @ Space >= ^HVD_N_S_1 um 
   EXT HVD_Nx < HVD_N_S_1 ABUT < 90 SINGULAR REGION
}

HVD_N.S.2 { @ Space of two HVD_N with different optentials >= ^HVD_N_S_2 um
   A = STAMP HVD_Nx BY NSDc
   EXT A < HVD_N_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
   B = HVD_Nx NOT INTERACT NSDc
   EXT B HVD_Nx < HVD_N_S_2 ABUT < 90 SINGULAR REGION SPACE
}

HVD_N.S.3 { @ Space to NW >= ^HVD_N_S_3 um
   EXT HVD_Nx NWEL < HVD_N_S_3 ABUT < 90 SINGULAR REGION
}

HVD_N.S.4 { @ Space tp PW STRAP (overlap is not allowed) >= ^HVD_N_S_4 um
   EXT HVD_Nx PSTP < HVD_N_S_4 ABUT < 90 SINGULAR REGION
   HVD_Nx AND PSTP
}

HVD_N.S.5 { @ Space to N+ACTIVE >= ^HVD_N_S_5 um
   EXT HVD_Nx NACT < HVD_N_S_5 ABUT < 90 SINGULAR REGION
}

HVD_N.S.6 { @ Space to DNW >= ^HVD_N_S_6 um
   EXT HVD_Nx DNW < HVD_N_S_6 ABUT < 90 SINGULAR REGION
   HVD_Nx AND DNW
}

HVD_N.EX.1 { @ Extension on N+ACTIVE (Drain side must be fully inside HVD_N) >= ^HVD_N_EX_1 um
   ENC NACT HVD_Nx < HVD_N_EX_1 ABUT < 90 SINGULAR REGION
   HVD_NMOS_DRAIN NOT HVD_Nx
}

HVD_N.O.1 { @ Overlap of {I/O NMOS GATE} >= ^HVD_N_O_1 um
    A = HV_GATE_W COIN OUTSIDE EDGE HVD_NMOS_DRAIN
    B = EXPAND EDGE A INSIDE BY HVD_N_O_1
    C = HVD_Nx AND HVD_NGATE
    C XOR B 
    HVD_NGATE INTERACT B > 1
}

HVD_N.L.1 { @ Channel length of {GATE interact with HVD_N} >= ^HVD_N_L_1 um
   A = HV_GATE_W COIN INSIDE EDGE HVD_NGATE 
   INT A < HVD_N_L_1 ABUT < 90 REGION
}

HVD_N.A.1 { @ Area >= ^HVD_N_A_1 um
   AREA HVD_Nx < HVD_N_A_1
}
 
HVD_N.A.2 { @ Enclosed area >= ^HVD_N_A_2 um
   A = HOLES HVD_Nx INNER
   B = A NOT HVD_Nx
   AREA B < HVD_N_A_2
}

HVD_N.R.1 { @ Overlap of NW is not allowed
   HVD_Nx AND NWEL 
}

HVD_N.R.2 { @ HVD_N edge landing on OD without landing on GATE is not allowed
   A = HVD_Nx INSIDE EDGE OD
   AX= EXPAND EDGE A OUTSIDE BY 0.005
   B=  HVD_Nx INSIDE EDGE GATE
   BX= EXPAND EDGE B OUTSIDE BY 0.005
   AX NOT BX
}

HVD_N.R.3 { @ HVD_N must be fully covered by OD_25
   HVD_Nx NOT OD_25 
}

HVD_N.R.4 { @ {(OD NOT PO) inside one HVD_N} must be the same potential
   HVD_Nx INTERACT NSDc > 1 BY NET 
}

HVD_N.R.6 { @ {(HVD_N interact OD) AND PO} must be a rectangle,
            @ a concave shape is not allowed
  NOT RECTANGLE ((HVD_Nx INTERACT OD) AND POLY)
}

#ELSE
HVD_N.WARN { @ 5V HV MOS is allowed only in N65LP process
  COPY HVD_N_nw
}
#ENDIF
#ELSE
HVD_N.WARN { @ 5V HV MOS is allowed only in N65LP process
  COPY HVD_N_nw
}
#ENDIF



#IFNDEF HALF_NODE
#IFDEF LP
//HVD_P CHECKS
//============

HVD_PMOS_DRAIN = SD INTERACT HVD_P
HVD_PGATE = HV_GATE INTERACT HVD_P

HVD_P.W.1 { @ Width >= ^HVD_P_W_1 um 
   INT HVD_P < HVD_P_W_1 ABUT < 90 SINGULAR REGION
}

HVD_P.W.2 { @ Channel width of {GATE interact HVD_P} >= ^HVD_P_W_2 um
   HV_GATE_L = GATE_L INSIDE EDGE OD2
   A = HV_GATE_L COIN INSIDE EDGE HVD_PGATE 
   INT A < HVD_P_W_2 ABUT < 90 REGION
}

HVD_P.S.1 { @ Space >= ^HVD_P_S_1 um
   EXT HVD_P < HVD_P_S_1 ABUT < 90 SINGULAR REGION
}

HVD_P.S.2 { @ Space of two HVD_P with different potenetials >= ^HVD_P_S_2 um
   A = STAMP HVD_P BY PSDc 
   EXT A < HVD_P_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION
   B = HVD_P NOT INTERACT PSDc
   EXT B HVD_P < HVD_P_S_2 ABUT < 90 SINGULAR REGION SPACE
}

HVD_P.S.4 { @ Space to NW STRAP >= ^HVD_P_S_4 um 
   EXT HVD_P NSTP < HVD_P_S_4 ABUT < 90 SINGULAR REGION
   HVD_P AND NSTP
}

HVD_P.S.5 { @ Space to P+ACTIVE >= ^HVD_P_S_5 um 
   EXT HVD_P PACT < HVD_P_S_5 ABUT < 90 SINGULAR REGION
}


HVD_P.EX.1 { @ Extension on P+ACTIVE (Drain side must be fully inside HVD_P) >= ^HVD_P_EX_1 um
   ENC PACT HVD_P < HVD_P_EX_1 ABUT < 90 SINGULAR REGION
   HVD_PMOS_DRAIN NOT HVD_P
}

HVD_P.EN.1 { @ Enclosure by NW >= ^HVD_P_EN_1 um
   ENC HVD_P NWEL < HVD_P_EN_1 ABUT < 90 SINGULAR REGION
}


HVD_P.O.1 { @ Overlap of {I/O PMOS GATE} >= ^HVD_P_O_1 um
   A = HV_GATE_W COIN OUTSIDE EDGE HVD_PMOS_DRAIN
   B = EXPAND EDGE A INSIDE BY HVD_P_O_1
   C = HVD_P AND HVD_PGATE
   C XOR B 
   HVD_PGATE INTERACT B > 1
}

HVD_P.L.1 { @ Channel length of {GATE interact with HVD_P} >= ^HVD_P_L_1 um
   A = HV_GATE_W COIN INSIDE EDGE HVD_PGATE 
   INT A < HVD_P_L_1 ABUT < 90 REGION
}

HVD_P.A.1 { @ Area >= ^HVD_P_A_1 um
   AREA HVD_P < HVD_P_A_1
}

HVD_P.A.2 { @ Enclosured area >= ^HVD_P_A_2 um
   A = HOLES HVD_P INNER
   B = A NOT HVD_P
   AREA B < HVD_P_A_2
}

HVD_P.R.1 { @ HVD_P must be inside {NW not interact with DNW}    
    HVD_P NOT NWEL 
      
}

HVD_P.R.2 { @ HVD_P edge landing on OD without landing on GATE is not allowed
   A = HVD_P INSIDE EDGE OD
   AX= EXPAND EDGE A OUTSIDE BY 0.005
   B=  HVD_P INSIDE EDGE GATE
   BX= EXPAND EDGE B OUTSIDE BY 0.005
   AX NOT BX
}

HVD_P.R.3 { @ HVD_P must be fully inside OD_25
   HVD_P NOT OD_25 
}


HVD_P.R.4 { @ {(OD NOT PO) inside same HVD_P} must be the same potential
   HVD_P INTERACT PSDc > 1 BY NET
}

HVD_P.R.6 { @ {(HVD_P interact OD) AND PO} must be a rectangle,
            @ a concave shape is noe allowed
  NOT RECTANGLE ((HVD_P INTERACT OD) AND POLY)
}

#ELSE
HVD_P.WARN { @ 5V HV MOS is allowed only in N65LP process
  COPY HVD_P
}
#ENDIF
#ELSE
HVD_P.WARN { @ 5V HV MOS is allowed only in N65LP process
  COPY HVD_P
}
#ENDIF



//GUARD RING RULES
//=================

HVPMOS = PPOD INTERACT HVD_P
HVNMOS = NPOD INTERACT HVD_N_nw
  
GR.R.1 { @ It is not allowed to place HVNMOS and HVPMOS inside the same guard-ring
  PSTP_HOLES = HOLES PSTP
  NSTP_HOLES = HOLES NSTP
  PSTP_HOLES ENCLOSE HVPMOS
  NSTP_HOLES ENCLOSE HVNMOS
}



#IFNDEF HALF_NODE
#IFDEF LP
//Breakdown Characterization RULES
//================================

HVPMOS_GATE = GATE AND HVPMOS
HVNMOS_GATE = GATE AND HVNMOS

BV.W.1g { @ Maximum HV NMOS channel width <= ^BV_W_1 um
  HVNMOS_GATE_W = POLY COIN INSIDE EDGE HVNMOS_GATE
  VALID_HVNGATE_W = LENGTH HVNMOS_GATE_W <= BV_W_1
  HVNMOS_GATE_W NOT COINCIDENT EDGE VALID_HVNGATE_W
}

BV.W.2g { @ Maximum HV NMOS channel width <= ^BV_W_2 um
  HVPMOS_GATE_W = POLY COIN INSIDE EDGE HVPMOS_GATE
  VALID_HVPGATE_W = LENGTH HVPMOS_GATE_W <= BV_W_2
  HVPMOS_GATE_W NOT COINCIDENT EDGE VALID_HVPGATE_W
}

BV.R.1g { @ Maximum finger number of PO gate in the same OD <= ^BV_R_1 um
  HVPMOS INTERACT GATE > BV_R_1
  HVNMOS INTERACT GATE > BV_R_1
}

#ENDIF
#ENDIF


#ENDIF


//CO CHECKS
//=========

CO.W.1 { @ Width (maximum = minimum except for seal-ring and fuse protection ring) = ^CO_W_1 um
@ CO.R.3  45-degree rotated CO is not allowed     
  A = NOT RECTANGLE COs == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  (A NOT VIA_EXD) NOT INSIDE SRAM_EXCLUDE
}
CO.W.2 { @ CO bar width = ^CO_W_2 um (CO bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring) 
  INT CO_BAR < CO_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY 
  A = CO_BAR WITH WIDTH > CO_W_2
  B = ANGLE CO_BAR == 45
  C = INT B < CO_W_2 + GRID REGION
  D = A NOT C
  ENCLOSE RECTANGLE D 1 0.005
}
CO.S.1 { @ Space >= 0.11 
  EXT CO < CO_S_1 ABUT < 90 SINGULAR REGION
}
CO.S.2 { @ Space to 3-neighboring CO (< 0.15 um distance) >= 0.14 
  X = WITH NEIGHBOR CO > 2 SPACE < CO_S_2_N
  EXT X CO < CO_S_2 ABUT < 90 SINGULAR REGION
}

CO_NODAL = COPY CO
CONNECT CO_NODAL COi

CO.S.2.1 { @ Space to neighboring CO [different net and common parallel run length > 0]  >= 0.14 
  EXT CO_NODAL < CO_S_2_1 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}

CO.S.2.2 { @ Space to neighboring CO [different net] >= 0.12 
  EXT CO_NODAL < CO_S_2_2 ABUT < 90 NOT CONNECTED REGION
}

CO.S.3 { @ Space to GATE (Overlap of GATE is not allowed) >=  ^CO_S_3
  A = EXT COOD GATE < CO_S_3 ABUT < 90 SINGULAR REGION
  A NOT INSIDE SRAMDMY_PERI
  CO AND GATE
  // Checks for SRAM periphery are implemented by WLD.R.1 and WLD.R.2
}

CO.S.4 { @ {CO inside PO} space to OD >= 0.07 
  EXT COPO OD < CO_S_4 ABUT < 90 SINGULAR REGION
}
CO.S.5 { @ {CO inside OD} space to 1.8V or 2.5V or 3.3V GATE >= 0.09 
  EXT COOD HV_GATE < CO_S_5 ABUT < 90 SINGULAR REGION
}
CO.S.6 { @ Space to butted PP/NP edge on OD (overlap of NP/PP boundary on OD is not allowed.) >= 0.06 
  EXT NP_PP_BTE COOD < CO_S_6 ABUT < 90 REGION
  ENC COOD NP_PP_BTE < CO_S_6 ABUT < 90 REGION 
  ((COOD NOT CSRDMY) NOT SEALRING) CUT PP // exclude sealring region
  ENC COOD PP < 0.001 ABUT < 90 SINGULAR REGION
  ENC COOD NP < 0.001 ABUT < 90 SINGULAR REGION
}

CO.EN.1 { @ Enclosure by OD >= ^CO_EN_1 um
  ENC COOD OD < CO_EN_1 ABUT < 90 SINGULAR REGION
}

CO.EN.1.1 { @ Enclosure by OD [at least two opposite side] >= ^CO_EN_1_1 um.  
  X = RECTANGLE ENCLOSURE COOD OD ABUT < 90 SINGULAR GOOD CO_EN_1 CO_EN_1_1 OPPOSITE CO_EN_1 CO_EN_1_1 OPPOSITE
  Y = ENC [X] OD < CO_EN_1_1 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}

CO.EN.2 { @ Enclosure by PO >= ^CO_EN_2 
  ENC COPO POLYs < CO_EN_2 ABUT < 90 SINGULAR REGION
  COPO NOT POLY
}

CO.EN.3_CO.EN.4 { @ Enclosure by PO [at least two opposite sides] >= ^CO_EN_3 ,or [all sides] >= ^CO_EN_4
  X = RECTANGLE ENCLOSURE CO POLYs ABUT >0 < 90 SINGULAR GOOD CO_EN_2 CO_EN_3 OPPOSITE CO_EN_2 CO_EN_3 OPPOSITE
  ENC X POLYs < CO_EN_4 ABUT < 90 SINGULAR REGION
}

// CO.R.2 is checked by RPO.S.3
// CO.R.3 is checked by CO.W.1
// CO.R.4 is checked by M1.EN.1, CO.EN.2


#IFDEF BACK_END


//M1 CHECKS
//=========

M1Wide_first = (SIZE M1 BY M1_S_2_W /2 UNDEROVER TRUNCATE M1_S_2_W /2) AND M1 
#IFDEF HALF_NODE
M1Wide_0.4 = (SIZE M1Wide_first BY (M1_S_2_1_W + OFFSETX )/2 UNDEROVER TRUNCATE (M1_S_2_1_W + OFFSETX) /2) AND M1Wide_first
M1Wide_0.2  = (SIZE M1 BY M1_S_2_2_W /2 UNDEROVER TRUNCATE M1_S_2_2_W /2) AND M1
M1Wide_0.42 = (SIZE M1Wide_first BY M1_S_2_3_W /2 UNDEROVER TRUNCATE M1_S_2_3_W /2) AND M1Wide_first
#ELSE
M1Wide_0.4 = (SIZE M1Wide_first BY M1_S_2_1_W /2 UNDEROVER TRUNCATE M1_S_2_1_W /2) AND M1Wide_first
#ENDIF
M1Wide_1.5 = (SIZE M1Wide_first BY M1_S_3_W /2 UNDEROVER TRUNCATE M1_S_3_W /2) AND M1Wide_first
M1Wide_4.5 = (SIZE M1Wide_1.5 BY M1_S_4_W /2 UNDEROVER TRUNCATE M1_S_4_W /2) AND M1Wide_1.5

M1_10 = M1Wide_first NOT CB_NON_CUP
M1_11 = M1Wide_0.4 NOT CB_NON_CUP
#IFDEF HALF_NODE
M1_12 = M1Wide_0.2 NOT CB_NON_CUP
M1_13 = M1Wide_0.42 NOT CB_NON_CUP
#ENDIF
M1_2 = M1Wide_1.5 NOT CB_NON_CUP
M1_3 = M1Wide_4.5 NOT CB_NON_CUP

M1AS3 = AREA M1 > M1_S_3_L*M1_W_1  // filter small metal for M1.S.3
M1AS4 = AREA M1AS3 > M1_S_4_L*M1_W_1  // filter small metal for M1.S.4

M1_EDGE_45 = M1 ANGLE == 45

M1.W.1 { @ Width >= 0.09 
  (INT M1s < M1_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE    
}
M1.W.2 { @ Width of 45-degree bent M1 Please make sure the vertex of 45 degree pattern is on 5nm grid (refer to the guideline, G.6gU, in section 3.7) >= 0.19 
  INT M1_EDGE_45 < M1_W_2 ABUT < 90 REGION
}
M1.W.3 { @ Maximum width <= 12.00 
  SIZE M1 BY M1_W_3 /2 UNDEROVER TRUNCATE M1_W_3 /2
}
M1.S.1 { @ Space >= 0.09 
  EXT M1 < M1_S_1 ABUT < 90 SINGULAR REGION
}
M1.S.2 { @ Space [at least one metal line width > ^M1_S_2_W um  and the parallel metal run length > ^M1_S_2_L um ] (union projection) >= ^M1_S_2
  X = EXT M1_10 M1 < M1_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_L+GRID
}
M1.S.2.1 { @ Space [at least one metal line width > ^M1_S_2_1_W um  and the parallel metal run length > ^M1_S_2_1_L um ] (union projection) >= ^M1_S_2_1

  X = EXT M1_11 M1 < M1_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_1_L+GRID
}

#IFDEF HALF_NODE
M1.S.2.2 { @ Space [at least one metal line width > ^M1_S_2_2_W um  and the parallel metal run length > ^M1_S_2_2_L um ] (union projection) >= ^M1_S_2_2
  X = EXT M1_12 M1 < M1_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_2_L+GRID
}
M1.S.2.3 { @ Space [at least one metal line width > ^M1_S_2_3_W um  and the parallel metal run length > ^M1_S_2_3_L um ] (union projection) >= ^M1_S_2_3
  X = EXT M1_13 M1 < M1_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_3_L+GRID
}
#ENDIF

M1.S.3 { @ Space [at least one metal line width > ^M1_S_3_W um  and the parallel metal run length > ^M1_S_3_L um ] (union projection) >= ^M1_S_3
  X = EXT M1_2 M1AS3 < M1_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_3_L+GRID
}

M1.S.4 { @ Space [at least one metal line width > ^M1_S_4_W um  and the parallel metal run length > ^M1_S_4_L um ] (union projection) >= ^M1_S_4
  X = EXT M1_3 M1AS4 < M1_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_4_L+GRID
}

M1.S.5 { @ Space at M1 line-end (W<Q=0.110) in a dense-line-end configuration: If M1 has parallel run length with opposite M1 (measured with T=0.035 extension) along 2 adjacent edges of M1 [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.09 um (R)) >= 0.11 
  A = CONVEX EDGE M1 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M1_S_5_Q
  B = EXT [A] M1 < M1_S_5 ABUT < 90 OPPOSITE EXTENDED M1_S_5_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [M1] < M1_S_5_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M1_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M1_S_5_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M1 < M1_S_5 ABUT < 90 OPPOSITE REGION
}
M1.S.6 { @ Space to 45-degree bent M1 >= 0.19 
  X = EXPAND EDGE M1_EDGE_45 OUTSIDE BY M1_S_6
  X AND M1
}

// M1.EN.0 is checked by M1.EN.1, M1.EN.2, and M1.EN.3

M1.EN.1 { @ Enclosure of CO >= 0.00 
  COs NOT M1s
}
M1.EN.2_M1.EN.3 { @ Enclosure of CO [at least two opposite sides] >= ^M1_EN_2, or [all sides] >= ^M1_EN_3  
  A = RECTANGLE ENCLOSURE COs M1s ABUT >0 < 90 GOOD 0 M1_EN_2 OPPOSITE 0 M1_EN_2 OPPOSITE
 (ENC A M1s < M1_EN_3 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
}

M1Wide_1.0 = (SIZE M1Wide_first BY M1_EN_4_W /2 UNDEROVER TRUNCATE M1_EN_4_W /2) AND M1Wide_first

M1.EN.4 { @ Enclosure of CO [M1 width > 1um] >= 0.04 
   A = COs INSIDE M1Wide_1.0
   ENC A M1s < M1_EN_4 ABUT < 90 SINGULAR REGION
}


M1.A.1 { @ Area >= ^M1_A_1 um2
  (AREA M1s < M1_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE M1_A_2pre ((M1_A_2 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))*((M1_A_2 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))/3.141

M1.A.2 { @ Enclosed area >=  ^M1_A_2 um2
   X = HOLES M1s INNER < M1_A_2pre
   (AREA ( X NOT M1i ) < M1_A_2) NOT INSIDE SRAM_EXCLUDE
}


M1DN1H_EXC = COPY M1_EXC
M1DN1L_EXC = COPY M1_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
M1.DN.1L { @ M1 local density must be >= ^M1_DN_1L range over ^M1_DN_1L_W um x ^M1_DN_1L_W um step ^M1_DN_1L_S um
  M1_CHECK = M1x NOT M1DN1L_EXC
  CHIP_CHECK = CHIP NOT M1DN1L_EXC
  ERR_WIN = DENSITY M1_CHECK CHIP_CHECK < M1_DN_1L WINDOW M1_DN_1L_W STEP M1_DN_1L_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M1DN1L_EXC) >= M1_DN_1L_E
  DENSITY F M1_CHECK CHIP_CHECK < M1_DN_1L WINDOW M1_DN_1L_W STEP M1_DN_1L_S INSIDE OF LAYER CHIPx BACKUP PRINT M1.DN.1L.density
         [ !AREA(F)+AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M1.DN.1H { @ M1 local density must be <= ^M1_DN_1H range over ^M1_DN_1H_W um x ^M1_DN_1H_W um step ^M1_DN_1H_S um
  M1_CHECK = M1x NOT M1DN1H_EXC
  CHIP_CHECK = CHIP NOT M1DN1H_EXC
  ERR_WIN = DENSITY M1_CHECK CHIP_CHECK > M1_DN_1H WINDOW M1_DN_1H_W STEP M1_DN_1H_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M1DN1H_EXC) >= M1_DN_1H_E
  DENSITY F M1_CHECK CHIP_CHECK > M1_DN_1H WINDOW M1_DN_1H_W STEP M1_DN_1H_S INSIDE OF LAYER CHIPx BACKUP PRINT M1.DN.1H.density
         [ !!AREA(F)*AREA(M1_CHECK)/AREA(CHIP_CHECK) ]
}

M1DN2_EXC = COPY EMPTYi


M1.DN.2 { @ M1 local density must be <= ^M1_DN_2 range over ^M1_DN_2_W um x ^M1_DN_2_W um step ^M1_DN_2_S um
  M1_CHECK = M1x NOT M1DN2_EXC
  ERR_WIN = DENSITY M1_CHECK CHIP > M1_DN_2 WINDOW M1_DN_2_W STEP M1_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(M1_CHECK)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT M1DN2_EXC) >= M1_DN_2_E
  DENSITY F M1_CHECK CHIP > M1_DN_2 WINDOW M1_DN_2_W STEP M1_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT M1.DN.2.density 
          [ !!AREA(F)*AREA(M1_CHECK)/AREA(CHIP) ]
}

M1.DN.4 { @ The metal density difference between any two ^M1_DN_4_W um x ^M1_DN_4_W um neighboring checking windows including DM1EXCL <= ^M1_DN_4
  DENSITY M1x CHIP <=1 WINDOW M1_DN_4_W BACKUP GRADIENT > M1_DN_4 ABSOLUTE CORNER PRINT M1.DN.4.density
  	[ AREA(M1x)/AREA(CHIP) ]     
}



//M1.R.1 can't be checked

// Pre-Notice rules
// New Mx.R.3
//==============
M1_CORE = M1x NOT SRCSR





//VIA1 CHECKS
//===========

M2Wide_first = (SIZE M2 BY M2_S_2_W /2 UNDEROVER TRUNCATE M2_S_2_W /2) AND M2 
M2Wide_0.4 = (SIZE M2Wide_first BY M2_S_2_1_W /2 UNDEROVER TRUNCATE M2_S_2_1_W /2) AND M2Wide_first
#IFDEF HALF_NODE
M2Wide_0.2 = (SIZE M2 BY M2_S_2_2_W /2 UNDEROVER TRUNCATE M2_S_2_2_W /2) AND M2
M2Wide_0.4S = (SIZE M2Wide_first BY M2_S_2_3_W /2 UNDEROVER TRUNCATE M2_S_2_3_W /2) AND M2Wide_first
#ENDIF
M2Wide_1.5 = (SIZE M2Wide_first BY M2_S_3_W /2 UNDEROVER TRUNCATE M2_S_3_W /2) AND M2Wide_first
M2Wide_4.5 = (SIZE M2Wide_1.5 BY M2_S_4_W /2 UNDEROVER TRUNCATE M2_S_4_W /2) AND M2Wide_1.5

M1Wide_0.42_VIA1 = (SIZE M1Wide_first BY VIA1_R_2_W /2 UNDEROVER TRUNCATE VIA1_R_2_W /2) AND M1Wide_first 
M1Wide_0.7_VIA1 = (SIZE M1Wide_0.42_VIA1 BY VIA1_R_4_W /2 UNDEROVER TRUNCATE VIA1_R_4_W /2) AND M1Wide_0.42_VIA1
M1Wide_0.98_VIA1 = (SIZE M1Wide_0.7_VIA1 BY VIA1_R_3_W /2 UNDEROVER TRUNCATE VIA1_R_3_W /2) AND M1Wide_0.7_VIA1
M1Wide_2_VIA1 = (SIZE M1Wide_0.98_VIA1 BY VIA1_R_5_W /2 UNDEROVER TRUNCATE VIA1_R_5_W /2) AND M1Wide_0.98_VIA1
M1Wide_3_VIA1 = (SIZE M1Wide_2_VIA1 BY VIA1_R_6_W /2 UNDEROVER TRUNCATE VIA1_R_6_W /2) AND M1Wide_2_VIA1
M2Wide_0.42_VIA1 = (SIZE M2Wide_first BY VIA1_R_2_W /2 UNDEROVER TRUNCATE VIA1_R_2_W /2) AND M2Wide_first 
M2Wide_0.7_VIA1 = (SIZE M2Wide_0.42_VIA1 BY VIA1_R_4_W /2 UNDEROVER TRUNCATE VIA1_R_4_W /2) AND M2Wide_0.42_VIA1
M2Wide_0.98_VIA1 = (SIZE M2Wide_0.7_VIA1 BY VIA1_R_3_W /2 UNDEROVER TRUNCATE VIA1_R_3_W /2) AND M2Wide_0.7_VIA1 
M2Wide_2_VIA1 = (SIZE M2Wide_0.98_VIA1 BY VIA1_R_5_W /2 UNDEROVER TRUNCATE VIA1_R_5_W /2) AND M2Wide_0.98_VIA1
M2Wide_3_VIA1 = (SIZE M2Wide_2_VIA1 BY VIA1_R_6_W /2 UNDEROVER TRUNCATE VIA1_R_6_W /2) AND M2Wide_2_VIA1 


VIA1.W.1 { @ Width (maximum = minimum except for seal-ring and fuse protection ring) = ^VIA1_W_1
@ VIA1.R.1 45-degree rotated VIA is not allowed     
  A = NOT RECTANGLE VIA1s == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
  (A NOT VIA_EXD) NOT SRAM_EXCLUDE
}
VIA1.W.2 { @ VIA1 bar width = ^VIA1_W_2 (VIA1 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring) 
  INT VIA1_BAR < VIA1_W_2 ABUT < 90 OPPOSITE REGION
  A = VIA1_BAR WITH WIDTH > VIA1_W_2
  B = ANGLE VIA1_BAR == 45
  C = INT B < VIA1_W_2 + 2*GRID REGION
  D = A NOT C
  ENCLOSE RECTANGLE D 1 0.005

}
VIA1.S.1 { @ Space >= 0.10 
  EXT VIA1 < VIA1_S_1 ABUT < 90 SINGULAR REGION
}

VIA1.S.2 { @ Space to 3-neighboring VIAx (< 0.14 um distance) >= 0.13 
  X = WITH NEIGHBOR VIA1 > 2 SPACE < VIA1_S_2_S
  EXT X VIA1 < VIA1_S_2 ABUT < 90 SINGULAR REGION
}

VIA1.S.3 { @ Space to neighboring VIAx [different net and common parallel run length > 0] >= 0.13 
  VIA1_NODAL = STAMP VIA1 BY VIA1i
  EXT VIA1_NODAL < VIA1_S_3 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}


VIA1.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA1 NOT M1
}

VIA1.EN.2_VIA1.EN.3 { @ Enclosure by M1 [at least two opposite sides] >= ^VIA1_EN_2 , or [all sides] >= ^VIA1_EN_3
  X = RECTANGLE ENCLOSURE VIA1 M1s ABUT < 90 SINGULAR GOOD 0 VIA1_EN_2 OPPOSITE 0 VIA1_EN_2 OPPOSITE
  ENC X M1s < VIA1_EN_3 ABUT < 90 SINGULAR REGION
}



#IFDEF HALF_NODE 
VARIABLE VIA1_R_2_S2_S1  (VIA1_R_2_S2 - VIA1_R_2_S1 - OFFSETX)/2
#ELSE
VARIABLE VIA1_R_2_S2_S1  (VIA1_R_2_S2 - VIA1_R_2_S1)/2
#ENDIF

// VIA1.R.1 is checked by VIA1.W.1
VIA1.R.2_VIA1.R.3 { @ When M1 or M2 width > ^VIA1_R_2_W um, more than one VIA1 is required.
                    @ 2 vias spacing should be <= ^VIA1_R_2_S1 um or 4 vias spacing should be <= ^VIA1_R_2_S2 um
  		    @ When M1 or M2 width > ^VIA1_R_3_W um, more than three VIA1 is required.
                    @ 4 vias spacing should be <= ^VIA1_R_3_S1 um or 9 vias spacing should be <= ^VIA1_R_3_S2 um
   M2OvpM1_W_ = (M1Wide_0.42_VIA1 AND M2) OR (M2Wide_0.42_VIA1 AND M1)
   M2OvpM1_B  = (M1Wide_0.98_VIA1 AND M2) OR (M2Wide_0.98_VIA1 AND M1)
   M2OvpM1_W  = M2OvpM1_W_ NOT M2OvpM1_B 
   Checked_VIA1_W_ = VIA1_EXD NOT OUTSIDE M2OvpM1_W
   Checked_VIA1_B  = VIA1_EXD NOT OUTSIDE M2OvpM1_B
   Checked_VIA1_W  = Checked_VIA1_W_ NOT Checked_VIA1_B
   M1_effect = M1i INTERACT M2OvpM1_W_
   M2_effect = M2i INTERACT M2OvpM1_W_
   effect_M2OvpM1_ = M1_effect AND M2_effect
   effect_M2OvpM1 = effect_M2OvpM1_ INTERACT M2OvpM1_W_
   effect_VIA = VIA1_EXD INTERACT effect_M2OvpM1

   V1Merged_A = SIZE effect_VIA BY VIA1_R_2_S1/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_B = SIZE V1Merged_A BY VIA1_R_2_S2_S1 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_C = SIZE V1Merged_B BY (VIA1_R_3_S2 - VIA1_R_2_S2)/2 INSIDE OF effect_M2OvpM1 STEP M1_S_1*0.7
   V1Merged_A2R = V1Merged_A INTERACT effect_VIA < 2
   V1Merged_A2 = V1Merged_A OUTSIDE V1Merged_A2R
   V1Merged_A4R = V1Merged_A2 INTERACT effect_VIA < 4
   V1Merged_A4 = V1Merged_A2 OUTSIDE V1Merged_A4R
   V1Merged_B4R = V1Merged_B INTERACT effect_VIA < 4
   V1Merged_B4 = V1Merged_B OUTSIDE V1Merged_B4R
   V1Merged_C9R = V1Merged_C INTERACT effect_VIA < 9
   V1Merged_C9 = V1Merged_C OUTSIDE V1Merged_C9R

   GMergeW = V1Merged_A2 OR V1Merged_B4
   GMergeB = V1Merged_A4 OR V1Merged_C9
   GVIA_W = Checked_VIA1_W INTERACT GMergeW
   GVIA_B = Checked_VIA1_B INTERACT GMergeB
   GOOD_AREA_W = M2OvpM1_W INTERACT GVIA_W
   GOOD_AREA_B = M2OvpM1_B INTERACT GVIA_B
   Checked_VIA1_W OUTSIDE GOOD_AREA_W
   Checked_VIA1_B OUTSIDE GOOD_AREA_B
}

VIA1.R.4.M1 { @  At least two VIAx must be used for a connection that is <= ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W).)   
  Branch1 = ((SIZE M1Wide_0.7_VIA1 BY VIA1_R_4_D + GRID) NOT M1Wide_0.7_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_0.7_VIA1) INTERACT VIA1
  Branch1Edge = M1Wide_0.7_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M1_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA1.R.4.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_4_W um (L) and width > ^VIA1_R_4_W um (W).)   
  Branch1 = ((SIZE M2Wide_0.7_VIA1 BY VIA1_R_4_D + GRID) NOT M2Wide_0.7_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_0.7_VIA1) INTERACT VIA1
  Branch1Edge = M2Wide_0.7_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M1) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA1.R.5.M1 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W). It is allowed to use one VIAx for a connection that is > ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W).)  
  Branch1 = ((SIZE M1Wide_2_VIA1 BY VIA1_R_5_D + GRID) NOT M1Wide_2_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_2_VIA1) INTERACT VIA1
  Branch1Edge = M1Wide_2_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA1.R.5.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W). It is allowed to use one VIAx for a connection that is > ^VIA1_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_5_W um (L) and width > ^VIA1_R_5_W um (W).)  
  Branch1 = ((SIZE M2Wide_2_VIA1 BY VIA1_R_5_D + GRID) NOT M2Wide_2_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_2_VIA1) INTERACT VIA1
  Branch1Edge = M2Wide_2_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M1Big_3_VIA1 = ENCLOSE RECTANGLE M1Wide_3_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID

VIA1.R.6.M1 { @  At least two VIAx must be used for a connection that is <= ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W)).
  Branch1 = ((SIZE M1Big_3_VIA1 BY VIA1_R_6_D + GRID) NOT M1Big_3_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Big_3_VIA1) INTERACT VIA1
  Branch1Edge = M1Big_3_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M2Big_3_VIA1 = ENCLOSE RECTANGLE M2Wide_3_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID

VIA1.R.6.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA1_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA1_R_6_L um (L) and width > ^VIA1_R_6_W um (W)).
  Branch1 = ((SIZE M2Big_3_VIA1 BY VIA1_R_6_D + GRID) NOT M2Big_3_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_3_VIA1) INTERACT VIA1
  Branch1Edge = M2Big_3_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA1.R.7 is checked by VIA1.EN.1 and M2.EN.1
// VIA1.R.9 can't be checked


VIA1.R.11{@ Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= ^VIA1_R_11_A um2 and two metal hole length(L2) <= ^VIA1_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 
@ 3. The length (L) of the center metal bar <= ^VIA1_R_11_L um and the width of metal bar is <= ^VIA1_R_11_W um. 
  W = M2i WITH WIDTH <= VIA1_R_11_W   
  H_HOLE = HOLES M2i INNER <= VIA1_R_11_A
  A = M2i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA1_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M2i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA1_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M2i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA1_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA1_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA1_R_11_L+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M2i <= VIA1_R_11_L2 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA1i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M2i INTERACT CHECK_VIA) AND (M1i INTERACT CHECK_VIA)) INTERACT VIA1i == 1)
}


//M2 CHECKS
//=========

M21 = M2Wide_first NOT CB_NON_CUP
M211 = M2Wide_0.4 NOT CB_NON_CUP
#IFDEF HALF_NODE  
M212 = M2Wide_0.2 NOT CB_NON_CUP
M213 = M2Wide_0.4S NOT CB_NON_CUP
#ENDIF
M22 = M2Wide_1.5 NOT CB_NON_CUP
M23 = M2Wide_4.5 NOT CB_NON_CUP

M2AS3 = AREA M2 > M2_S_3_L*M2_W_1  // filter small metal for M2.S.3
M2AS4 = AREA M2AS3 > M2_S_4_L*M2_W_1  // filter small metal for M2.S.4

M2_EDGE_45 = M2 ANGLE == 45

M2.W.1 { @ Width >= 0.10 
  INT M2 < M2_W_1 ABUT < 90 SINGULAR REGION
}
M2.W.2 { @ Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid (refer to the guideline, G.6gU, in section 3.7) >= 0.19 
  INT M2_EDGE_45 < M2_W_2 ABUT < 90 REGION
}
M2.W.3 { @ Maximum width <= 12.00 
  SIZE M2 BY M2_W_3 /2 UNDEROVER TRUNCATE M2_W_3 /2
}
M2.S.1 { @ Space >= 0.10 
  EXT M2 < M2_S_1 ABUT < 90 SINGULAR REGION
}

M2.S.2 { @ Space [at least one metal line width > ^M2_S_2_W um  and the parallel metal run length > ^M2_S_2_L um ] (union projection) >= ^M2_S_2
  X = EXT M21 M2 < M2_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_L+GRID
}

M2.S.2.1 { @ Space [at least one metal line width > ^M2_S_2_1_W um  and the parallel metal run length > ^M2_S_2_1_L um ] (union projection) >= ^M2_S_2_1
  X = EXT M211 M2 < M2_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_1_L+GRID
}

#IFDEF HALF_NODE
M2.S.2.2 { @  Space [at least one metal line width > ^M2_S_2_2_W um  and the parallel metal run length > ^M2_S_2_2_L um ] (union projection) >= ^M2_S_2_2
  X = EXT M212 M2 < M2_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_2_L+GRID
}
M2.S.2.3 { @ Space [at least one metal line width > ^M2_S_2_3_W um  and the parallel metal run length > ^M2_S_2_3_L um ] (union projection) >= ^M2_S_2_3
  X = EXT M213 M2 < M2_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_3_L+GRID
}
#ENDIF

M2.S.3 { @ Space [at least one metal line width > ^M2_S_3_W um  and the parallel metal run length > ^M2_S_3_L um ] (union projection) >= ^M2_S_3
  X = EXT M22 M2AS3 < M2_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_3_L+GRID
}

M2.S.4 { @ Space [at least one metal line width > ^M2_S_4_W um  and the parallel metal run length > ^M2_S_4_L um ] (union projection) >= ^M2_S_4
  X = EXT M23 M2AS4 < M2_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_4_L+GRID
}

M2.S.5 { @ Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= 0.12 
  M2sx = M2 NOT SRAM_EXCLUDE
  A = CONVEX EDGE M2sx ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M2_S_5_Q
  B = EXT [A] M2sx < M2_S_5 ABUT < 90 OPPOSITE EXTENDED M2_S_5_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [M2sx] < M2_S_5_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M2_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M2_S_5_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M2sx < M2_S_5 ABUT < 90 OPPOSITE REGION
}
M2.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA1 NOT M2
}


M2.EN.2_M2.EN.3 { @ Enclosure of VIA1 [at least two opposite sides] >= ^M2_EN_2 ,or [all sides] >= ^M2_EN_3  
  X = RECTANGLE ENCLOSURE VIA1 M2 ABUT < 90 SINGULAR GOOD 0 M2_EN_2 OPPOSITE 0 M2_EN_2 OPPOSITE
  ENC X M2 < M2_EN_3 ABUT < 90 SINGULAR REGION
}



M2.A.1 { @ Area >= 0.052 
  A = AREA M2 < M2_A_1
  A NOT SRAM_EXCLUDE
}

VARIABLE M2_A_2pre ((M2_A_2 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))*((M2_A_2 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))/3.141
M2.A.2 { @ Enclosed area >= 0.20 
   X = HOLES M2 INNER < M2_A_2pre
   AREA ( X NOT M2 ) < M2_A_2
}

M2.S.6 { @ Space to 45-degree bent Mx >= 0.19 
  X = EXPAND EDGE M2_EDGE_45 OUTSIDE BY M2_S_6
  X AND M2
}



// M2.R.1 can not be checked


M2DN1H_EXC = COPY M2_EXC
M2DN1L_EXC = COPY M2_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
M2.DN.1L { @ M2 local density must be >= ^M2_DN_1L range over ^M2_DN_1L_W um x ^M2_DN_1L_W um step ^M2_DN_1L_S um
  M2_CHECK = M2x NOT M2DN1L_EXC
  CHIP_CHECK = CHIP NOT M2DN1L_EXC
  ERR_WIN = DENSITY M2_CHECK CHIP_CHECK < M2_DN_1L WINDOW M2_DN_1L_W STEP M2_DN_1L_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M2DN1L_EXC) >= M2_DN_1L_E
  DENSITY F M2_CHECK CHIP_CHECK < M2_DN_1L WINDOW M2_DN_1L_W STEP M2_DN_1L_S INSIDE OF LAYER CHIPx BACKUP PRINT M2.DN.1L.density
         [ !AREA(F)+AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M2.DN.1H { @ M2 local density must be <= ^M2_DN_1H range over ^M2_DN_1H_W um x ^M2_DN_1H_W um step ^M2_DN_1H_S um
  M2_CHECK = M2x NOT M2DN1H_EXC
  CHIP_CHECK = CHIP NOT M2DN1H_EXC
  ERR_WIN = DENSITY M2_CHECK CHIP_CHECK > M2_DN_1H WINDOW M2_DN_1H_W STEP M2_DN_1H_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M2DN1H_EXC) >= M2_DN_1H_E
  DENSITY F M2_CHECK CHIP_CHECK > M2_DN_1H WINDOW M2_DN_1H_W STEP M2_DN_1H_S INSIDE OF LAYER CHIPx BACKUP PRINT M2.DN.1H.density
         [ !!AREA(F)*AREA(M2_CHECK)/AREA(CHIP_CHECK) ]
}

M2DN2_EXC = COPY EMPTYi


M2.DN.2 { @ M2 local density must be <= ^M2_DN_2 range over ^M2_DN_2_W um x ^M2_DN_2_W um step ^M2_DN_2_S um
  M2_CHECK = M2x NOT M2DN2_EXC
  ERR_WIN = DENSITY M2_CHECK CHIP > M2_DN_2 WINDOW M2_DN_2_W STEP M2_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(M2_CHECK)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT M2DN2_EXC) >= M2_DN_2_E
  DENSITY F M2_CHECK CHIP > M2_DN_2 WINDOW M2_DN_2_W STEP M2_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT M2.DN.2.density 
          [ !!AREA(F)*AREA(M2_CHECK)/AREA(CHIP) ]
}

M2.DN.4 { @ The metal density difference between any two ^M2_DN_4_W um x ^M2_DN_4_W um neighboring checking windows including DM2EXCL <= ^M2_DN_4
  DENSITY M2x CHIP <=1 WINDOW M2_DN_4_W BACKUP GRADIENT > M2_DN_4 ABSOLUTE CORNER PRINT M2.DN.4.density
  	[ AREA(M2x)/AREA(CHIP) ]     
}



// Mx.DN.5
//===========
M2_CORE = M2x NOT SRCSR


		


//VIA2 CHECKS
//===========

M3Wide_first = (SIZE M3 BY M3_S_2_W /2 UNDEROVER TRUNCATE M3_S_2_W /2) AND M3 
M3Wide_0.4 = (SIZE M3Wide_first BY M3_S_2_1_W /2 UNDEROVER TRUNCATE M3_S_2_1_W /2) AND M3Wide_first
#IFDEF HALF_NODE
M3Wide_0.2 = (SIZE M3 BY M3_S_2_2_W /2 UNDEROVER TRUNCATE M3_S_2_2_W /2) AND M3
M3Wide_0.4S = (SIZE M3Wide_first BY M3_S_2_3_W /2 UNDEROVER TRUNCATE M3_S_2_3_W /2) AND M3Wide_first
#ENDIF
M3Wide_1.5 = (SIZE M3Wide_first BY M3_S_3_W /2 UNDEROVER TRUNCATE M3_S_3_W /2) AND M3Wide_first
M3Wide_4.5 = (SIZE M3Wide_1.5 BY M3_S_4_W /2 UNDEROVER TRUNCATE M3_S_4_W /2) AND M3Wide_1.5

M2Wide_0.42_VIA2 = (SIZE M2Wide_first BY VIA2_R_2_W /2 UNDEROVER TRUNCATE VIA2_R_2_W /2) AND M2Wide_first 
M2Wide_0.7_VIA2 = (SIZE M2Wide_0.42_VIA2 BY VIA2_R_4_W /2 UNDEROVER TRUNCATE VIA2_R_4_W /2) AND M2Wide_0.42_VIA2
M2Wide_0.98_VIA2 = (SIZE M2Wide_0.7_VIA2 BY VIA2_R_3_W /2 UNDEROVER TRUNCATE VIA2_R_3_W /2) AND M2Wide_0.7_VIA2
M2Wide_2_VIA2 = (SIZE M2Wide_0.98_VIA2 BY VIA2_R_5_W /2 UNDEROVER TRUNCATE VIA2_R_5_W /2) AND M2Wide_0.98_VIA2
M2Wide_3_VIA2 = (SIZE M2Wide_2_VIA2 BY VIA2_R_6_W /2 UNDEROVER TRUNCATE VIA2_R_6_W /2) AND M2Wide_2_VIA2
M3Wide_0.42_VIA2 = (SIZE M3Wide_first BY VIA2_R_2_W /2 UNDEROVER TRUNCATE VIA2_R_2_W /2) AND M3Wide_first 
M3Wide_0.7_VIA2 = (SIZE M3Wide_0.42_VIA2 BY VIA2_R_4_W /2 UNDEROVER TRUNCATE VIA2_R_4_W /2) AND M3Wide_0.42_VIA2
M3Wide_0.98_VIA2 = (SIZE M3Wide_0.7_VIA2 BY VIA2_R_3_W /2 UNDEROVER TRUNCATE VIA2_R_3_W /2) AND M3Wide_0.7_VIA2 
M3Wide_2_VIA2 = (SIZE M3Wide_0.98_VIA2 BY VIA2_R_5_W /2 UNDEROVER TRUNCATE VIA2_R_5_W /2) AND M3Wide_0.98_VIA2
M3Wide_3_VIA2 = (SIZE M3Wide_2_VIA2 BY VIA2_R_6_W /2 UNDEROVER TRUNCATE VIA2_R_6_W /2) AND M3Wide_2_VIA2 


VIA2.W.1 { @ Width (maximum = minimum except for seal-ring and fuse protection ring) = ^VIA2_W_1
@ VIA2.R.1 45-degree rotated VIA is not allowed     
  A = NOT RECTANGLE VIA2 == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA2.W.2 { @ VIA2 bar width = ^VIA2_W_2 (VIA2 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring) 
  INT VIA2_BAR < VIA2_W_2 ABUT < 90 OPPOSITE REGION
  A = VIA2_BAR WITH WIDTH > VIA2_W_2
  B = ANGLE VIA2_BAR == 45
  C = INT B < VIA2_W_2 + 2*GRID REGION
  D = A NOT C
  ENCLOSE RECTANGLE D 1 0.005

}
VIA2.S.1 { @ Space >= 0.10 
  EXT VIA2 < VIA2_S_1 ABUT < 90 SINGULAR REGION
}

VIA2.S.2 { @ Space to 3-neighboring VIAx (< 0.14 um distance) >= 0.13 
  X = WITH NEIGHBOR VIA2 > 2 SPACE < VIA2_S_2_S
  EXT X VIA2 < VIA2_S_2 ABUT < 90 SINGULAR REGION
}

VIA2.S.3 { @ Space to neighboring VIAx [different net and common parallel run length > 0] >= 0.13 
  VIA2_NODAL = STAMP VIA2 BY VIA2i
  EXT VIA2_NODAL < VIA2_S_3 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}


VIA2.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA2 NOT M2
}

VIA2.EN.2_VIA2.EN.3 { @ Enclosure by M2 [at least two opposite sides] >= ^VIA2_EN_2 , or [all sides] >= ^VIA2_EN_3
  A = VIA2 NOT SRAM_EXCLUDE 
  X = RECTANGLE ENCLOSURE A M2 ABUT < 90 SINGULAR GOOD 0 VIA2_EN_2 OPPOSITE 0 VIA2_EN_2 OPPOSITE
  ENC X M2 < VIA2_EN_3 ABUT < 90 SINGULAR REGION
}



#IFDEF HALF_NODE 
VARIABLE VIA2_R_2_S2_S1  (VIA2_R_2_S2 - VIA2_R_2_S1 - OFFSETX)/2
#ELSE
VARIABLE VIA2_R_2_S2_S1  (VIA2_R_2_S2 - VIA2_R_2_S1)/2
#ENDIF

// VIA2.R.1 is checked by VIA2.W.1
VIA2.R.2_VIA2.R.3 { @ When M2 or M3 width > ^VIA2_R_2_W um, more than one VIA2 is required.
                    @ 2 vias spacing should be <= ^VIA2_R_2_S1 um or 4 vias spacing should be <= ^VIA2_R_2_S2 um
  		    @ When M2 or M3 width > ^VIA2_R_3_W um, more than three VIA2 is required.
                    @ 4 vias spacing should be <= ^VIA2_R_3_S1 um or 9 vias spacing should be <= ^VIA2_R_3_S2 um
   M3OvpM2_W_ = (M2Wide_0.42_VIA2 AND M3) OR (M3Wide_0.42_VIA2 AND M2)
   M3OvpM2_B  = (M2Wide_0.98_VIA2 AND M3) OR (M3Wide_0.98_VIA2 AND M2)
   M3OvpM2_W  = M3OvpM2_W_ NOT M3OvpM2_B 
   Checked_VIA2_W_ = VIA2_EXD NOT OUTSIDE M3OvpM2_W
   Checked_VIA2_B  = VIA2_EXD NOT OUTSIDE M3OvpM2_B
   Checked_VIA2_W  = Checked_VIA2_W_ NOT Checked_VIA2_B
   M2_effect = M2i INTERACT M3OvpM2_W_
   M3_effect = M3i INTERACT M3OvpM2_W_
   effect_M3OvpM2_ = M2_effect AND M3_effect
   effect_M3OvpM2 = effect_M3OvpM2_ INTERACT M3OvpM2_W_
   effect_VIA = VIA2_EXD INTERACT effect_M3OvpM2

   V2Merged_A = SIZE effect_VIA BY VIA2_R_2_S1/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_B = SIZE V2Merged_A BY VIA2_R_2_S2_S1 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_C = SIZE V2Merged_B BY (VIA2_R_3_S2 - VIA2_R_2_S2)/2 INSIDE OF effect_M3OvpM2 STEP M2_S_1*0.7
   V2Merged_A2R = V2Merged_A INTERACT effect_VIA < 2
   V2Merged_A2 = V2Merged_A OUTSIDE V2Merged_A2R
   V2Merged_A4R = V2Merged_A2 INTERACT effect_VIA < 4
   V2Merged_A4 = V2Merged_A2 OUTSIDE V2Merged_A4R
   V2Merged_B4R = V2Merged_B INTERACT effect_VIA < 4
   V2Merged_B4 = V2Merged_B OUTSIDE V2Merged_B4R
   V2Merged_C9R = V2Merged_C INTERACT effect_VIA < 9
   V2Merged_C9 = V2Merged_C OUTSIDE V2Merged_C9R

   GMergeW = V2Merged_A2 OR V2Merged_B4
   GMergeB = V2Merged_A4 OR V2Merged_C9
   GVIA_W = Checked_VIA2_W INTERACT GMergeW
   GVIA_B = Checked_VIA2_B INTERACT GMergeB
   GOOD_AREA_W = M3OvpM2_W INTERACT GVIA_W
   GOOD_AREA_B = M3OvpM2_B INTERACT GVIA_B
   Checked_VIA2_W OUTSIDE GOOD_AREA_W
   Checked_VIA2_B OUTSIDE GOOD_AREA_B
}

VIA2.R.4.M2 { @  At least two VIAx must be used for a connection that is <= ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W).)   
  Branch1 = ((SIZE M2Wide_0.7_VIA2 BY VIA2_R_4_D + GRID) NOT M2Wide_0.7_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_0.7_VIA2) INTERACT VIA2
  Branch1Edge = M2Wide_0.7_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.4.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_4_W um (L) and width > ^VIA2_R_4_W um (W).)   
  Branch1 = ((SIZE M3Wide_0.7_VIA2 BY VIA2_R_4_D + GRID) NOT M3Wide_0.7_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_0.7_VIA2) INTERACT VIA2
  Branch1Edge = M3Wide_0.7_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.5.M2 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W). It is allowed to use one VIAx for a connection that is > ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W).)  
  Branch1 = ((SIZE M2Wide_2_VIA2 BY VIA2_R_5_D + GRID) NOT M2Wide_2_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_2_VIA2) INTERACT VIA2
  Branch1Edge = M2Wide_2_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA2.R.5.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W). It is allowed to use one VIAx for a connection that is > ^VIA2_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_5_W um (L) and width > ^VIA2_R_5_W um (W).)  
  Branch1 = ((SIZE M3Wide_2_VIA2 BY VIA2_R_5_D + GRID) NOT M3Wide_2_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_2_VIA2) INTERACT VIA2
  Branch1Edge = M3Wide_2_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M2Big_3_VIA2 = ENCLOSE RECTANGLE M2Wide_3_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID

VIA2.R.6.M2 { @  At least two VIAx must be used for a connection that is <= ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W)).
  Branch1 = ((SIZE M2Big_3_VIA2 BY VIA2_R_6_D + GRID) NOT M2Big_3_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_3_VIA2) INTERACT VIA2
  Branch1Edge = M2Big_3_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M3Big_3_VIA2 = ENCLOSE RECTANGLE M3Wide_3_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID

VIA2.R.6.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA2_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA2_R_6_L um (L) and width > ^VIA2_R_6_W um (W)).
  Branch1 = ((SIZE M3Big_3_VIA2 BY VIA2_R_6_D + GRID) NOT M3Big_3_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_3_VIA2) INTERACT VIA2
  Branch1Edge = M3Big_3_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA2.R.7 is checked by VIA2.EN.1 and M3.EN.1
// VIA2.R.9 can't be checked


VIA2.R.11{@ Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= ^VIA2_R_11_A um2 and two metal hole length(L2) <= ^VIA2_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 
@ 3. The length (L) of the center metal bar <= ^VIA2_R_11_L um and the width of metal bar is <= ^VIA2_R_11_W um. 
  W = M3i WITH WIDTH <= VIA2_R_11_W   
  H_HOLE = HOLES M3i INNER <= VIA2_R_11_A
  A = M3i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA2_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M3i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA2_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M3i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA2_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA2_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA2_R_11_L+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M3i <= VIA2_R_11_L2 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA2i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M3i INTERACT CHECK_VIA) AND (M2i INTERACT CHECK_VIA)) INTERACT VIA2i == 1)
}


//M3 CHECKS
//=========

M31 = M3Wide_first NOT CB_NON_CUP
M311 = M3Wide_0.4 NOT CB_NON_CUP
#IFDEF HALF_NODE  
M312 = M3Wide_0.2 NOT CB_NON_CUP
M313 = M3Wide_0.4S NOT CB_NON_CUP
#ENDIF
M32 = M3Wide_1.5 NOT CB_NON_CUP
M33 = M3Wide_4.5 NOT CB_NON_CUP

M3AS3 = AREA M3 > M3_S_3_L*M3_W_1  // filter small metal for M3.S.3
M3AS4 = AREA M3AS3 > M3_S_4_L*M3_W_1  // filter small metal for M3.S.4

M3_EDGE_45 = M3 ANGLE == 45

M3.W.1 { @ Width >= 0.10 
  INT M3 < M3_W_1 ABUT < 90 SINGULAR REGION
}
M3.W.2 { @ Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid (refer to the guideline, G.6gU, in section 3.7) >= 0.19 
  INT M3_EDGE_45 < M3_W_2 ABUT < 90 REGION
}
M3.W.3 { @ Maximum width <= 12.00 
  SIZE M3 BY M3_W_3 /2 UNDEROVER TRUNCATE M3_W_3 /2
}
M3.S.1 { @ Space >= 0.10 
  EXT M3 < M3_S_1 ABUT < 90 SINGULAR REGION
}

M3.S.2 { @ Space [at least one metal line width > ^M3_S_2_W um  and the parallel metal run length > ^M3_S_2_L um ] (union projection) >= ^M3_S_2
  X = EXT M31 M3 < M3_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_L+GRID
}

M3.S.2.1 { @ Space [at least one metal line width > ^M3_S_2_1_W um  and the parallel metal run length > ^M3_S_2_1_L um ] (union projection) >= ^M3_S_2_1
  X = EXT M311 M3 < M3_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_1_L+GRID
}

#IFDEF HALF_NODE
M3.S.2.2 { @  Space [at least one metal line width > ^M3_S_2_2_W um  and the parallel metal run length > ^M3_S_2_2_L um ] (union projection) >= ^M3_S_2_2
  X = EXT M312 M3 < M3_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_2_L+GRID
}
M3.S.2.3 { @ Space [at least one metal line width > ^M3_S_2_3_W um  and the parallel metal run length > ^M3_S_2_3_L um ] (union projection) >= ^M3_S_2_3
  X = EXT M313 M3 < M3_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_3_L+GRID
}
#ENDIF

M3.S.3 { @ Space [at least one metal line width > ^M3_S_3_W um  and the parallel metal run length > ^M3_S_3_L um ] (union projection) >= ^M3_S_3
  X = EXT M32 M3AS3 < M3_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_3_L+GRID
}

M3.S.4 { @ Space [at least one metal line width > ^M3_S_4_W um  and the parallel metal run length > ^M3_S_4_L um ] (union projection) >= ^M3_S_4
  X = EXT M33 M3AS4 < M3_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_4_L+GRID
}

M3.S.5 { @ Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= 0.12 
  A = CONVEX EDGE M3 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M3_S_5_Q
  B = EXT [A] M3 < M3_S_5 ABUT < 90 OPPOSITE EXTENDED M3_S_5_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [M3] < M3_S_5_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M3_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M3_S_5_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M3 < M3_S_5 ABUT < 90 OPPOSITE REGION

}
M3.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA2 NOT M3
}


M3.EN.2_M3.EN.3 { @ Enclosure of VIA2 [at least two opposite sides] >= ^M3_EN_2 ,or [all sides] >= ^M3_EN_3  
  A =  VIA2 NOT SRAM_EXCLUDE
  X = RECTANGLE ENCLOSURE A M3 ABUT < 90 SINGULAR GOOD 0 M3_EN_2 OPPOSITE 0 M3_EN_2 OPPOSITE
  ENC X M3 < M3_EN_3 ABUT < 90 SINGULAR REGION
}



M3.A.1 { @ Area >= 0.052 
  AREA M3 < M3_A_1
}

VARIABLE M3_A_2pre ((M3_A_2 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))*((M3_A_2 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))/3.141
M3.A.2 { @ Enclosed area >= 0.20 
   X = HOLES M3 INNER < M3_A_2pre
   AREA ( X NOT M3 ) < M3_A_2
}

M3.S.6 { @ Space to 45-degree bent Mx >= 0.19 
  X = EXPAND EDGE M3_EDGE_45 OUTSIDE BY M3_S_6
  X AND M3
}



// M3.R.1 can not be checked


M3DN1H_EXC = COPY M3_EXC
M3DN1L_EXC = COPY M3_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
M3.DN.1L { @ M3 local density must be >= ^M3_DN_1L range over ^M3_DN_1L_W um x ^M3_DN_1L_W um step ^M3_DN_1L_S um
  M3_CHECK = M3x NOT M3DN1L_EXC
  CHIP_CHECK = CHIP NOT M3DN1L_EXC
  ERR_WIN = DENSITY M3_CHECK CHIP_CHECK < M3_DN_1L WINDOW M3_DN_1L_W STEP M3_DN_1L_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M3DN1L_EXC) >= M3_DN_1L_E
  DENSITY F M3_CHECK CHIP_CHECK < M3_DN_1L WINDOW M3_DN_1L_W STEP M3_DN_1L_S INSIDE OF LAYER CHIPx BACKUP PRINT M3.DN.1L.density
         [ !AREA(F)+AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M3.DN.1H { @ M3 local density must be <= ^M3_DN_1H range over ^M3_DN_1H_W um x ^M3_DN_1H_W um step ^M3_DN_1H_S um
  M3_CHECK = M3x NOT M3DN1H_EXC
  CHIP_CHECK = CHIP NOT M3DN1H_EXC
  ERR_WIN = DENSITY M3_CHECK CHIP_CHECK > M3_DN_1H WINDOW M3_DN_1H_W STEP M3_DN_1H_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M3DN1H_EXC) >= M3_DN_1H_E
  DENSITY F M3_CHECK CHIP_CHECK > M3_DN_1H WINDOW M3_DN_1H_W STEP M3_DN_1H_S INSIDE OF LAYER CHIPx BACKUP PRINT M3.DN.1H.density
         [ !!AREA(F)*AREA(M3_CHECK)/AREA(CHIP_CHECK) ]
}

M3DN2_EXC = COPY EMPTYi


M3.DN.2 { @ M3 local density must be <= ^M3_DN_2 range over ^M3_DN_2_W um x ^M3_DN_2_W um step ^M3_DN_2_S um
  M3_CHECK = M3x NOT M3DN2_EXC
  ERR_WIN = DENSITY M3_CHECK CHIP > M3_DN_2 WINDOW M3_DN_2_W STEP M3_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(M3_CHECK)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT M3DN2_EXC) >= M3_DN_2_E
  DENSITY F M3_CHECK CHIP > M3_DN_2 WINDOW M3_DN_2_W STEP M3_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT M3.DN.2.density 
          [ !!AREA(F)*AREA(M3_CHECK)/AREA(CHIP) ]
}

M3.DN.4 { @ The metal density difference between any two ^M3_DN_4_W um x ^M3_DN_4_W um neighboring checking windows including DM3EXCL <= ^M3_DN_4
  DENSITY M3x CHIP <=1 WINDOW M3_DN_4_W BACKUP GRADIENT > M3_DN_4 ABSOLUTE CORNER PRINT M3.DN.4.density
  	[ AREA(M3x)/AREA(CHIP) ]     
}



// Mx.DN.5
//===========
M3_CORE = M3x NOT SRCSR


		

M1.DN.5 { @ It is not allowed to have local density > ^Mx_DN_5 of all 3 consecutive metal (M1,M2,M3) over any ^Mx_DN_5_W um x ^Mx_DN_5_W um window (stepping ^Mx_DN_5_S um)

    DENSITY  M1_CORE M2_CORE M3_CORE >0 WINDOW Mx_DN_5_W STEP Mx_DN_5_S BACKUP 
  	  [ !~(AREA(M1_CORE)/AREA()-Mx_DN_5)*!~(AREA(M2_CORE)/AREA()-Mx_DN_5)*!~(AREA(M3_CORE)/AREA()-Mx_DN_5) ]
 	  RDB M1.DN.5.density

}

VARIABLE M1_DN_6 0.15

M1DN6_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M1DN6_CHECK_CBM = AREA M1DN6_CBM_MERGE >= 200 * 200

M1DN6_M1_CHECK = M1 AND M1DN6_CHECK_CBM
M1DN6_M2_CHECK = M2 AND M1DN6_CHECK_CBM
M1DN6_M3_CHECK = M3 AND M1DN6_CHECK_CBM
CONNECT M1DN6_CHECK_CBM M1DN6_M1_CHECK
CONNECT M1DN6_CHECK_CBM M1DN6_M2_CHECK
CONNECT M1DN6_CHECK_CBM M1DN6_M3_CHECK
    
M1.DN.6 { @ It is not allowed to have local density < ^M1_DN_6 of all 3 consecutive metal (M1,M2,M3) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M1DN6_M1_CHECK M1DN6_CHECK_CBM < M1_DN_6
        [AREA(M1DN6_M1_CHECK)/AREA(M1DN6_CHECK_CBM)]
        RDB M1.DN.6.M1.density
    B = NET AREA RATIO M1DN6_M2_CHECK M1DN6_CHECK_CBM < M1_DN_6
        [AREA(M1DN6_M2_CHECK)/AREA(M1DN6_CHECK_CBM)]
        RDB M1.DN.6.M2.density
    C = NET AREA RATIO M1DN6_M3_CHECK M1DN6_CHECK_CBM < M1_DN_6
        [AREA(M1DN6_M3_CHECK)/AREA(M1DN6_CHECK_CBM)]
        RDB M1.DN.6.M3.density
    (A AND B) AND C
}


//VIA3 CHECKS
//===========

M4Wide_first = (SIZE M4 BY M4_S_2_W /2 UNDEROVER TRUNCATE M4_S_2_W /2) AND M4 
M4Wide_0.4 = (SIZE M4Wide_first BY M4_S_2_1_W /2 UNDEROVER TRUNCATE M4_S_2_1_W /2) AND M4Wide_first
#IFDEF HALF_NODE
M4Wide_0.2 = (SIZE M4 BY M4_S_2_2_W /2 UNDEROVER TRUNCATE M4_S_2_2_W /2) AND M4
M4Wide_0.4S = (SIZE M4Wide_first BY M4_S_2_3_W /2 UNDEROVER TRUNCATE M4_S_2_3_W /2) AND M4Wide_first
#ENDIF
M4Wide_1.5 = (SIZE M4Wide_first BY M4_S_3_W /2 UNDEROVER TRUNCATE M4_S_3_W /2) AND M4Wide_first
M4Wide_4.5 = (SIZE M4Wide_1.5 BY M4_S_4_W /2 UNDEROVER TRUNCATE M4_S_4_W /2) AND M4Wide_1.5

M3Wide_0.42_VIA3 = (SIZE M3Wide_first BY VIA3_R_2_W /2 UNDEROVER TRUNCATE VIA3_R_2_W /2) AND M3Wide_first 
M3Wide_0.7_VIA3 = (SIZE M3Wide_0.42_VIA3 BY VIA3_R_4_W /2 UNDEROVER TRUNCATE VIA3_R_4_W /2) AND M3Wide_0.42_VIA3
M3Wide_0.98_VIA3 = (SIZE M3Wide_0.7_VIA3 BY VIA3_R_3_W /2 UNDEROVER TRUNCATE VIA3_R_3_W /2) AND M3Wide_0.7_VIA3
M3Wide_2_VIA3 = (SIZE M3Wide_0.98_VIA3 BY VIA3_R_5_W /2 UNDEROVER TRUNCATE VIA3_R_5_W /2) AND M3Wide_0.98_VIA3
M3Wide_3_VIA3 = (SIZE M3Wide_2_VIA3 BY VIA3_R_6_W /2 UNDEROVER TRUNCATE VIA3_R_6_W /2) AND M3Wide_2_VIA3
M4Wide_0.42_VIA3 = (SIZE M4Wide_first BY VIA3_R_2_W /2 UNDEROVER TRUNCATE VIA3_R_2_W /2) AND M4Wide_first 
M4Wide_0.7_VIA3 = (SIZE M4Wide_0.42_VIA3 BY VIA3_R_4_W /2 UNDEROVER TRUNCATE VIA3_R_4_W /2) AND M4Wide_0.42_VIA3
M4Wide_0.98_VIA3 = (SIZE M4Wide_0.7_VIA3 BY VIA3_R_3_W /2 UNDEROVER TRUNCATE VIA3_R_3_W /2) AND M4Wide_0.7_VIA3 
M4Wide_2_VIA3 = (SIZE M4Wide_0.98_VIA3 BY VIA3_R_5_W /2 UNDEROVER TRUNCATE VIA3_R_5_W /2) AND M4Wide_0.98_VIA3
M4Wide_3_VIA3 = (SIZE M4Wide_2_VIA3 BY VIA3_R_6_W /2 UNDEROVER TRUNCATE VIA3_R_6_W /2) AND M4Wide_2_VIA3 


VIA3.W.1 { @ Width (maximum = minimum except for seal-ring and fuse protection ring) = ^VIA3_W_1
@ VIA3.R.1 45-degree rotated VIA is not allowed     
  A = NOT RECTANGLE VIA3 == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
VIA3.W.2 { @ VIA3 bar width = ^VIA3_W_2 (VIA3 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring) 
  INT VIA3_BAR < VIA3_W_2 ABUT < 90 OPPOSITE REGION
  A = VIA3_BAR WITH WIDTH > VIA3_W_2
  B = ANGLE VIA3_BAR == 45
  C = INT B < VIA3_W_2 + 2*GRID REGION
  D = A NOT C
  ENCLOSE RECTANGLE D 1 0.005

}
VIA3.S.1 { @ Space >= 0.10 
  EXT VIA3 < VIA3_S_1 ABUT < 90 SINGULAR REGION
}

VIA3.S.2 { @ Space to 3-neighboring VIAx (< 0.14 um distance) >= 0.13 
  X = WITH NEIGHBOR VIA3 > 2 SPACE < VIA3_S_2_S
  EXT X VIA3 < VIA3_S_2 ABUT < 90 SINGULAR REGION
}

VIA3.S.3 { @ Space to neighboring VIAx [different net and common parallel run length > 0] >= 0.13 
  VIA3_NODAL = STAMP VIA3 BY VIA3i
  EXT VIA3_NODAL < VIA3_S_3 ABUT < 90 NOT CONNECTED OPPOSITE REGION
}


VIA3.EN.1 { @ Enclosure by Mx or M1 >= 0.00 
  VIA3 NOT M3
}

VIA3.EN.2_VIA3.EN.3 { @ Enclosure by M3 [at least two opposite sides] >= ^VIA3_EN_2 , or [all sides] >= ^VIA3_EN_3
  X = RECTANGLE ENCLOSURE VIA3 M3 ABUT < 90 SINGULAR GOOD 0 VIA3_EN_2 OPPOSITE 0 VIA3_EN_2 OPPOSITE
  ENC X M3 < VIA3_EN_3 ABUT < 90 SINGULAR REGION
}



#IFDEF HALF_NODE 
VARIABLE VIA3_R_2_S2_S1  (VIA3_R_2_S2 - VIA3_R_2_S1 - OFFSETX)/2
#ELSE
VARIABLE VIA3_R_2_S2_S1  (VIA3_R_2_S2 - VIA3_R_2_S1)/2
#ENDIF

// VIA3.R.1 is checked by VIA3.W.1
VIA3.R.2_VIA3.R.3 { @ When M3 or M4 width > ^VIA3_R_2_W um, more than one VIA3 is required.
                    @ 2 vias spacing should be <= ^VIA3_R_2_S1 um or 4 vias spacing should be <= ^VIA3_R_2_S2 um
  		    @ When M3 or M4 width > ^VIA3_R_3_W um, more than three VIA3 is required.
                    @ 4 vias spacing should be <= ^VIA3_R_3_S1 um or 9 vias spacing should be <= ^VIA3_R_3_S2 um
   M4OvpM3_W_ = (M3Wide_0.42_VIA3 AND M4) OR (M4Wide_0.42_VIA3 AND M3)
   M4OvpM3_B  = (M3Wide_0.98_VIA3 AND M4) OR (M4Wide_0.98_VIA3 AND M3)
   M4OvpM3_W  = M4OvpM3_W_ NOT M4OvpM3_B 
   Checked_VIA3_W_ = VIA3_EXD NOT OUTSIDE M4OvpM3_W
   Checked_VIA3_B  = VIA3_EXD NOT OUTSIDE M4OvpM3_B
   Checked_VIA3_W  = Checked_VIA3_W_ NOT Checked_VIA3_B
   M3_effect = M3i INTERACT M4OvpM3_W_
   M4_effect = M4i INTERACT M4OvpM3_W_
   effect_M4OvpM3_ = M3_effect AND M4_effect
   effect_M4OvpM3 = effect_M4OvpM3_ INTERACT M4OvpM3_W_
   effect_VIA = VIA3_EXD INTERACT effect_M4OvpM3

   V3Merged_A = SIZE effect_VIA BY VIA3_R_2_S1/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_B = SIZE V3Merged_A BY VIA3_R_2_S2_S1 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_C = SIZE V3Merged_B BY (VIA3_R_3_S2 - VIA3_R_2_S2)/2 INSIDE OF effect_M4OvpM3 STEP M3_S_1*0.7
   V3Merged_A2R = V3Merged_A INTERACT effect_VIA < 2
   V3Merged_A2 = V3Merged_A OUTSIDE V3Merged_A2R
   V3Merged_A4R = V3Merged_A2 INTERACT effect_VIA < 4
   V3Merged_A4 = V3Merged_A2 OUTSIDE V3Merged_A4R
   V3Merged_B4R = V3Merged_B INTERACT effect_VIA < 4
   V3Merged_B4 = V3Merged_B OUTSIDE V3Merged_B4R
   V3Merged_C9R = V3Merged_C INTERACT effect_VIA < 9
   V3Merged_C9 = V3Merged_C OUTSIDE V3Merged_C9R

   GMergeW = V3Merged_A2 OR V3Merged_B4
   GMergeB = V3Merged_A4 OR V3Merged_C9
   GVIA_W = Checked_VIA3_W INTERACT GMergeW
   GVIA_B = Checked_VIA3_B INTERACT GMergeB
   GOOD_AREA_W = M4OvpM3_W INTERACT GVIA_W
   GOOD_AREA_B = M4OvpM3_B INTERACT GVIA_B
   Checked_VIA3_W OUTSIDE GOOD_AREA_W
   Checked_VIA3_B OUTSIDE GOOD_AREA_B
}

VIA3.R.4.M3 { @  At least two VIAx must be used for a connection that is <= ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W).)   
  Branch1 = ((SIZE M3Wide_0.7_VIA3 BY VIA3_R_4_D + GRID) NOT M3Wide_0.7_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_0.7_VIA3) INTERACT VIA3
  Branch1Edge = M3Wide_0.7_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.4.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_4_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_4_W um (L) and width > ^VIA3_R_4_W um (W).)   
  Branch1 = ((SIZE M4Wide_0.7_VIA3 BY VIA3_R_4_D + GRID) NOT M4Wide_0.7_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_0.7_VIA3) INTERACT VIA3
  Branch1Edge = M4Wide_0.7_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.5.M3 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W). It is allowed to use one VIAx for a connection that is > ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W).)  
  Branch1 = ((SIZE M3Wide_2_VIA3 BY VIA3_R_5_D + GRID) NOT M3Wide_2_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_2_VIA3) INTERACT VIA3
  Branch1Edge = M3Wide_2_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

VIA3.R.5.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W). It is allowed to use one VIAx for a connection that is > ^VIA3_R_5_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_5_W um (L) and width > ^VIA3_R_5_W um (W).)  
  Branch1 = ((SIZE M4Wide_2_VIA3 BY VIA3_R_5_D + GRID) NOT M4Wide_2_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_2_VIA3) INTERACT VIA3
  Branch1Edge = M4Wide_2_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M3Big_3_VIA3 = ENCLOSE RECTANGLE M3Wide_3_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID

VIA3.R.6.M3 { @  At least two VIAx must be used for a connection that is <= ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W)).
  Branch1 = ((SIZE M3Big_3_VIA3 BY VIA3_R_6_D + GRID) NOT M3Big_3_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_3_VIA3) INTERACT VIA3
  Branch1Edge = M3Big_3_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M4Big_3_VIA3 = ENCLOSE RECTANGLE M4Wide_3_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID

VIA3.R.6.M4 { @ At least two VIAx must be used for a connection that is <= ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length > ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W). (It is allowed to use one VIAx for a connection that is > ^VIA3_R_6_D um (D) away from a metal plate (either Mx or Mx+1) with length> ^VIA3_R_6_L um (L) and width > ^VIA3_R_6_W um (W)).
  Branch1 = ((SIZE M4Big_3_VIA3 BY VIA3_R_6_D + GRID) NOT M4Big_3_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_3_VIA3) INTERACT VIA3
  Branch1Edge = M4Big_3_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}
// VIA3.R.7 is checked by VIA3.EN.1 and M4.EN.1
// VIA3.R.9 can't be checked


VIA3.R.11{@ Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= ^VIA3_R_11_A um2 and two metal hole length(L2) <= ^VIA3_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 
@ 3. The length (L) of the center metal bar <= ^VIA3_R_11_L um and the width of metal bar is <= ^VIA3_R_11_W um. 
  W = M4i WITH WIDTH <= VIA3_R_11_W   
  H_HOLE = HOLES M4i INNER <= VIA3_R_11_A
  A = M4i COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA3_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M4i) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA3_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE M4i) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA3_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA3_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA3_R_11_L+GRID
  CENTER_BAR2 = CENTER_BAR1 INTERACT H_HOLE == 2
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] M4i <= VIA3_R_11_L2 OPPOSITE
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA3i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((M4i INTERACT CHECK_VIA) AND (M3i INTERACT CHECK_VIA)) INTERACT VIA3i == 1)
}


//M4 CHECKS
//=========

M41 = M4Wide_first NOT CB_NON_CUP
M411 = M4Wide_0.4 NOT CB_NON_CUP
#IFDEF HALF_NODE  
M412 = M4Wide_0.2 NOT CB_NON_CUP
M413 = M4Wide_0.4S NOT CB_NON_CUP
#ENDIF
M42 = M4Wide_1.5 NOT CB_NON_CUP
M43 = M4Wide_4.5 NOT CB_NON_CUP

M4AS3 = AREA M4 > M4_S_3_L*M4_W_1  // filter small metal for M4.S.3
M4AS4 = AREA M4AS3 > M4_S_4_L*M4_W_1  // filter small metal for M4.S.4

M4_EDGE_45 = M4 ANGLE == 45

M4.W.1 { @ Width >= 0.10 
  INT M4 < M4_W_1 ABUT < 90 SINGULAR REGION
}
M4.W.2 { @ Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid (refer to the guideline, G.6gU, in section 3.7) >= 0.19 
  INT M4_EDGE_45 < M4_W_2 ABUT < 90 REGION
}
M4.W.3 { @ Maximum width <= 12.00 
  SIZE M4 BY M4_W_3 /2 UNDEROVER TRUNCATE M4_W_3 /2
}
M4.S.1 { @ Space >= 0.10 
  EXT M4 < M4_S_1 ABUT < 90 SINGULAR REGION
}

M4.S.2 { @ Space [at least one metal line width > ^M4_S_2_W um  and the parallel metal run length > ^M4_S_2_L um ] (union projection) >= ^M4_S_2
  X = EXT M41 M4 < M4_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_L+GRID
}

M4.S.2.1 { @ Space [at least one metal line width > ^M4_S_2_1_W um  and the parallel metal run length > ^M4_S_2_1_L um ] (union projection) >= ^M4_S_2_1
  X = EXT M411 M4 < M4_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_1_L+GRID
}

#IFDEF HALF_NODE
M4.S.2.2 { @  Space [at least one metal line width > ^M4_S_2_2_W um  and the parallel metal run length > ^M4_S_2_2_L um ] (union projection) >= ^M4_S_2_2
  X = EXT M412 M4 < M4_S_2_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_2_L+GRID
}
M4.S.2.3 { @ Space [at least one metal line width > ^M4_S_2_3_W um  and the parallel metal run length > ^M4_S_2_3_L um ] (union projection) >= ^M4_S_2_3
  X = EXT M413 M4 < M4_S_2_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_3_L+GRID
}
#ENDIF

M4.S.3 { @ Space [at least one metal line width > ^M4_S_3_W um  and the parallel metal run length > ^M4_S_3_L um ] (union projection) >= ^M4_S_3
  X = EXT M42 M4AS3 < M4_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_3_L+GRID
}

M4.S.4 { @ Space [at least one metal line width > ^M4_S_4_W um  and the parallel metal run length > ^M4_S_4_L um ] (union projection) >= ^M4_S_4
  X = EXT M43 M4AS4 < M4_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_4_L+GRID
}

M4.S.5 { @ Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= 0.12 
  A = CONVEX EDGE M4 ANGLE1 == 90 ANGLE2 == 90 WITH LENGTH < M4_S_5_Q
  B = EXT [A] M4 < M4_S_5 ABUT < 90 OPPOSITE EXTENDED M4_S_5_E
  C = A TOUCH INSIDE EDGE B
  D = INT C [M4] < M4_S_5_Q ABUT == 90 INTERSECTING ONLY
  I = LENGTH D >= M4_W_1
  J = EXPAND EDGE I INSIDE BY 0.001 EXTEND BY M4_S_5_E
  K = EXPAND EDGE I INSIDE BY 0.001 
  L = J NOT K
  M = L WITH EDGE A 
  N = M OR K
  O = N TOUCH EDGE I
  EXT O M4 < M4_S_5 ABUT < 90 OPPOSITE REGION

}
M4.EN.1 { @ Enclosure of VIAx-1 >= 0.00 
  VIA3 NOT M4
}


M4.EN.2_M4.EN.3 { @ Enclosure of VIA3 [at least two opposite sides] >= ^M4_EN_2 ,or [all sides] >= ^M4_EN_3  
  X = RECTANGLE ENCLOSURE VIA3 M4 ABUT < 90 SINGULAR GOOD 0 M4_EN_2 OPPOSITE 0 M4_EN_2 OPPOSITE
  ENC X M4 < M4_EN_3 ABUT < 90 SINGULAR REGION
}



M4.A.1 { @ Area >= 0.052 
  AREA M4 < M4_A_1
}

VARIABLE M4_A_2pre ((M4_A_2 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))*((M4_A_2 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))/3.141
M4.A.2 { @ Enclosed area >= 0.20 
   X = HOLES M4 INNER < M4_A_2pre
   AREA ( X NOT M4 ) < M4_A_2
}

M4.S.6 { @ Space to 45-degree bent Mx >= 0.19 
  X = EXPAND EDGE M4_EDGE_45 OUTSIDE BY M4_S_6
  X AND M4
}



// M4.R.1 can not be checked


M4DN1H_EXC = COPY M4_EXC
M4DN1L_EXC = COPY M4_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
M4.DN.1L { @ M4 local density must be >= ^M4_DN_1L range over ^M4_DN_1L_W um x ^M4_DN_1L_W um step ^M4_DN_1L_S um
  M4_CHECK = M4x NOT M4DN1L_EXC
  CHIP_CHECK = CHIP NOT M4DN1L_EXC
  ERR_WIN = DENSITY M4_CHECK CHIP_CHECK < M4_DN_1L WINDOW M4_DN_1L_W STEP M4_DN_1L_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M4DN1L_EXC) >= M4_DN_1L_E
  DENSITY F M4_CHECK CHIP_CHECK < M4_DN_1L WINDOW M4_DN_1L_W STEP M4_DN_1L_S INSIDE OF LAYER CHIPx BACKUP PRINT M4.DN.1L.density
         [ !AREA(F)+AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M4.DN.1H { @ M4 local density must be <= ^M4_DN_1H range over ^M4_DN_1H_W um x ^M4_DN_1H_W um step ^M4_DN_1H_S um
  M4_CHECK = M4x NOT M4DN1H_EXC
  CHIP_CHECK = CHIP NOT M4DN1H_EXC
  ERR_WIN = DENSITY M4_CHECK CHIP_CHECK > M4_DN_1H WINDOW M4_DN_1H_W STEP M4_DN_1H_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M4DN1H_EXC) >= M4_DN_1H_E
  DENSITY F M4_CHECK CHIP_CHECK > M4_DN_1H WINDOW M4_DN_1H_W STEP M4_DN_1H_S INSIDE OF LAYER CHIPx BACKUP PRINT M4.DN.1H.density
         [ !!AREA(F)*AREA(M4_CHECK)/AREA(CHIP_CHECK) ]
}

M4DN2_EXC = COPY EMPTYi


M4.DN.2 { @ M4 local density must be <= ^M4_DN_2 range over ^M4_DN_2_W um x ^M4_DN_2_W um step ^M4_DN_2_S um
  M4_CHECK = M4x NOT M4DN2_EXC
  ERR_WIN = DENSITY M4_CHECK CHIP > M4_DN_2 WINDOW M4_DN_2_W STEP M4_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(M4_CHECK)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT M4DN2_EXC) >= M4_DN_2_E
  DENSITY F M4_CHECK CHIP > M4_DN_2 WINDOW M4_DN_2_W STEP M4_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT M4.DN.2.density 
          [ !!AREA(F)*AREA(M4_CHECK)/AREA(CHIP) ]
}

M4.DN.4 { @ The metal density difference between any two ^M4_DN_4_W um x ^M4_DN_4_W um neighboring checking windows including DM4EXCL <= ^M4_DN_4
  DENSITY M4x CHIP <=1 WINDOW M4_DN_4_W BACKUP GRADIENT > M4_DN_4 ABSOLUTE CORNER PRINT M4.DN.4.density
  	[ AREA(M4x)/AREA(CHIP) ]     
}



// Mx.DN.5
//===========
M4_CORE = M4x NOT SRCSR


		

M2.DN.5 { @ It is not allowed to have local density > ^Mx_DN_5 of all 3 consecutive metal (M2,M3,M4) over any ^Mx_DN_5_W um x ^Mx_DN_5_W um window (stepping ^Mx_DN_5_S um)

    DENSITY  M2_CORE M3_CORE M4_CORE >0 WINDOW Mx_DN_5_W STEP Mx_DN_5_S BACKUP 
  	  [ !~(AREA(M2_CORE)/AREA()-Mx_DN_5)*!~(AREA(M3_CORE)/AREA()-Mx_DN_5)*!~(AREA(M4_CORE)/AREA()-Mx_DN_5) ]
 	  RDB M2.DN.5.density

}

VARIABLE M2_DN_6 0.15

M2DN6_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M2DN6_CHECK_CBM = AREA M2DN6_CBM_MERGE >= 200 * 200

M2DN6_M2_CHECK = M2 AND M2DN6_CHECK_CBM
M2DN6_M3_CHECK = M3 AND M2DN6_CHECK_CBM
M2DN6_M4_CHECK = M4 AND M2DN6_CHECK_CBM
CONNECT M2DN6_CHECK_CBM M2DN6_M2_CHECK
CONNECT M2DN6_CHECK_CBM M2DN6_M3_CHECK
CONNECT M2DN6_CHECK_CBM M2DN6_M4_CHECK
    
M2.DN.6 { @ It is not allowed to have local density < ^M2_DN_6 of all 3 consecutive metal (M2,M3,M4) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M2DN6_M2_CHECK M2DN6_CHECK_CBM < M2_DN_6
        [AREA(M2DN6_M2_CHECK)/AREA(M2DN6_CHECK_CBM)]
        RDB M2.DN.6.M2.density
    B = NET AREA RATIO M2DN6_M3_CHECK M2DN6_CHECK_CBM < M2_DN_6
        [AREA(M2DN6_M3_CHECK)/AREA(M2DN6_CHECK_CBM)]
        RDB M2.DN.6.M3.density
    C = NET AREA RATIO M2DN6_M4_CHECK M2DN6_CHECK_CBM < M2_DN_6
        [AREA(M2DN6_M4_CHECK)/AREA(M2DN6_CHECK_CBM)]
        RDB M2.DN.6.M4.density
    (A AND B) AND C
}


//VIA4 CHECKS
//===========

VIA4.W.1 { @ Width (maximum = minimum except for seal-ring and fuse protection ring) = ^VIA4_W_1
@ VIA4.R.1 45-degree rotated VIA is not allowed
  A = NOT RECTANGLE VIA4 == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}

VIA4.W.2 { @ VIA4 bar width = ^VIA4_W_2 (VIA4 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)
  INT VIA4_BAR < VIA4_W_2 ABUT < 90 OPPOSITE REGION
  A = VIA4_BAR WITH WIDTH > VIA4_W_2
  B = ANGLE VIA4_BAR == 45
  C = INT B < VIA4_W_2 + GRID REGION
  D = A NOT C
  ENCLOSE RECTANGLE D 2 0.005
}

VIA4.S.1 { @  Space >= ^VIA4_S_1 um
  EXT VIA4 < VIA4_S_1 ABUT < 90 SINGULAR REGION
}

VIA4.S.2 { @ Space to 3-neighboring VIAz (<0.56 um distance) >= 0.54 
  X = WITH NEIGHBOR VIA4 > 2 SPACE < VIA4_S_2_S
  EXT X VIA4 < VIA4_S_2 ABUT < 90 SINGULAR REGION
}



VIA4.EN.1 { @ Enclosure by M4 >= ^VIA4_EN_1
  ENC VIA4 M4 < VIA4_EN_1 ABUT < 90 SINGULAR REGION
  (VIA4 NOT M4) NOT CBM
}

VIA4.EN.2 { @ Enclosure by M4 [at least two opposite sides] >= ^VIA4_EN_2 
  X = RECTANGLE ENCLOSURE VIA4 M4 ABUT < 90 SINGULAR GOOD VIA4_EN_1 VIA4_EN_2 OPPOSITE VIA4_EN_1 VIA4_EN_2 OPPOSITE
  Y = ENC [X] M4 < VIA4_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA4_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}



// VIA4.R.1 is checked by VIA4.W.1

M5Wide_1.8_VIA4T = (SIZE M5 BY VIA4_R_2_W /2 UNDEROVER TRUNCATE VIA4_R_2_W /2) AND M5
M4Wide_1.8_VIA4T = (SIZE M4 BY VIA4_R_2_W /2 UNDEROVER TRUNCATE VIA4_R_2_W /2) AND M4
M5Wide_3_VIA4T = (SIZE M5Wide_1.8_VIA4T BY VIA4_R_3_W /2 UNDEROVER TRUNCATE VIA4_R_3_W /2) AND M5Wide_1.8_VIA4T
M4Wide_3_VIA4T = (SIZE M4Wide_1.8_VIA4T BY VIA4_R_3_W /2 UNDEROVER TRUNCATE VIA4_R_3_W /2) AND M4Wide_1.8_VIA4T

VIA4.R.2 { @ At least two VIA4 with spacing <= ^VIA4_R_2_S um are required to connect M4 and M5 when one of these metals has a width and length > ^VIA4_R_2_W um.   
   M5OvpM4W = (M5 AND M4Wide_1.8_VIA4T) OR (M4 AND M5Wide_1.8_VIA4T)
   Checked_VIA4 = VIA4_EXD NOT OUTSIDE M5OvpM4W
   M4_effect = M4i INTERACT M5OvpM4W
   M5_effect = M5i INTERACT M5OvpM4W
   effect_M5OvpM4_ = M4_effect AND M5_effect
   effect_M5OvpM4 = effect_M5OvpM4_ INTERACT M5OvpM4W
   Effect_VIA4 = VIA4_EXD INTERACT effect_M5OvpM4
   VIA4Merged = SIZE Effect_VIA4 BY VIA4_R_2_S /2 INSIDE OF effect_M5OvpM4 STEP M4_S_1*0.7
   VIA4Merged2 = VIA4Merged ENCLOSE Effect_VIA4 >=2
   GVIA = Checked_VIA4 INTERACT VIA4Merged2
   GM5OvpM4W = M5OvpM4W INTERACT GVIA
   Checked_VIA4 OUTSIDE GM5OvpM4W
}   

M4Big_3_VIA4T = ENCLOSE RECTANGLE M4Wide_3_VIA4T VIA4_R_3_W VIA4_R_3_L+GRID

VIA4.R.3.M4 { @  At least two VIA4 must be used for a connection that is <= ^VIA4_R_3_D um (D) away from a metal plate (either M4 or M5) with length > ^VIA4_R_3_L um (L) and width > ^VIA4_R_3_W um (W). (It is allowed to use one VIA4 for a connection that is > ^VIA4_R_3_D um (D) away from a metal plate (either M4 or M5) with length> ^VIA4_R_3_L um (L) and width > ^VIA4_R_3_W um (W)).   
  Branch1 = ((SIZE M4Big_3_VIA4T BY VIA4_R_3_D + GRID) NOT M4Big_3_VIA4T) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_3_VIA4T) INTERACT VIA4
  Branch1Edge = M4Big_3_VIA4T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_3_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M5Big_3_VIA4T = ENCLOSE RECTANGLE M5Wide_3_VIA4T VIA4_R_3_W VIA4_R_3_L+GRID

VIA4.R.3.M5 { @ At least two VIA4 must be used for a connection that is <= ^VIA4_R_3_D um (D) away from a metal plate (either M4 or M5) with length > ^VIA4_R_3_L um (L) and width > ^VIA4_R_3_W um (W). (It is allowed to use one VIA4 for a connection that is > ^VIA4_R_3_D um (D) away from a metal plate (either M4 or M5) with length> ^VIA4_R_3_L um (L) and width > ^VIA4_R_3_W um (W)).
  Branch1 = ((SIZE M5Big_3_VIA4T BY VIA4_R_3_D + GRID) NOT M5Big_3_VIA4T) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_3_VIA4T) INTERACT VIA4
  Branch1Edge = M5Big_3_VIA4T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_3_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

// VIA4.R.4 is checked by VIA4.EN.1 and M5.EN.1 
// VIA4.R.5 can not be checked.



VCAP = COPY VIA4
MCAP = COPY M5
MCAPx = COPY M5x       
MBOT = COPY M4        //Mcap-1
MBOTx = COPY M4x       

VCAP_CTMDMY = VCAP AND CTMDMY
VCAP_ICTMDMY = VCAP INSIDE CTMDMY
MCAP_CTMDMY = MCAP AND CTMDMY
MCAPx_CTMDMY = MCAPx AND CTMDMY
MBOT_ICTMDMY = MBOT NOT OUTSIDE CTMDMY
MBOTx_ICTMDMY = MBOTx NOT OUTSIDE CTMDMY
MCAP_ICTMDMY = MCAP NOT OUTSIDE CTMDMY
MCAPx_ICTMDMY = MCAPx NOT OUTSIDE CTMDMY

VCAP_CTM = VCAP AND CTM
VCAP_CBM = (VCAP AND CBM) NOT CTM

VIA4.EN.3 { @ Enclosure by CTM (cut is not allowed) >= ^VIA4_EN_3
  ENC VCAP_CTM CTM < VIA4_EN_3 ABUT<90 SINGULAR REGION
  CUT VCAP CTM    
}

VIA4.EN.4 { @ Enclosure by CBM (cut is not allowed) >= ^VIA4_EN_4 
  ENC VCAP_CBM CBM < VIA4_EN_4 ABUT<90 SINGULAR REGION
  CUT VCAP CBM 
}

VIA4.S.3{ @ [VIA4 inside CBM but outside CTM] space to CTM >= ^VIA4_S_3  
  EXT CTM VCAP_CBM < VIA4_S_3 ABUT<90 SINGULAR REGION
}

VIA4.S.4 { @ Space of VIA4 inside CTM  >= ^VIA4_S_4
  EXT VCAP_CTM < VIA4_S_4 ABUT<90 SINGULAR REGION
}

VIA4.S.5 { @ Space of VIA4 inside CBM >= ^VIA4_S_5
  EXT VCAP_CBM < VIA4_S_5 ABUT<90 SINGULAR REGION
}

//VIA4.R.6g is un-checkable.

VIA4.R.7 { @ Single VIA4 for in a CTM or [CBM NOT CTM] or connect to [M4 (top Mx) layer inside a CTMDMY] is not allowed.
  CTM ENCLOSE VCAP == 1
  CBM ENCLOSE VCAP_CBM == 1
  (MCAP AND CTM) ENCLOSE VCAP == 1
  (MCAP AND CBM) ENCLOSE VCAP_CBM == 1
  A = (MCAP_ICTMDMY AND MBOT_ICTMDMY) ENCLOSE VCAP == 1
  VCAP_ICTMDMY INTERACT A
}  



//M5 CHECKS
//=============

M5Wide_1.5 = (SIZE M5 BY M5_S_2_W /2 UNDEROVER TRUNCATE M5_S_2_W /2) AND M5
M5Wide_4.5 = (SIZE M5Wide_1.5 BY M5_S_3_W /2 UNDEROVER TRUNCATE M5_S_3_W /2) AND M5Wide_1.5

M51 = M5Wide_1.5 NOT CB
M52 = M5Wide_4.5 NOT CB


M5nAS2 = AREA M5 > M5_S_2_L*M5_W_1  // filter small metal for M5.S.2
M5nAS3 = AREA M5nAS2 > M5_S_3_L*M5_W_1  // filter small metal for M5.S.3

M5.W.1 { @ Width >= ^M5_W_1
  INT M5 < M5_W_1 ABUT < 90 SINGULAR REGION
}
M5.W.2 { @ Maximum width [except bond pad] <= 12.00 
  SIZE M5_MAX_WIDTH BY M5_W_2 /2 UNDEROVER TRUNCATE M5_W_2 /2
}
M5.S.1 { @ Space >= ^M5_S_1
  EXT M5 < M5_S_1 ABUT < 90 SINGULAR REGION
}
M5.S.2 { @  Space [at least one metal line width > ^M5_S_2_W um (W1) and the parallel metal run length > ^M5_S_2_L um (L1)] >= ^M5_S_2
  X = EXT M51 M5nAS2 < M5_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_L+GRID
}
M5.S.3 { @ Space [at least one metal line width > ^M5_S_3_W um (W1) and the parallel metal run length > ^M5_S_3_L um (L1)] >= ^M5_S_3
  X = EXT M52 M5nAS3 < M5_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_3_L+GRID
}
M5.EN.1 { @ Enclosure of VIA4 >= ^M5_EN_1
  ENC VIA4 M5 < M5_EN_1 ABUT < 90 SINGULAR REGION
  VIA4 NOT M5
}
M5.EN.2 { @ Enclosure of VIA4 [at least two opposite sides] >= ^M5_EN_2
  X = RECTANGLE ENCLOSURE VIA4 M5 ABUT < 90 SINGULAR GOOD M5_EN_1 M5_EN_2 OPPOSITE M5_EN_1 M5_EN_2 OPPOSITE
  Y = ENC [X] M5 < M5_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA4_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
M5.A.1 { @ Area >= ^M5_A_1
  AREA M5 < M5_A_1
}

VARIABLE M5_A_2pre ((M5_A_2 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))*((M5_A_2 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))/3.141
M5.A.2 { @ Enclosed area >= ^M5_A_2
  X = HOLES M5 INNER < M5_A_2pre
  AREA ( X NOT M5 ) < M5_A_2
}


M5DN1H_EXC =  M5_EXC OR WBDMY
M5DN1L_EXC = COPY M5_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
M5.DN.1L { @ M5 local density must be >= ^M5_DN_1L range over ^M5_DN_1L_W um x ^M5_DN_1L_W um step ^M5_DN_1L_S um
  M5_CHECK = M5x NOT M5DN1L_EXC
  CHIP_CHECK = CHIP NOT M5DN1L_EXC
  ERR_WIN = DENSITY M5_CHECK CHIP_CHECK < M5_DN_1L WINDOW M5_DN_1L_W STEP M5_DN_1L_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M5DN1L_EXC) >= M5_DN_1L_E
  DENSITY F M5_CHECK CHIP_CHECK < M5_DN_1L WINDOW M5_DN_1L_W STEP M5_DN_1L_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.1L.density
         [ !AREA(F)+AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M5.DN.1H { @ M5 local density must be <= ^M5_DN_1H range over ^M5_DN_1H_W um x ^M5_DN_1H_W um step ^M5_DN_1H_S um
  M5_CHECK = M5x NOT M5DN1H_EXC
  CHIP_CHECK = CHIP NOT M5DN1H_EXC
  ERR_WIN = DENSITY M5_CHECK CHIP_CHECK > M5_DN_1H WINDOW M5_DN_1H_W STEP M5_DN_1H_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M5DN1H_EXC) >= M5_DN_1H_E
  DENSITY F M5_CHECK CHIP_CHECK > M5_DN_1H WINDOW M5_DN_1H_W STEP M5_DN_1H_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.1H.density
         [ !!AREA(F)*AREA(M5_CHECK)/AREA(CHIP_CHECK) ]
}

M5DN2_EXC = WBDMY OR IND_EXD

M5.DN.2 { @ M5 local density must be <= ^M5_DN_2 range over ^M5_DN_2_W um x ^M5_DN_2_W um step ^M5_DN_2_S um
  M5_CHECK = M5x NOT M5DN2_EXC
  ERR_WIN = DENSITY M5_CHECK CHIP > M5_DN_2 WINDOW M5_DN_2_W STEP M5_DN_2_S INSIDE OF LAYER CHIPx BACKUP
          [ AREA(M5_CHECK)/AREA(CHIP) ]
  F = WITH WIDTH (ERR_WIN NOT M5DN2_EXC) >= M5_DN_2_E
  DENSITY F M5_CHECK CHIP > M5_DN_2 WINDOW M5_DN_2_W STEP M5_DN_2_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.2.density 
          [ !!AREA(F)*AREA(M5_CHECK)/AREA(CHIP) ]
}

M5.DN.4 { @ The metal density difference between any two ^M5_DN_4_W um x ^M5_DN_4_W um neighboring checking windows including DM5EXCL <= ^M5_DN_4
  DENSITY M5x CHIP <=1 WINDOW M5_DN_4_W BACKUP GRADIENT > M5_DN_4 ABSOLUTE CORNER PRINT M5.DN.4.density
  	[ AREA(M5x)/AREA(CHIP) ]     
}



// M5.R.1 can't be checked


M5.EN.3 { @ M5 enclosure of [VIA4 inside CTMDMY] >= ^M5_EN_3
  ENC VCAP_ICTMDMY MCAP_ICTMDMY < M5_EN_3 ABUT<90 OUTSIDE ALSO SINGULAR REGION
}

M5.DN.5L { @ M5 density inside CTMDMY over any ^M5_DN_5L_W um x ^M5_DN_5L_W um area (checked by stepping in ^M5_DN_5L_S um increments) [the overlapped area of checking window and CTMDMY >= ^M5_DN_5L_E um2] >= ^M5_DN_5L 
    DENSITY MCAPx_CTMDMY CTMDMY < M5_DN_5L WINDOW M5_DN_5L_W STEP M5_DN_5L_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.5L.density
    [ ~(AREA(CTMDMY)-M5_DN_5L_E)*!!(AREA(CTMDMY)-M5_DN_5L_E)+AREA(MCAPx_CTMDMY)/AREA(CTMDMY) ]
}

M5.DN.5H { @ M5 density inside CTMDMY over any ^M5_DN_5H_W um x ^M5_DN_5H_W um area (checked by stepping in ^M5_DN_5H_S um increments) [the overlapped area of checking window and CTMDMY >= ^M5_DN_5H_E um2] <= ^M5_DN_5H 
    DENSITY MCAPx_CTMDMY CTMDMY > M5_DN_5H WINDOW M5_DN_5H_W STEP M5_DN_5H_S INSIDE OF LAYER CHIPx BACKUP PRINT M5.DN.5H.density
    [ !(~(AREA(CTMDMY)-M5_DN_5H_E)*!!(AREA(CTMDMY)-M5_DN_5H_E))*AREA(MCAPx_CTMDMY)/AREA(CTMDMY) ]
}

M5.W.4 { @ Width of {M5 inside CTMDMY} >= ^M5_W_4
  A = INT MCAPx_ICTMDMY < M5_W_4 ABUT<90 SINGULAR REGION 
  A NOT OUTSIDE CTMDMY
}

M5.S.4 { @ Space of {M5 inside CTMDMY} >= ^M5_S_4
  A = EXT MCAPx_ICTMDMY < M5_S_4 ABUT<90 SINGULAR REGION 
  A NOT OUTSIDE CTMDMY   
}



//VIA5 CHECKS
//===========

VIA5.W.1 { @ Width (maximum = minimum except for seal-ring and fuse protection ring) = ^VIA5_W_1
@ VIA5.R.1 45-degree rotated VIA is not allowed
  A = NOT RECTANGLE VIA5 == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}

VIA5.W.2 { @ VIA5 bar width = ^VIA5_W_2 (VIA5 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)
  INT VIA5_BAR < VIA5_W_2 ABUT < 90 OPPOSITE REGION
  A = VIA5_BAR WITH WIDTH > VIA5_W_2
  B = ANGLE VIA5_BAR == 45
  C = INT B < VIA5_W_2 + GRID REGION
  D = A NOT C
  ENCLOSE RECTANGLE D 2 0.005
}

VIA5.S.1 { @  Space >= ^VIA5_S_1 um
  EXT VIA5 < VIA5_S_1 ABUT < 90 SINGULAR REGION
}

VIA5.S.2 { @ Space to 3-neighboring VIAz (<0.56 um distance) >= 0.54 
  X = WITH NEIGHBOR VIA5 > 2 SPACE < VIA5_S_2_S
  EXT X VIA5 < VIA5_S_2 ABUT < 90 SINGULAR REGION
}


//VIA5.EN.1/VIA5.EN.2 are checked by VIA5.EN.5

VIA5.EN.5 { @ VIA5(VIAu) enclosure by M5 >= ^VIA5_EN_5 um
  ENC VIA5 M5 < VIA5_EN_5 ABUT <90 SINGULAR REGION
  VIA5 NOT M5
}



// VIA5.R.1 is checked by VIA5.W.1

M6Wide_1.8_VIA5T = (SIZE M6 BY VIA5_R_2_W /2 UNDEROVER TRUNCATE VIA5_R_2_W /2) AND M6
M5Wide_1.8_VIA5T = (SIZE M5 BY VIA5_R_2_W /2 UNDEROVER TRUNCATE VIA5_R_2_W /2) AND M5
M6Wide_3_VIA5T = (SIZE M6Wide_1.8_VIA5T BY VIA5_R_3_W /2 UNDEROVER TRUNCATE VIA5_R_3_W /2) AND M6Wide_1.8_VIA5T
M5Wide_3_VIA5T = (SIZE M5Wide_1.8_VIA5T BY VIA5_R_3_W /2 UNDEROVER TRUNCATE VIA5_R_3_W /2) AND M5Wide_1.8_VIA5T

// VIA5.R.2 is checked by VIA5.R.8 

VIA5.R.8 { @ At least two VIA5(VIAu) with space <= ^VIA5_R_8_S um is required to connect M6(Mu) and M5(Mz or Mx).
  M6OvpM5 = M6 AND M5
  Check_VIA5 = VIA5_EXD INTERACT M6OvpM5
  VIA5Merge = SIZE Check_VIA5 BY VIA5_R_8_S/2 INSIDE OF M6OvpM5 STEP M5_S_1*0.7
  VIA5Merge2 = VIA5Merge ENCLOSE Check_VIA5 >= 2
  Good_VIA5 = Check_VIA5 AND VIA5Merge2
  GM6OvpM5 = M6OvpM5 INTERACT Good_VIA5
  Check_VIA5 OUTSIDE GM6OvpM5
}

M5Big_3_VIA5T = ENCLOSE RECTANGLE M5Wide_3_VIA5T VIA5_R_3_W VIA5_R_3_L+GRID

VIA5.R.3.M5 { @  At least two VIA5 must be used for a connection that is <= ^VIA5_R_3_D um (D) away from a metal plate (either M5 or M6) with length > ^VIA5_R_3_L um (L) and width > ^VIA5_R_3_W um (W). (It is allowed to use one VIA5 for a connection that is > ^VIA5_R_3_D um (D) away from a metal plate (either M5 or M6) with length> ^VIA5_R_3_L um (L) and width > ^VIA5_R_3_W um (W)).   
  Branch1 = ((SIZE M5Big_3_VIA5T BY VIA5_R_3_D + GRID) NOT M5Big_3_VIA5T) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_3_VIA5T) INTERACT VIA5
  Branch1Edge = M5Big_3_VIA5T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_3_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

M6Big_3_VIA5T = ENCLOSE RECTANGLE M6Wide_3_VIA5T VIA5_R_3_W VIA5_R_3_L+GRID

VIA5.R.3.M6 { @ At least two VIA5 must be used for a connection that is <= ^VIA5_R_3_D um (D) away from a metal plate (either M5 or M6) with length > ^VIA5_R_3_L um (L) and width > ^VIA5_R_3_W um (W). (It is allowed to use one VIA5 for a connection that is > ^VIA5_R_3_D um (D) away from a metal plate (either M5 or M6) with length> ^VIA5_R_3_L um (L) and width > ^VIA5_R_3_W um (W)).
  Branch1 = ((SIZE M6Big_3_VIA5T BY VIA5_R_3_D + GRID) NOT M6Big_3_VIA5T) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Big_3_VIA5T) INTERACT VIA5
  Branch1Edge = M6Big_3_VIA5T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_3_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD
}

// VIA5.R.4 is checked by VIA5.EN.1 and M6.EN.1 
// VIA5.R.5 can not be checked.



// Mu CHECKS
//==========


M6.W.1 { @ Width >= ^M6_W_1 um. 
  INT M6 < M6_W_1 ABUT<90 SINGULAR REGION
}

M6.W.2 { @ Maximun width [except bond pad and inductor] <= ^M6_W_2 um.
  SIZE M6_MAX_WIDTH BY M6_W_2/2 UNDEROVER TRUNCATE M6_W_2/2
}

//M6.W.3 is checked by IND.W.6

M6.S.1 { @ Space >= ^M6_S_1 um
  A = EXT M6 < M6_S_1 ABUT<90  SINGULAR REGION
  B = M6 AND CSRDMY 
  C = CONVEX EDGE B ANGLE1==270 ANGLE2==225 WITH LENGTH < M6_S_1
  D = EXT B < M6_S_1 ABUT<90  SINGULAR REGION NOTCH
  E = D WITH EDGE C
  A NOT E
}


M6.EN.1 { @ Enclosure of VIA5 >= ^M6_EN_1 um.
  ENC VIA5 M6 < M6_EN_1 ABUT<90 SINGULAR REGION
  NOT VIA5 M6
}


M6.A.1 { @ Area >= ^M6_A_1 um2.
  AREA M6 < M6_A_1
}

M6.A.2 { @ Enclosed area >= ^M6_A_2 um2 
  UTMHO = HOLES M6 INNER
  UTMHOC = UTMHO NOT M6
  AREA UTMHOC < M6_A_2
}

//M6.R.2 can not be checked.


#IFDEF FULL_CHIP

M6.DN.1L { @ M6 metal density over the whole chip >= ^M6_DN_1L 
  DENSITY M6x CHIP < M6_DN_1L INSIDE OF LAYER CHIPx PRINT M6.DN.1L.density
  [ AREA(M6x)/AREA(CHIP) ]
}

M6.DN.1H { @ M6 metal density over the whole chip <= ^M6_DN_1H  
  DENSITY M6x CHIP > M6_DN_1H INSIDE OF LAYER CHIPx PRINT M6.DN.1H.density
  [ AREA(M6x)/AREA(CHIP) ]
}

#ENDIF

M6DN2H_EXC =  M6_EXC OR MTOP_EXC
M6DN2L_EXC =  COPY M6_EXC_LOW

#IFDEF CHECK_LOW_DENSITY
M6.DN.2L { @ M6 density must be >= ^M6_DN_2L range over any ^M6_DN_2L_W um x ^M6_DN_2L_W um area by step ^M6_DN_2L_S um 
  M6_CHECK = M6x NOT M6DN2L_EXC
  CHIP_CHECK = CHIP NOT M6DN2L_EXC
  ERR_WIN = DENSITY M6_CHECK CHIP_CHECK < M6_DN_2L WINDOW M6_DN_2L_W STEP M6_DN_2L_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M6DN2L_EXC) >= M6_DN_2L_E
  DENSITY F M6_CHECK CHIP_CHECK < M6_DN_2L WINDOW M6_DN_2L_W STEP M6_DN_2L_S INSIDE OF LAYER CHIPx BACKUP PRINT M6.DN.2L.density
         [ !AREA(F)+AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
}
#ENDIF

M6.DN.2H { @ M6 density must be <= ^M6_DN_2H range over any ^M6_DN_2H_W um x ^M6_DN_2H_W um  area by step ^M6_DN_2H_S um
  M6_CHECK = M6x NOT M6DN2H_EXC
  CHIP_CHECK = CHIP NOT M6DN2H_EXC
  ERR_WIN = DENSITY M6_CHECK CHIP_CHECK > M6_DN_2H WINDOW M6_DN_2H_W STEP M6_DN_2H_S INSIDE OF LAYER CHIPx BACKUP 
	[ AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
  F = WITH WIDTH (ERR_WIN NOT M6DN2H_EXC) >= M6_DN_2H_E
  DENSITY F M6_CHECK CHIP_CHECK > M6_DN_2H WINDOW M6_DN_2H_W STEP M6_DN_2H_S INSIDE OF LAYER CHIPx BACKUP PRINT M6.DN.2H.density
         [ !!AREA(F)*AREA(M6_CHECK)/AREA(CHIP_CHECK) ]
}








//CTM CHECKS
//==========
#IFDEF HALF_NODE
CTM.R.2{@ It is prohibitive to have My, VIAy, Mr, and VIAr in your design. 
  COPY CTM
  COPY CBM     
}

CTM.R.3 { @ CTM/CBM is not allowed in N55 technology, DRC will flag CTM layer
  COPY CTM
  COPY CBM
}

#ELSE
CTM.W.1 { @ Width >= ^CTM_W_1
  INT CTM < CTM_W_1 ABUT <90 SINGULAR REGION
}

CTM.W.2 { @ Maximum length and width <= ^CTM_W_2
  ENCLOSE RECTANGLE CTM CTM_W_1 CTM_W_2+GRID ORTHOGONAL ONLY
}

CTM.S.1 { @ Space >= ^CTM_S_1
  EXT CTM < CTM_S_1 ABUT <90 SINGULAR REGION
}

CTM.EN.1 { @ Enclosure by CBM  >= ^CTM_EN_1 (CTM must be fully inside CBM)
  ENC CTM CBM < CTM_EN_1 ABUT<90 SINGULAR REGION
  CTM NOT CBM     
}  

CTM.R.1 { @ The different unit capacitance can not co-exist on same product
  X = CHIPx INTERACT CTMDMY_10
  X INTERACT CTMDMY_15
  X INTERACT CTMDMY_20
  Y = CHIPx INTERACT CTMDMY_15
  Y INTERACT CTMDMY_20
}
#ENDIF


//CBM CHECKS
//==========
#IFDEF HALF_NODE
CBM.WARN { @ N55 process does not support MIM device
  COPY CBM
}
#ELSE
CBM.W.1 { @ Width >= ^CBM_W_1
  INT CBM < CBM_W_1 ABUT <90 SINGULAR REGION
}

CBM.W.2 { @ Maximum length and width <= ^CBM_W_2 
  ENCLOSE RECTANGLE CBM CBM_W_1 CBM_W_2+GRID ORTHOGONAL ONLY
}

CBM.S.1 { @ Space (For CTMDMY area <= ^CBM_S_1_A um2) >= ^CBM_S_1
  CTMDMY_S = AREA CTMDMY <= CBM_S_1_A
  CBM_S = CBM AND CTMDMY_S
  EXT CBM_S < CBM_S_1 ABUT <90 SINGULAR REGION
}

CBM.S.2 { @ Space (For CTMDMY area > ^CBM_S_2_A um2)  >= ^CBM_S_2
  CTMDMY_W = AREA CTMDMY > CBM_S_2_A
  CBM_W = CBM AND CTMDMY_W
  EXT CBM_W < CBM_S_2 ABUT <90 SINGULAR REGION
}

CBM.S.3 { @ Space to the top Mx (M4) >= ^CBM_S_3 um.
  EXT MBOT CBM < CBM_S_3 ABUT<90 SINGULAR REGION
}

CBM.EN.2 { @ CTMDMY is equal to CBM layer sizing up ^CBM_EN_2 um for each side.
           @ DRC checking layer(CTMDMY,GDS layer 148) is needed to specify MiM capacitor region.
  A = SIZE CBM BY CBM_EN_2
  A XOR CTMDMY
  (CTMDMY INTERACT CTMDMY_10) XOR CTMDMY_10
  (CTMDMY INTERACT CTMDMY_15) XOR CTMDMY_15
  (CTMDMY INTERACT CTMDMY_20) XOR CTMDMY_20
}


CBM.R.1 { @ The top Mx (M4) layer (including the top dummy Mx) interacting with CBM is not allowed.
  MBOTx AND CBM
}

//CBM.R.2 can not be checked by DRC.

#ENDIF



CHIP_MOM_WIVIA = COPY CHIP
CHIP_MOM_WOVIA = COPY CHIP
CONNECT CHIP_MOM_WIVIA
CONNECT CHIP_MOM_WOVIA
MOM_VIA1 = VIA1 AND (( MOMDMY_1 AND MOMDMY_2) ENCLOSE VIA1 > 4) 
MOM_VIA1_C = STAMP MOM_VIA1 BY CHIP_MOM_WIVIA
MOM_VIA2 = VIA2 AND (( MOMDMY_2 AND MOMDMY_3) ENCLOSE VIA2 > 4) 
MOM_VIA2_C = STAMP MOM_VIA2 BY CHIP_MOM_WIVIA
MOM_VIA3 = VIA3 AND (( MOMDMY_3 AND MOMDMY_4) ENCLOSE VIA3 > 4) 
MOM_VIA3_C = STAMP MOM_VIA3 BY CHIP_MOM_WIVIA
MOM_VIA4 = VIA4 AND (( MOMDMY_4 AND MOMDMY_5) ENCLOSE VIA4 > 4) 
MOM_VIA4_C = STAMP MOM_VIA4 BY CHIP_MOM_WIVIA
MOM_VIA5 = VIA5 AND (( MOMDMY_5 AND MOMDMY_6) ENCLOSE VIA5 > 4) 
MOM_VIA5_C = STAMP MOM_VIA5 BY CHIP_MOM_WIVIA
MOM_RV =  RV AND (( MOMDMY_6 AND MOMDMY_AP) ENCLOSE RV > 4) 
MOM_RV_C = STAMP MOM_RV BY CHIP_MOM_WIVIA
MOMDMY_1_WIVIA = MOMDMY_1 ENCLOSE MOM_VIA1
MOMDMY_1_WOVIA = MOMDMY_1 NOT MOMDMY_1_WIVIA 
MOM_M1_WIVIA = MOMDMY_1_WIVIA AND M1
MOM_M1_WOVIA = MOMDMY_1_WOVIA AND M1
MOM_M1 = MOM_M1_WIVIA OR MOM_M1_WOVIA 
MOM_M1_EDGE = M1 COIN INSIDE EDGE MOM_M1
MOM_M1_LINE_END = CONVEX EDGE MOM_M1_EDGE ANGLE1==90 ANGLE2==90
MOM_M1_SIDE_EDGE = MOM_M1_EDGE NOT COIN INSIDE EDGE MOM_M1_LINE_END
MOM_M1_CAP_EDGE_b1 = ENC MOM_M1_LINE_END MOMDMY_1 <= 4 OPPOSITE REGION
MOM_M1_CAP_EDGE_b2 = MOM_M1 NOT COIN EDGE MOM_M1_EDGE
MOM_M1_CAP_EDGE_b3 = (MOMDMY_1 TOUCH EDGE MOM_M1_CAP_EDGE_b2) NOT COIN EDGE MOM_M1_CAP_EDGE_b2
MOM_M1_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M1_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M1_CAP_EDGE_b1)   
MOM_M1_CAP_EDGE_b5 = (MOMDMY_1 NOT (MOM_M1_CAP_EDGE_b1 OR MOM_M1)) INTERACT MOM_M1 == 1
MOM_M1_CAP_EDGE    = ((MOM_M1_SIDE_EDGE  NOT COIN EDGE MOMDMY_1) NOT COIN EDGE MOM_M1_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M1_CAP_EDGE_b4 
MOM_M1_CAP_EDGE_EXP = EXPAND EDGE MOM_M1_CAP_EDGE INSIDE BY 0.001
MOM_M1_CAP_EDGE_EXP_WIVIA = MOM_M1_CAP_EDGE_EXP AND MOM_M1_WIVIA
MOM_M1_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M1_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M1_CAP_EDGE_EXP_WOVIA = MOM_M1_CAP_EDGE_EXP AND MOM_M1_WOVIA
MOM_M1_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M1_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_2_WIVIA = (MOMDMY_2 ENCLOSE MOM_VIA1) OR (MOMDMY_2 ENCLOSE MOM_VIA2)
MOMDMY_2_WOVIA = MOMDMY_2 NOT MOMDMY_2_WIVIA 
MOM_M2_WIVIA = MOMDMY_2_WIVIA AND M2
MOM_M2_WOVIA = MOMDMY_2_WOVIA AND M2
MOM_M2 = MOM_M2_WIVIA OR MOM_M2_WOVIA 
MOM_M2_EDGE = M2 COIN INSIDE EDGE MOM_M2
MOM_M2_LINE_END = CONVEX EDGE MOM_M2_EDGE ANGLE1==90 ANGLE2==90
MOM_M2_SIDE_EDGE = MOM_M2_EDGE NOT COIN INSIDE EDGE MOM_M2_LINE_END
MOM_M2_CAP_EDGE_b1 = ENC MOM_M2_LINE_END MOMDMY_2 <= 4 OPPOSITE REGION
MOM_M2_CAP_EDGE_b2 = MOM_M2 NOT COIN EDGE MOM_M2_EDGE
MOM_M2_CAP_EDGE_b3 = (MOMDMY_2 TOUCH EDGE MOM_M2_CAP_EDGE_b2) NOT COIN EDGE MOM_M2_CAP_EDGE_b2
MOM_M2_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M2_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M2_CAP_EDGE_b1)   
MOM_M2_CAP_EDGE_b5 = (MOMDMY_2 NOT (MOM_M2_CAP_EDGE_b1 OR MOM_M2)) INTERACT MOM_M2 == 1
MOM_M2_CAP_EDGE    = ((MOM_M2_SIDE_EDGE  NOT COIN EDGE MOMDMY_2) NOT COIN EDGE MOM_M2_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M2_CAP_EDGE_b4 
MOM_M2_CAP_EDGE_EXP = EXPAND EDGE MOM_M2_CAP_EDGE INSIDE BY 0.001
MOM_M2_CAP_EDGE_EXP_WIVIA = MOM_M2_CAP_EDGE_EXP AND MOM_M2_WIVIA
MOM_M2_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M2_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M2_CAP_EDGE_EXP_WOVIA = MOM_M2_CAP_EDGE_EXP AND MOM_M2_WOVIA
MOM_M2_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M2_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_3_WIVIA = (MOMDMY_3 ENCLOSE MOM_VIA2) OR (MOMDMY_3 ENCLOSE MOM_VIA3)
MOMDMY_3_WOVIA = MOMDMY_3 NOT MOMDMY_3_WIVIA 
MOM_M3_WIVIA = MOMDMY_3_WIVIA AND M3
MOM_M3_WOVIA = MOMDMY_3_WOVIA AND M3
MOM_M3 = MOM_M3_WIVIA OR MOM_M3_WOVIA 
MOM_M3_EDGE = M3 COIN INSIDE EDGE MOM_M3
MOM_M3_LINE_END = CONVEX EDGE MOM_M3_EDGE ANGLE1==90 ANGLE2==90
MOM_M3_SIDE_EDGE = MOM_M3_EDGE NOT COIN INSIDE EDGE MOM_M3_LINE_END
MOM_M3_CAP_EDGE_b1 = ENC MOM_M3_LINE_END MOMDMY_3 <= 4 OPPOSITE REGION
MOM_M3_CAP_EDGE_b2 = MOM_M3 NOT COIN EDGE MOM_M3_EDGE
MOM_M3_CAP_EDGE_b3 = (MOMDMY_3 TOUCH EDGE MOM_M3_CAP_EDGE_b2) NOT COIN EDGE MOM_M3_CAP_EDGE_b2
MOM_M3_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M3_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M3_CAP_EDGE_b1)   
MOM_M3_CAP_EDGE_b5 = (MOMDMY_3 NOT (MOM_M3_CAP_EDGE_b1 OR MOM_M3)) INTERACT MOM_M3 == 1
MOM_M3_CAP_EDGE    = ((MOM_M3_SIDE_EDGE  NOT COIN EDGE MOMDMY_3) NOT COIN EDGE MOM_M3_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M3_CAP_EDGE_b4 
MOM_M3_CAP_EDGE_EXP = EXPAND EDGE MOM_M3_CAP_EDGE INSIDE BY 0.001
MOM_M3_CAP_EDGE_EXP_WIVIA = MOM_M3_CAP_EDGE_EXP AND MOM_M3_WIVIA
MOM_M3_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M3_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M3_CAP_EDGE_EXP_WOVIA = MOM_M3_CAP_EDGE_EXP AND MOM_M3_WOVIA
MOM_M3_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M3_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_4_WIVIA = (MOMDMY_4 ENCLOSE MOM_VIA3) OR (MOMDMY_4 ENCLOSE MOM_VIA4)
MOMDMY_4_WOVIA = MOMDMY_4 NOT MOMDMY_4_WIVIA 
MOM_M4_WIVIA = MOMDMY_4_WIVIA AND M4
MOM_M4_WOVIA = MOMDMY_4_WOVIA AND M4
MOM_M4 = MOM_M4_WIVIA OR MOM_M4_WOVIA 
MOM_M4_EDGE = M4 COIN INSIDE EDGE MOM_M4
MOM_M4_LINE_END = CONVEX EDGE MOM_M4_EDGE ANGLE1==90 ANGLE2==90
MOM_M4_SIDE_EDGE = MOM_M4_EDGE NOT COIN INSIDE EDGE MOM_M4_LINE_END
MOM_M4_CAP_EDGE_b1 = ENC MOM_M4_LINE_END MOMDMY_4 <= 4 OPPOSITE REGION
MOM_M4_CAP_EDGE_b2 = MOM_M4 NOT COIN EDGE MOM_M4_EDGE
MOM_M4_CAP_EDGE_b3 = (MOMDMY_4 TOUCH EDGE MOM_M4_CAP_EDGE_b2) NOT COIN EDGE MOM_M4_CAP_EDGE_b2
MOM_M4_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M4_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M4_CAP_EDGE_b1)   
MOM_M4_CAP_EDGE_b5 = (MOMDMY_4 NOT (MOM_M4_CAP_EDGE_b1 OR MOM_M4)) INTERACT MOM_M4 == 1
MOM_M4_CAP_EDGE    = ((MOM_M4_SIDE_EDGE  NOT COIN EDGE MOMDMY_4) NOT COIN EDGE MOM_M4_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M4_CAP_EDGE_b4 
MOM_M4_CAP_EDGE_EXP = EXPAND EDGE MOM_M4_CAP_EDGE INSIDE BY 0.001
MOM_M4_CAP_EDGE_EXP_WIVIA = MOM_M4_CAP_EDGE_EXP AND MOM_M4_WIVIA
MOM_M4_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M4_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M4_CAP_EDGE_EXP_WOVIA = MOM_M4_CAP_EDGE_EXP AND MOM_M4_WOVIA
MOM_M4_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M4_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_5_WIVIA = (MOMDMY_5 ENCLOSE MOM_VIA4) OR (MOMDMY_5 ENCLOSE MOM_VIA5)
MOMDMY_5_WOVIA = MOMDMY_5 NOT MOMDMY_5_WIVIA 
MOM_M5_WIVIA = MOMDMY_5_WIVIA AND M5
MOM_M5_WOVIA = MOMDMY_5_WOVIA AND M5
MOM_M5 = MOM_M5_WIVIA OR MOM_M5_WOVIA 
MOM_M5_EDGE = M5 COIN INSIDE EDGE MOM_M5
MOM_M5_LINE_END = CONVEX EDGE MOM_M5_EDGE ANGLE1==90 ANGLE2==90
MOM_M5_SIDE_EDGE = MOM_M5_EDGE NOT COIN INSIDE EDGE MOM_M5_LINE_END
MOM_M5_CAP_EDGE_b1 = ENC MOM_M5_LINE_END MOMDMY_5 <= 4 OPPOSITE REGION
MOM_M5_CAP_EDGE_b2 = MOM_M5 NOT COIN EDGE MOM_M5_EDGE
MOM_M5_CAP_EDGE_b3 = (MOMDMY_5 TOUCH EDGE MOM_M5_CAP_EDGE_b2) NOT COIN EDGE MOM_M5_CAP_EDGE_b2
MOM_M5_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M5_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M5_CAP_EDGE_b1)   
MOM_M5_CAP_EDGE_b5 = (MOMDMY_5 NOT (MOM_M5_CAP_EDGE_b1 OR MOM_M5)) INTERACT MOM_M5 == 1
MOM_M5_CAP_EDGE    = ((MOM_M5_SIDE_EDGE  NOT COIN EDGE MOMDMY_5) NOT COIN EDGE MOM_M5_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M5_CAP_EDGE_b4 
MOM_M5_CAP_EDGE_EXP = EXPAND EDGE MOM_M5_CAP_EDGE INSIDE BY 0.001
MOM_M5_CAP_EDGE_EXP_WIVIA = MOM_M5_CAP_EDGE_EXP AND MOM_M5_WIVIA
MOM_M5_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M5_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M5_CAP_EDGE_EXP_WOVIA = MOM_M5_CAP_EDGE_EXP AND MOM_M5_WOVIA
MOM_M5_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M5_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_6_WIVIA = (MOMDMY_6 ENCLOSE MOM_VIA5) OR (MOMDMY_6 ENCLOSE MOM_RV)
MOMDMY_6_WOVIA = MOMDMY_6 NOT MOMDMY_6_WIVIA 
MOM_M6_WIVIA = MOMDMY_6_WIVIA AND M6
MOM_M6_WOVIA = MOMDMY_6_WOVIA AND M6
MOM_M6 = MOM_M6_WIVIA OR MOM_M6_WOVIA 
MOM_M6_EDGE = M6 COIN INSIDE EDGE MOM_M6
MOM_M6_LINE_END = CONVEX EDGE MOM_M6_EDGE ANGLE1==90 ANGLE2==90
MOM_M6_SIDE_EDGE = MOM_M6_EDGE NOT COIN INSIDE EDGE MOM_M6_LINE_END
MOM_M6_CAP_EDGE_b1 = ENC MOM_M6_LINE_END MOMDMY_6 <= 4 OPPOSITE REGION
MOM_M6_CAP_EDGE_b2 = MOM_M6 NOT COIN EDGE MOM_M6_EDGE
MOM_M6_CAP_EDGE_b3 = (MOMDMY_6 TOUCH EDGE MOM_M6_CAP_EDGE_b2) NOT COIN EDGE MOM_M6_CAP_EDGE_b2
MOM_M6_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M6_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M6_CAP_EDGE_b1)   
MOM_M6_CAP_EDGE_b5 = (MOMDMY_6 NOT (MOM_M6_CAP_EDGE_b1 OR MOM_M6)) INTERACT MOM_M6 == 1
MOM_M6_CAP_EDGE    = ((MOM_M6_SIDE_EDGE  NOT COIN EDGE MOMDMY_6) NOT COIN EDGE MOM_M6_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M6_CAP_EDGE_b4 
MOM_M6_CAP_EDGE_EXP = EXPAND EDGE MOM_M6_CAP_EDGE INSIDE BY 0.001
MOM_M6_CAP_EDGE_EXP_WIVIA = MOM_M6_CAP_EDGE_EXP AND MOM_M6_WIVIA
MOM_M6_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M6_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M6_CAP_EDGE_EXP_WOVIA = MOM_M6_CAP_EDGE_EXP AND MOM_M6_WOVIA
MOM_M6_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M6_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_AP_WIVIA = MOMDMY_AP ENCLOSE MOM_RV
MOMDMY_AP_WOVIA = MOMDMY_AP NOT MOMDMY_AP_WIVIA
MOM_AP_WIVIA = MOMDMY_AP_WIVIA AND AP
MOM_AP_WOVIA = MOMDMY_AP_WOVIA AND AP
MOM_AP = MOM_AP_WIVIA OR MOM_AP_WOVIA
MOM_AP_EDGE = AP COIN INSIDE EDGE MOM_AP
MOM_AP_LINE_END = CONVEX EDGE MOM_AP_EDGE ANGLE1==90 ANGLE2==90

MOM_AP_SIDE_EDGE = MOM_AP_EDGE NOT COIN INSIDE EDGE MOM_AP_LINE_END
MOM_AP_CAP_EDGE_b1 = ENC MOM_AP_LINE_END MOMDMY_AP <= 4 OPPOSITE REGION
MOM_AP_CAP_EDGE_b2 = MOM_AP NOT COIN EDGE MOM_AP_EDGE
MOM_AP_CAP_EDGE_b3 = (MOMDMY_AP TOUCH EDGE MOM_AP_CAP_EDGE_b2) NOT COIN EDGE MOM_AP_CAP_EDGE_b2
MOM_AP_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_AP_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_AP_CAP_EDGE_b1)   
MOM_AP_CAP_EDGE_b5 = (MOMDMY_AP NOT (MOM_AP_CAP_EDGE_b1 OR MOM_AP)) INTERACT MOM_AP == 1
MOM_AP_CAP_EDGE    = ((MOM_AP_SIDE_EDGE  NOT COIN EDGE MOMDMY_AP) NOT COIN EDGE MOM_AP_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_AP_CAP_EDGE_b4 
MOM_AP_CAP_EDGE_EXP = EXPAND EDGE MOM_AP_CAP_EDGE INSIDE BY 0.001
MOM_AP_CAP_EDGE_EXP_WIVIA = MOM_AP_CAP_EDGE_EXP AND MOM_AP_WIVIA
MOM_AP_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_AP_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_AP_CAP_EDGE_EXP_WOVIA = MOM_AP_CAP_EDGE_EXP AND MOM_AP_WOVIA
MOM_AP_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_AP_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA


#IFDEF HALF_NODE
VARIABLE m1_thickness 0.16
#ELSE
VARIABLE m1_thickness 0.18
#ENDIF
#IFDEF HALF_NODE
VARIABLE m2_thickness 0.2
#ELSE
VARIABLE m2_thickness 0.22
#ENDIF
VARIABLE v1_thickness 0.175
#IFDEF HALF_NODE
VARIABLE m3_thickness 0.2
#ELSE
VARIABLE m3_thickness 0.22
#ENDIF
VARIABLE v2_thickness 0.175
#IFDEF HALF_NODE
VARIABLE m4_thickness 0.2
#ELSE
VARIABLE m4_thickness 0.22
#ENDIF
VARIABLE v3_thickness 0.175
VARIABLE m5_thickness 0.9
VARIABLE v4_thickness 0.595
VARIABLE m6_thickness 3.3
VARIABLE v5_thickness 0.595
#IFDEF 28K_AP
VARIABLE ap_thickness 2.8
#ELSE
VARIABLE ap_thickness 1.45
#ENDIF
VARIABLE rv_thickness 0.8


MOM.S.1{ @ Space of M1 in MOMDMY_1 >= 0.1
  EXT MOM_M1 < MOM_S_1 ABUT < 90 SINGULAR REGION
}

MOM.S.2.M1{ @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12
  EXT MOM_M1_LINE_END M1 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M2{ @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12
  EXT MOM_M2_LINE_END M2 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M3{ @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12
  EXT MOM_M3_LINE_END M3 < MOM_S_2 ABUT < 90 REGION
}
MOM.S.2.M4{ @ Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12
  EXT MOM_M4_LINE_END M4 < MOM_S_2 ABUT < 90 REGION
}


MOM.A.1{ @ Maximum sidewall area of total metals in MOM without Via <= 7.01E7
   NET AREA RATIO CHIP_MOM_WOVIA  MOM_M1_CAP_EDGE_EXP_WOVIA_C MOM_M2_CAP_EDGE_EXP_WOVIA_C MOM_M3_CAP_EDGE_EXP_WOVIA_C MOM_M4_CAP_EDGE_EXP_WOVIA_C MOM_M5_CAP_EDGE_EXP_WOVIA_C MOM_M6_CAP_EDGE_EXP_WOVIA_C MOM_AP_CAP_EDGE_EXP_WOVIA_C > MOM_A_1
  [
    ( PERIMETER(MOM_M1_CAP_EDGE_EXP_WOVIA_C)*m1_thickness+ PERIMETER(MOM_M2_CAP_EDGE_EXP_WOVIA_C)*m2_thickness+ PERIMETER(MOM_M3_CAP_EDGE_EXP_WOVIA_C)*m3_thickness+ PERIMETER(MOM_M4_CAP_EDGE_EXP_WOVIA_C)*m4_thickness+ PERIMETER(MOM_M5_CAP_EDGE_EXP_WOVIA_C)*m5_thickness+ PERIMETER(MOM_M6_CAP_EDGE_EXP_WOVIA_C)*m6_thickness+ PERIMETER(MOM_AP_CAP_EDGE_EXP_WOVIA_C)*ap_thickness )/4
  ] RDB MOM.A.1.rep
}


MOM.S.3.M1{ @ Space of Metal (M1/Mx) in MOM with Via >= 0.13
  EXT MOM_M1_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
MOM.S.3.M2{ @ Space of Metal (M1/Mx) in MOM with Via >= 0.13
  EXT MOM_M2_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
MOM.S.3.M3{ @ Space of Metal (M1/Mx) in MOM with Via >= 0.13
  EXT MOM_M3_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
MOM.S.3.M4{ @ Space of Metal (M1/Mx) in MOM with Via >= 0.13
  EXT MOM_M4_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}

MOM.S.4.VIA1{ @ Space of VIAx in MOM with Via in different net >= 0.13 
  A = STAMP MOM_VIA1 BY VIA1i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
MOM.S.4.VIA2{ @ Space of VIAx in MOM with Via in different net >= 0.13 
  A = STAMP MOM_VIA2 BY VIA2i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
MOM.S.4.VIA3{ @ Space of VIAx in MOM with Via in different net >= 0.13 
  A = STAMP MOM_VIA3 BY VIA3i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}


MOM.A.2{ @ Maximum sidewall area of {total metals+ total Vias} in MOM with Via. <= 1.72E5
   NET AREA RATIO CHIP_MOM_WIVIA  MOM_M1_CAP_EDGE_EXP_WIVIA_C MOM_VIA1_C  MOM_M2_CAP_EDGE_EXP_WIVIA_C MOM_VIA2_C  MOM_M3_CAP_EDGE_EXP_WIVIA_C MOM_VIA3_C  MOM_M4_CAP_EDGE_EXP_WIVIA_C MOM_VIA4_C  MOM_M5_CAP_EDGE_EXP_WIVIA_C MOM_VIA5_C  MOM_M6_CAP_EDGE_EXP_WIVIA_C  MOM_RV_C MOM_AP_CAP_EDGE_EXP_WIVIA_C > MOM_A_2
  [
    ( PERIMETER(MOM_M1_CAP_EDGE_EXP_WIVIA_C)*m1_thickness+ PERIMETER(MOM_VIA1_C)*v1_thickness+  PERIMETER(MOM_M2_CAP_EDGE_EXP_WIVIA_C)*m2_thickness+ PERIMETER(MOM_VIA2_C)*v2_thickness+  PERIMETER(MOM_M3_CAP_EDGE_EXP_WIVIA_C)*m3_thickness+ PERIMETER(MOM_VIA3_C)*v3_thickness+  PERIMETER(MOM_M4_CAP_EDGE_EXP_WIVIA_C)*m4_thickness+ PERIMETER(MOM_VIA4_C)*v4_thickness+  PERIMETER(MOM_M5_CAP_EDGE_EXP_WIVIA_C)*m5_thickness+ PERIMETER(MOM_VIA5_C)*v5_thickness+  PERIMETER(MOM_M6_CAP_EDGE_EXP_WIVIA_C)*m6_thickness+  PERIMETER(MOM_RV_C)*rv_thickness+PERIMETER(MOM_AP_CAP_EDGE_EXP_WIVIA_C)*ap_thickness )/4
  ] RDB MOM.A.2.rep
}




VARIABLE IND_W_1  0.4
VARIABLE IND_W_2  0.6
VARIABLE IND_W_3  0.8
VARIABLE IND_S_1  0.4
VARIABLE IND_S_2  0.6
VARIABLE IND_S_3  0.8
VARIABLE IND_S_4  1.0
VARIABLE IND_S_5  2.0
VARIABLE IND_W_6  30.0

IND_REGION = SIZE INDDMY BY 12
IND_M1 =  M1 AND IND_REGION  
IND_WideM11.5 = IND_M1 WITH WIDTH > 1.5
IND_WideM14.5 = IND_WideM11.5 WITH WIDTH > 4.5
IND_M2 =  M2 AND IND_REGION  
IND_WideM21.5 = IND_M2 WITH WIDTH > 1.5
IND_WideM24.5 = IND_WideM21.5 WITH WIDTH > 4.5
IND_M3 =  M3 AND IND_REGION  
IND_WideM31.5 = IND_M3 WITH WIDTH > 1.5
IND_WideM34.5 = IND_WideM31.5 WITH WIDTH > 4.5
IND_M4 =  M4 AND IND_REGION  
IND_WideM41.5 = IND_M4 WITH WIDTH > 1.5
IND_WideM44.5 = IND_WideM41.5 WITH WIDTH > 4.5
IND_M5 =  M5 AND IND_REGION  
IND_WideM51.5 = IND_M5 WITH WIDTH > 1.5
IND_WideM54.5 = IND_WideM51.5 WITH WIDTH > 4.5
IND_M6 =  M6 AND IND_REGION  
IND_WideM61.5 = IND_M6 WITH WIDTH > 1.5
IND_WideM64.5 = IND_WideM61.5 WITH WIDTH > 4.5

IND.W.1 { @ M1 width in (INDDMY SIZING 12um) >= 0.4
  A =  M1 NOT OUTSIDE IND_REGION
  (INT A < IND_W_1 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.W.2.M2 { @ Mx width in (INDDMY SIZING 12um) >= 0.6
  A =  M2 NOT OUTSIDE IND_REGION  
  (INT A < IND_W_2 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.W.2.M3 { @ Mx width in (INDDMY SIZING 12um) >= 0.6
  A =  M3 NOT OUTSIDE IND_REGION  
  (INT A < IND_W_2 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.W.2.M4 { @ Mx width in (INDDMY SIZING 12um) >= 0.6
  A =  M4 NOT OUTSIDE IND_REGION  
  (INT A < IND_W_2 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.W.3.M5 { @ Mz width in (INDDMY SIZING 12um) >= 0.8
  A =  M5 NOT OUTSIDE IND_REGION  
  (INT A < IND_W_3 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.S.1 { @ M1 space in (INDDMY SIZING 12um) >= 0.4
  A =  M1 NOT OUTSIDE IND_REGION  
  (EXT A < IND_S_1 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.S.2.M2 { @ Mx space in (INDDMY SIZING 12um) >= 0.6
  A =  M2 NOT OUTSIDE IND_REGION  
  (EXT A < IND_S_2 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M3 { @ Mx space in (INDDMY SIZING 12um) >= 0.6
  A =  M3 NOT OUTSIDE IND_REGION  
  (EXT A < IND_S_2 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}
IND.S.2.M4 { @ Mx space in (INDDMY SIZING 12um) >= 0.6
  A =  M4 NOT OUTSIDE IND_REGION  
  (EXT A < IND_S_2 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.S.3.M5 { @ Mz space in (INDDMY SIZING 12um) >= 0.8
  A =  M5 NOT OUTSIDE IND_REGION  
  (EXT A < IND_S_3 ABUT<90 SINGULAR REGION) NOT OUTSIDE IND_REGION  
}

IND.S.4.M1 { @ M1 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0
  X = EXT IND_WideM11.5 M1 < IND_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID 1.5+GRID
}
IND.S.5.M1 { @ M1 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0
  X = EXT IND_WideM14.5 M1 < IND_S_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID 4.5+GRID
}
IND.S.4.M2 { @ M2 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0
  X = EXT IND_WideM21.5 M2 < IND_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID 1.5+GRID
}
IND.S.5.M2 { @ M2 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0
  X = EXT IND_WideM24.5 M2 < IND_S_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID 4.5+GRID
}
IND.S.4.M3 { @ M3 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0
  X = EXT IND_WideM31.5 M3 < IND_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID 1.5+GRID
}
IND.S.5.M3 { @ M3 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0
  X = EXT IND_WideM34.5 M3 < IND_S_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID 4.5+GRID
}
IND.S.4.M4 { @ M4 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0
  X = EXT IND_WideM41.5 M4 < IND_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID 1.5+GRID
}
IND.S.5.M4 { @ M4 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0
  X = EXT IND_WideM44.5 M4 < IND_S_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID 4.5+GRID
}
IND.S.4.M5 { @ M5 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0
  X = EXT IND_WideM51.5 M5 < IND_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID 1.5+GRID
}
IND.S.5.M5 { @ M5 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0
  X = EXT IND_WideM54.5 M5 < IND_S_5 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID 4.5+GRID
}


//IND.W.4 is checked by Mx.W.2

//IND.W.5 is checked by Mz.W.2/Mu.W.2


IND.W.6.M5 { @ Maximun metal width only for Inductor application only <= 30.0
  A =  M5 AND IND_EXD  
  A WITH WIDTH > IND_W_6+0.005
}
IND.W.6.M6 { @ Maximun metal width only for Inductor application only <= 30.0
  A =  M6 AND IND_EXD  
  A WITH WIDTH > IND_W_6+0.005
}

IND.W.7 { @ Max. dimension (either width or length) of an INDDMY region <= 600 um
  ENCLOSE RECTANGLE INDDMY 0.005 600.005 ORTHOGONAL ONLY
}

REGION_A = SIZE INDDMY BY -4
REGION_B = INDDMY NOT REGION_A
REGION_C = (SIZE INDDMY BY 6 ) NOT INDDMY
REGION_D = (SIZE INDDMY BY 12 ) NOT (SIZE INDDMY BY 6)
REGION_BCD = (REGION_B OR REGION_C) OR REGION_D 
IND_JOG_EDGE = CONVEX EDGE INDDMY ANGLE1==90 ANGLE2==270
IND_R_EDGE  = INDDMY NOT COIN EDGE IND_JOG_EDGE 

PO_ISLAND_pre = POLY NOT OUTSIDE REGION_BCD
PO_ISLAND = (PO_ISLAND_pre NOT INTERACT OD) NOT INTERACT CO
M1_ISLAND_pre = M1 NOT OUTSIDE REGION_BCD
M1_ISLAND = ((RECTANGLE M1_ISLAND_pre > 2.99 < 3.01 BY > 2.99 < 3.01) NOT INTERACT VIA1) NOT INTERACT CO 
M2_ISLAND_pre = M2 NOT OUTSIDE REGION_BCD
M2_ISLAND = ((RECTANGLE M2_ISLAND_pre > 2.99 < 3.01 BY > 2.99 < 3.01) NOT INTERACT VIA2) NOT INTERACT VIA1 
M3_ISLAND_pre = M3 NOT OUTSIDE REGION_BCD
M3_ISLAND = ((RECTANGLE M3_ISLAND_pre > 2.99 < 3.01 BY > 2.99 < 3.01) NOT INTERACT VIA3) NOT INTERACT VIA2 
M4_ISLAND_pre = M4 NOT OUTSIDE REGION_BCD
M4_ISLAND = ((RECTANGLE M4_ISLAND_pre > 2.99 < 3.01 BY > 2.99 < 3.01) NOT INTERACT VIA4) NOT INTERACT VIA3 
M5_ISLAND_pre = M5 NOT OUTSIDE REGION_BCD
M5_ISLAND = ((RECTANGLE M5_ISLAND_pre > 2.99 < 3.01 BY > 2.99 < 3.01) NOT INTERACT VIA5) NOT INTERACT VIA4 
M6_ISLAND_pre = M6 NOT OUTSIDE REGION_BCD
M6_ISLAND = ((RECTANGLE M6_ISLAND_pre > 2.99 < 3.01 BY > 2.99 < 3.01) NOT INTERACT VIA5) NOT INTERACT RV

IND_TM = (M6 AND IND_REGION) NOT M6_ISLAND // Top inductor metal inside INDDMY 

IND_TM_A = EXT IND_TM INDDMY < 0.01 ABUT>0<=135 INTERSECTING ONLY REGION 
IND_TM_B = M6 TOUCH OUTSIDE EDGE IND_TM_A
IND_TM_B1 = EXPAND EDGE IND_TM_B INSIDE BY 0.005
IND_TM_B2 = EXPAND EDGE (INDDMY INSIDE EDGE IND_TM) BY 0.005
IND_TM_C = EXTENTS (IND_TM_B1 OR IND_TM_B2)
IND_TM_leading = (INT IND_TM_B < 30.005 OPPOSITE REGION) AND IND_TM_C     
IND_TM_spiral = (IND_TM NOT IND_TM_leading) AND INDDMY // core inductor metal

LEADING  = IND_TM_leading AND REGION_BCD
LEADING_EXD = SIZE LEADING BY 20
M1_GUARD_RING = (M1 NOT OUTSIDE REGION_B ) INTERACT (COOD INSIDE REGION_B)
M1_GUARD_RING_P = M1_GUARD_RING AND REGION_BCD
M1_GUARD_RING_Px = SIZE M1_GUARD_RING_P BY 20 
M1_GUARD_RING_P1 = M1_GUARD_RING AND REGION_C
M1_GUARD_RING_P1x = SIZE M1_GUARD_RING_P1 BY 20
CTAP_EXD  = IND_CTAP AND REGION_BCD
CTAP_EXDx = SIZE CTAP_EXD BY 20
REGION_Bx = (((EXPAND EDGE IND_R_EDGE INSIDE BY 4) NOT LEADING_EXD) NOT M1_GUARD_RING_P1x) NOT CTAP_EXDx   

CONNECT REGION_B

IND.DN.1.M1 { @ M1 density within ring region b  >= 10%  <= 80%
    REGION_B_NOT_EXD = REGION_B NOT LEADING_EXD
    X = M1x AND REGION_B_NOT_EXD
    Y = STAMP X BY REGION_B_NOT_EXD
    NET AREA RATIO REGION_B_NOT_EXD Y < 0.1 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1L.M1.density 
    NET AREA RATIO REGION_B_NOT_EXD Y > 0.8 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1H.M1.density 
}
IND.DN.1.M2 { @ M2 density within ring region b  >= 10%  <= 80%
    REGION_B_NOT_EXD = REGION_B NOT LEADING_EXD
    X = M2x AND REGION_B_NOT_EXD
    Y = STAMP X BY REGION_B_NOT_EXD
    NET AREA RATIO REGION_B_NOT_EXD Y < 0.1 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1L.M2.density 
    NET AREA RATIO REGION_B_NOT_EXD Y > 0.8 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1H.M2.density 
}
IND.DN.1.M3 { @ M3 density within ring region b  >= 10%  <= 80%
    REGION_B_NOT_EXD = REGION_B NOT LEADING_EXD
    X = M3x AND REGION_B_NOT_EXD
    Y = STAMP X BY REGION_B_NOT_EXD
    NET AREA RATIO REGION_B_NOT_EXD Y < 0.1 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1L.M3.density 
    NET AREA RATIO REGION_B_NOT_EXD Y > 0.8 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1H.M3.density 
}
IND.DN.1.M4 { @ M4 density within ring region b  >= 10%  <= 80%
    REGION_B_NOT_EXD = REGION_B NOT LEADING_EXD
    X = M4x AND REGION_B_NOT_EXD
    Y = STAMP X BY REGION_B_NOT_EXD
    NET AREA RATIO REGION_B_NOT_EXD Y < 0.1 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1L.M4.density 
    NET AREA RATIO REGION_B_NOT_EXD Y > 0.8 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1H.M4.density 
}
IND.DN.1.M5 { @ M5 density within ring region b  >= 10%  <= 80%
    REGION_B_NOT_EXD = REGION_B NOT LEADING_EXD
    X = M5x AND REGION_B_NOT_EXD
    Y = STAMP X BY REGION_B_NOT_EXD
    NET AREA RATIO REGION_B_NOT_EXD Y < 0.1 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1L.M5.density 
    NET AREA RATIO REGION_B_NOT_EXD Y > 0.8 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1H.M5.density 
}
IND.DN.1.M6 { @ M6 density within ring region b  >= 10%  <= 80%
    REGION_B_NOT_EXD = REGION_B NOT LEADING_EXD
    X = M6x AND REGION_B_NOT_EXD
    Y = STAMP X BY REGION_B_NOT_EXD
    NET AREA RATIO REGION_B_NOT_EXD Y < 0.1 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1L.M6.density 
    NET AREA RATIO REGION_B_NOT_EXD Y > 0.8 [ AREA(Y)/AREA(REGION_B_NOT_EXD)] RDB IND.DN.1H.M6.density 
}

IND.R.8.M1 { @ Maximun empty area within ring region b <= 4 x 12
  A = WITH WIDTH ((REGION_Bx NOT M1x) NOT M1_GUARD_RING_Px) >= 4 - GRID
  ENCLOSE RECTANGLE A 4 - GRID 12+GRID
}

IND.R.8.M2 { @ Maximun empty area within ring region b <= 4 x 12
  A = WITH WIDTH (REGION_Bx NOT M2x) >= 4 - GRID
  ENCLOSE RECTANGLE A 4 - GRID 12+GRID
}
IND.R.8.M3 { @ Maximun empty area within ring region b <= 4 x 12
  A = WITH WIDTH (REGION_Bx NOT M3x) >= 4 - GRID
  ENCLOSE RECTANGLE A 4 - GRID 12+GRID
}
IND.R.8.M4 { @ Maximun empty area within ring region b <= 4 x 12
  A = WITH WIDTH (REGION_Bx NOT M4x) >= 4 - GRID
  ENCLOSE RECTANGLE A 4 - GRID 12+GRID
}
IND.R.8.M5 { @ Maximun empty area within ring region b <= 4 x 12
  A = WITH WIDTH (REGION_Bx NOT M5x) >= 4 - GRID
  ENCLOSE RECTANGLE A 4 - GRID 12+GRID
}
IND.R.8.M6 { @ Maximun empty area within ring region b <= 4 x 12
  A = WITH WIDTH (REGION_Bx NOT M6x) >= 4 - GRID
  ENCLOSE RECTANGLE A 4 - GRID 12+GRID
}



IND.R.1 { @ In the region of (INDDMY SIZING 12um), inter-via (Vx) is not allowed.
 VIA1 AND IND_REGION 
 VIA2 AND IND_REGION 
 VIA3 AND IND_REGION 
}


IND.R.2_IND.R.3.VIA4 { @ More than 4 VIA4 with space <= 1.7 um is required to connect M5(Mz or Mu) and M4(Mz or Mx) for inductor application only.
  M5OvpM4 = (M5 AND M4) AND IND_REGION 
  Check_VIA4 = VIA4_EXD INTERACT M5OvpM4
  VIA4Merge = SIZE Check_VIA4 BY (1.7/2) INSIDE OF M5OvpM4 STEP M4_S_1*0.7
  VIA4Merge2 = VIA4Merge ENCLOSE Check_VIA4 >= 4
  Good_VIA4 = Check_VIA4 AND VIA4Merge2
  GM5OvpM4 = M5OvpM4 INTERACT Good_VIA4
  Check_VIA4 OUTSIDE GM5OvpM4
}
IND.R.2_IND.R.3.VIA5 { @ More than 4 VIA5 with space <= 1.7 um is required to connect M6(Mz or Mu) and M5(Mz or Mx) for inductor application only.
  M6OvpM5 = (M6 AND M5) AND IND_REGION 
  Check_VIA5 = VIA5_EXD INTERACT M6OvpM5
  VIA5Merge = SIZE Check_VIA5 BY (1.7/2) INSIDE OF M6OvpM5 STEP M5_S_1*0.7
  VIA5Merge2 = VIA5Merge ENCLOSE Check_VIA5 >= 4
  Good_VIA5 = Check_VIA5 AND VIA5Merge2
  GM6OvpM5 = M6OvpM5 INTERACT Good_VIA5
  Check_VIA5 OUTSIDE GM6OvpM5
}

IND.R.4 { @ In the region a of (INDDMY SIZING -4 m), except the Mx layer directly below [Mz or Mu], any other inter-metal layer (Mx) is not allowed. (E.g. for a 1P6M process with 9KA of M6 (Mz), then Mx of M5 is allowed, but other lower Mx metal layers are not allowed for the inductor.)   
 M2 AND REGION_A
 M3 AND REGION_A
}

IND.R.13 { @ INDDMY enclosure of top metal(inductor) >= 4 um.
  INDDMYx45 = INDDMY ANGLE == 45 
  INDDMYx090 = INDDMY NOT COIN EDGE INDDMYx45      
  IND_TM_core_check = IND_TM_spiral NOT TOUCH INSIDE EDGE IND_TM_B 
  ENC IND_TM_core_check INDDMYx45 < 4 - GRID ABUT < 90 OPPOSITE REGION
  ENC IND_TM_core_check INDDMYx090 < 4 ABUT < 90 OPPOSITE REGION
}





//IND.R.5, IND.R.7  can not be checked by DRC


IND.R.6 { @ In region b, 3um x 3um metal islands with 3um space from M2~Mtop are required.
  REGION_B NOT INTERACT M2_ISLAND   
  REGION_B NOT INTERACT M3_ISLAND   
  REGION_B NOT INTERACT M4_ISLAND   
  REGION_B NOT INTERACT M5_ISLAND   
  REGION_B NOT INTERACT M6_ISLAND   
}


#IFDEF FULL_CHIP
IND.DN.6 { @ Maximum density of INDDMY in whole chip <= 5% 
   DENSITY INDDMY CHIP > 0.05 INSIDE OF LAYER CHIPx PRINT IND.DN.6.density
   [ AREA(INDDMY)/AREA(CHIP) ]
}    
IND.DN.9 { @ M1/Mx/Mz. metal density over the whole chip >= 20% 
  CHIP_IND = CHIPx INTERACT INDDMY
  DENSITY M1x CHIP < 0.2 INSIDE OF LAYER CHIP_IND PRINT IND.DN.9.M1.density
  [ AREA(M1x)/AREA(CHIP) ]
  DENSITY M2x CHIP < 0.2 INSIDE OF LAYER CHIP_IND PRINT IND.DN.9.M2.density
  [ AREA(M2x)/AREA(CHIP) ]
  DENSITY M3x CHIP < 0.2 INSIDE OF LAYER CHIP_IND PRINT IND.DN.9.M3.density
  [ AREA(M3x)/AREA(CHIP) ]
  DENSITY M4x CHIP < 0.2 INSIDE OF LAYER CHIP_IND PRINT IND.DN.9.M4.density
  [ AREA(M4x)/AREA(CHIP) ]
  DENSITY M5x CHIP < 0.2 INSIDE OF LAYER CHIP_IND PRINT IND.DN.9.M5.density
  [ AREA(M5x)/AREA(CHIP) ]
}
#ENDIF

IND.DN.7.M1 { @ Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90% 
  DENSITY M1x > 0.9 INSIDE OF LAYER IND_REGION WINDOW 50 STEP 25 BACKUP PRINT IND.DN.7.M1.density 
}
IND.DN.7.M2 { @ Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90% 
  DENSITY M2x > 0.9 INSIDE OF LAYER IND_REGION WINDOW 50 STEP 25 BACKUP PRINT IND.DN.7.M2.density 
}
IND.DN.7.M3 { @ Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90% 
  DENSITY M3x > 0.9 INSIDE OF LAYER IND_REGION WINDOW 50 STEP 25 BACKUP PRINT IND.DN.7.M3.density 
}
IND.DN.7.M4 { @ Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90% 
  DENSITY M4x > 0.9 INSIDE OF LAYER IND_REGION WINDOW 50 STEP 25 BACKUP PRINT IND.DN.7.M4.density 
}

IND.DN.7.M5 { @ Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90% 
  DENSITY M5x > 0.9 INSIDE OF LAYER IND_REGION WINDOW 50 STEP 25 BACKUP PRINT IND.DN.7.M5.density 
}


IND.DN.8.M1 { @ Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80% 
  DENSITY M1x > 0.8 INSIDE OF LAYER IND_REGION WINDOW 100 STEP 50 BACKUP PRINT IND.DN.8.M1.density 
}
IND.DN.8.M2 { @ Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80% 
  DENSITY M2x > 0.8 INSIDE OF LAYER IND_REGION WINDOW 100 STEP 50 BACKUP PRINT IND.DN.8.M2.density 
}
IND.DN.8.M3 { @ Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80% 
  DENSITY M3x > 0.8 INSIDE OF LAYER IND_REGION WINDOW 100 STEP 50 BACKUP PRINT IND.DN.8.M3.density 
}
IND.DN.8.M4 { @ Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80% 
  DENSITY M4x > 0.8 INSIDE OF LAYER IND_REGION WINDOW 100 STEP 50 BACKUP PRINT IND.DN.8.M4.density 
}

IND.DN.8.M5 { @ Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80% 
  DENSITY M5x > 0.8 INSIDE OF LAYER IND_REGION WINDOW 100 STEP 50 BACKUP PRINT IND.DN.8.M5.density 
}








//CHIP CORNER RULE CHECKS
//=======================

#IFDEF FULL_CHIP

CSR.R.1.DNWi { @ DNWi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DNWi     
}
CSR.R.1.NWi { @ NWi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NWi     
}
CSR.R.1.OD_18i { @ OD_18i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_18i     
}
CSR.R.1.OD_25i { @ OD_25i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_25i     
}
CSR.R.1.OD25_33 { @ OD25_33 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD25_33     
}
CSR.R.1.OD25_18 { @ OD25_18 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD25_18     
}
CSR.R.1.OD_33i { @ OD_33i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_33i     
}
CSR.R.1.OD_DECAP { @ OD_DECAP is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_DECAP     
}
CSR.R.1.PPi { @ PPi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PPi     
}
CSR.R.1.NPi { @ NPi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NPi     
}
CSR.R.1.COi { @ COi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND COi     
}
CSR.R.1.CO_PUSH { @ CO_PUSH is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CO_PUSH     
}
CSR.R.1.CBi { @ CBi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CBi     
}
CSR.R.1.CB2i { @ CB2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CB2i     
}
CSR.R.1.RPOi { @ RPOi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RPOi     
}
CSR.R.1.NT_Ni { @ NT_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NT_Ni     
}
CSR.R.1.NCap_NTNi { @ NCap_NTNi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NCap_NTNi     
}
CSR.R.1.FWALi { @ FWALi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND FWALi     
}
CSR.R.1.FWCUi { @ FWCUi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND FWCUi     
}
CSR.R.1.POFUSE { @ POFUSE is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND POFUSE     
}
CSR.R.1.FUSELINK { @ FUSELINK is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND FUSELINK     
}
CSR.R.1.PMi { @ PMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PMi     
}
CSR.R.1.PM1i { @ PM1i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PM1i     
}
CSR.R.1.PM2i { @ PM2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PM2i     
}
CSR.R.1.SEALRINGi { @ SEALRINGi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SEALRINGi     
}
CSR.R.1.VTH_Ni { @ VTH_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTH_Ni     
}
CSR.R.1.VTH_Pi { @ VTH_Pi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTH_Pi     
}
CSR.R.1.VTL_Ni { @ VTL_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTL_Ni     
}
CSR.R.1.VTL_Pi { @ VTL_Pi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTL_Pi     
}
CSR.R.1.UHVT_Ni { @ UHVT_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND UHVT_Ni     
}
CSR.R.1.UHVT_Pi { @ UHVT_Pi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND UHVT_Pi     
}
CSR.R.1.CBDi { @ CBDi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CBDi     
}
CSR.R.1.UBMi { @ UBMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND UBMi     
}
CSR.R.1.RH { @ RH is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RH     
}
CSR.R.1.ESD3 { @ ESD3 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESD3     
}
CSR.R.1.VARi { @ VARi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VARi     
}
CSR.R.1.APi { @ APi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND APi     
}
CSR.R.1.Cu_PPIi { @ Cu_PPIi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND Cu_PPIi     
}
CSR.R.1.CBMi { @ CBMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CBMi     
}
CSR.R.1.CTMi { @ CTMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMi     
}
CSR.R.1.RVi { @ RVi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RVi     
}
CSR.R.1.DCOi { @ DCOi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DCOi     
}
CSR.R.1.HVD_N { @ HVD_N is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND HVD_N     
}
CSR.R.1.HVD_P { @ HVD_P is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND HVD_P     
}
CSR.R.1.HVD_N_nw { @ HVD_N_nw is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND HVD_N_nw     
}
CSR.R.1.BJTDMY { @ BJTDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND BJTDMY     
}
CSR.R.1.NWDMY { @ NWDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NWDMY     
}
CSR.R.1.RPDMY { @ RPDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RPDMY     
}
CSR.R.1.PMDMY { @ PMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PMDMY     
}
CSR.R.1.SDI { @ SDI is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SDI     
}
CSR.R.1.ESD1DMY { @ ESD1DMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESD1DMY     
}
CSR.R.1.ESD2DMY { @ ESD2DMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESD2DMY     
}
CSR.R.1.LMARK { @ LMARK is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND LMARK     
}
CSR.R.1.SRM { @ SRM is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRM     
}
CSR.R.1.CSRDMY { @ CSRDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CSRDMY     
}
CSR.R.1.CDUDMY { @ CDUDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CDUDMY     
}
CSR.R.1.TCDDMY { @ TCDDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND TCDDMY     
}
CSR.R.1.LOGO { @ LOGO is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND LOGO     
}
CSR.R.1.INDDMY { @ INDDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND INDDMY     
}
CSR.R.1.CTMDMY { @ CTMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMDMY     
}
CSR.R.1.CTMDMY_10 { @ CTMDMY_10 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMDMY_10     
}
CSR.R.1.CTMDMY_15 { @ CTMDMY_15 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMDMY_15     
}
CSR.R.1.CTMDMY_20 { @ CTMDMY_20 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMDMY_20     
}
CSR.R.1.MOMDMY_1 { @ MOMDMY_1 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_1     
}
CSR.R.1.MOMDMY_2 { @ MOMDMY_2 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_2     
}
CSR.R.1.MOMDMY_3 { @ MOMDMY_3 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_3     
}
CSR.R.1.MOMDMY_4 { @ MOMDMY_4 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_4     
}
CSR.R.1.MOMDMY_5 { @ MOMDMY_5 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_5     
}
CSR.R.1.MOMDMY_6 { @ MOMDMY_6 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_6     
}
CSR.R.1.MOMDMY_AP { @ MOMDMY_AP is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_AP     
}
CSR.R.1.RTMOMDMY { @ RTMOMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RTMOMDMY     
}
CSR.R.1.RFDMY { @ RFDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RFDMY     
}
CSR.R.1.WBDMY { @ WBDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND WBDMY     
}
CSR.R.1.DIODMY { @ DIODMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DIODMY     
}
CSR.R.1.SRAMDMY { @ SRAMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY     
}
CSR.R.1.SRAMDMY_4 { @ SRAMDMY_4 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY_4     
}
CSR.R.1.SRAMDMY_5 { @ SRAMDMY_5 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY_5     
}
CSR.R.1.SRAMDMY_1 { @ SRAMDMY_1 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY_1     
}
CSR.R.1.RAM1TDMY { @ RAM1TDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RAM1TDMY     
}
CSR.R.1.OD1Ti { @ OD1Ti is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD1Ti     
}
CSR.R.1.CLDDi { @ CLDDi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CLDDi     
}
CSR.R.1.CROWNi { @ CROWNi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CROWNi     
}
CSR.R.1.P3i { @ P3i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND P3i     
}
CSR.R.1.SNCTi { @ SNCTi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SNCTi     
}
CSR.R.1.LUPWDMY { @ LUPWDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND LUPWDMY     
}
CSR.R.1.VDDDMY { @ VDDDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VDDDMY     
}
CSR.R.1.VSSDMY { @ VSSDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VSSDMY     
}
CSR.R.1.M1i { @ M1i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M1i     
}
CSR.R.1.M1_real { @ M1_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M1_real     
}
CSR.R.1.DM1_O { @ DM1_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DM1_O     
}
CSR.R.1.DUM1 { @ DUM1 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM1     
}
CSR.R.1.M2i { @ M2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M2i     
}
CSR.R.1.M2_real { @ M2_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M2_real     
}
CSR.R.1.DM2_O { @ DM2_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DM2_O     
}
CSR.R.1.DUM2 { @ DUM2 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM2     
}
CSR.R.1.M3i { @ M3i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M3i     
}
CSR.R.1.M3_real { @ M3_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M3_real     
}
CSR.R.1.DM3_O { @ DM3_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DM3_O     
}
CSR.R.1.DUM3 { @ DUM3 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM3     
}
CSR.R.1.M4i { @ M4i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M4i     
}
CSR.R.1.M4_real { @ M4_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M4_real     
}
CSR.R.1.DM4_O { @ DM4_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DM4_O     
}
CSR.R.1.DUM4 { @ DUM4 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM4     
}
CSR.R.1.M5_OLD { @ M5_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M5_OLD     
}
CSR.R.1.M5_NEW { @ M5_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M5_NEW     
}
CSR.R.1.DUM5_OLD { @ DUM5_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM5_OLD     
}
CSR.R.1.DUM5_NEW { @ DUM5_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM5_NEW     
}
CSR.R.1.M6_OLD { @ M6_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M6_OLD     
}
CSR.R.1.M6_NEW { @ M6_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M6_NEW     
}
CSR.R.1.DUM6_OLD { @ DUM6_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM6_OLD     
}
CSR.R.1.DUM6_NEW { @ DUM6_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM6_NEW     
}
CSR.R.1.M7_OLD { @ M7_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M7_OLD     
}
CSR.R.1.M7_NEW { @ M7_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M7_NEW     
}
CSR.R.1.DUM7_OLD { @ DUM7_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM7_OLD     
}
CSR.R.1.DUM7_NEW { @ DUM7_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM7_NEW     
}
CSR.R.1.VIA1i { @ VIA1i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA1i     
}
CSR.R.1.VIA2i { @ VIA2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA2i     
}
CSR.R.1.VIA3i { @ VIA3i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA3i     
}
CSR.R.1.VIA4_OLD { @ VIA4_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA4_OLD     
}
CSR.R.1.VIA4_NEW { @ VIA4_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA4_NEW     
}
CSR.R.1.VIA5_OLD { @ VIA5_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA5_OLD     
}
CSR.R.1.VIA5_NEW { @ VIA5_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA5_NEW     
}
CSR.R.1.VIA6_OLD { @ VIA6_OLD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA6_OLD     
}
CSR.R.1.VIA6_NEW { @ VIA6_NEW is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA6_NEW     
}
CSR.R.1.ODi { @ ODi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ODi     
}
CSR.R.1.DOD { @ DOD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DOD     
}
CSR.R.1.POi { @ POi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND POi     
}
CSR.R.1.DPO { @ DPO is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DPO     
}
CSR.R.1.mVTLi { @ mVTLi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND mVTLi     
}

#ENDIF

LMARK_METAL_CSR = LMARK_METAL AND CSRDMY // L-mark in CSR
LMARK_SLOT_CSR = LSLOT AND CSRDMY  // L shaped oxide in L-mark metal
LMARK_MS_CSR = LMARK_METAL_CSR OR LMARK_SLOT_CSR

// Chip corner stress relief check
#IFDEF WLCSP_SEALRING
CSR_ED = CONVEX EDGE CSRDMY ANGLE1 == 135 ANGLE2 == 45  
#ELSE
CSR_ED = CONVEX EDGE CSRDMY ANGLE1 == 90 ANGLE2 == 45  
#ENDIF
CSR_EXD = EXPAND EDGE CSR_ED INSIDE BY 2    // exclude the Seal Ring part   
CC_CO = ((CO AND CSRDMY) NOT VIA_EXD) NOT CSR_EXD  
CC_M1 = M1 AND CSRDMY
CC_V1 = ((VIA1 AND CSRDMY) NOT VIA_EXD) NOT CSR_EXD 
CC_M1_HOLE  = HOLES (SIZE CC_M1 BY 0.6 UNDEROVER)
CC_M1_LSLOT = AREA CC_M1_HOLE > 300
CC_M1_FENCE_HOLE  = AREA CC_M1_HOLE <= 300 
CC_M1_FENCE_CROSS = SIZE ((CC_M1 NOT (EXPAND EDGE CC_M1_FENCE_HOLE OUTSIDE BY 2.5)) NOT INTERACT SEALRING ) BY 0.4 UNDEROVER
CC_M2 = M2 AND CSRDMY
CC_V2 = ((VIA2 AND CSRDMY) NOT VIA_EXD) NOT CSR_EXD 
CC_M2_HOLE  = HOLES (SIZE CC_M2 BY 0.6 UNDEROVER)
CC_M2_LSLOT = AREA CC_M2_HOLE > 300
CC_M2_FENCE_HOLE  = AREA CC_M2_HOLE <= 300 
CC_M2_FENCE_CROSS = SIZE ((CC_M2 NOT (EXPAND EDGE CC_M2_FENCE_HOLE OUTSIDE BY 2.5)) NOT INTERACT SEALRING ) BY 0.4 UNDEROVER
CC_M3 = M3 AND CSRDMY
CC_V3 = ((VIA3 AND CSRDMY) NOT VIA_EXD) NOT CSR_EXD 
CC_M3_HOLE  = HOLES (SIZE CC_M3 BY 0.6 UNDEROVER)
CC_M3_LSLOT = AREA CC_M3_HOLE > 300
CC_M3_FENCE_HOLE  = AREA CC_M3_HOLE <= 300 
CC_M3_FENCE_CROSS = SIZE ((CC_M3 NOT (EXPAND EDGE CC_M3_FENCE_HOLE OUTSIDE BY 2.5)) NOT INTERACT SEALRING ) BY 0.4 UNDEROVER
CC_M4 = M4 AND CSRDMY
CC_V4 = ((VIA4 AND CSRDMY) NOT VIA_EXD) NOT CSR_EXD 
CC_M4_HOLE  = HOLES (SIZE CC_M4 BY 0.6 UNDEROVER)
CC_M4_LSLOT = AREA CC_M4_HOLE > 300
CC_M4_FENCE_HOLE  = AREA CC_M4_HOLE <= 300 
CC_M4_FENCE_CROSS = SIZE ((CC_M4 NOT (EXPAND EDGE CC_M4_FENCE_HOLE OUTSIDE BY 2.5)) NOT INTERACT SEALRING ) BY 0.4 UNDEROVER
CC_M5 = M5 AND CSRDMY
CC_V5 = ((VIA5 AND CSRDMY) NOT VIA_EXD) NOT CSR_EXD 
CC_M5_HOLE  = HOLES (SIZE CC_M5 BY 0.6 UNDEROVER)
CC_M5_LSLOT = AREA CC_M5_HOLE > 300
CC_M5_FENCE_HOLE  = AREA CC_M5_HOLE <= 300 
CC_M5_FENCE_CROSS = SIZE ((CC_M5 NOT (EXPAND EDGE CC_M5_FENCE_HOLE OUTSIDE BY 2.5)) NOT INTERACT SEALRING ) BY 0.4 UNDEROVER
CC_M6 = M6i AND CSRDMY

 
CSR.R.2A { @ CSR structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD 
  CSRDMY NOT INTERACT ODi 
  CSRDMY NOT INTERACT PPi 
  CSRDMY NOT INTERACT M1x 
  CSRDMY NOT INTERACT M2x 
  CSRDMY NOT INTERACT M3x 
  CSRDMY NOT INTERACT M4x 
  CSRDMY NOT INTERACT M5x 
  CSRDMY NOT INTERACT M6x 
  CSRDMY NOT ENCLOSE COi 
  CSRDMY NOT ENCLOSE VIA1i 
  CSRDMY NOT ENCLOSE VIA2i 
  CSRDMY NOT ENCLOSE VIA3i 
  CSRDMY NOT ENCLOSE VIA4i 
  CSRDMY NOT ENCLOSE VIA5i 
}

CSR.R.2B { @ M1~M5 must be stacked and coincident the edge.
   XOR CC_M1 CC_M2 
   XOR CC_M2 CC_M3 
   XOR CC_M3 CC_M4 
   XOR CC_M4 CC_M5 
}
CSR.R.2C { @ CSR structure must be covered with CSRDMY
  SR_EDGE NOT INTERACT CSRDMY
}
CSR.R.2D { @ M1~M5 fence metal width & space = ^CSR_R_2
    NOT RECTANGLE CC_M1_FENCE_HOLE   == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M1_FENCE_CROSS  == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M2_FENCE_HOLE   == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M2_FENCE_CROSS  == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M3_FENCE_HOLE   == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M3_FENCE_CROSS  == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M4_FENCE_HOLE   == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M4_FENCE_CROSS  == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M5_FENCE_HOLE   == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY
    NOT RECTANGLE CC_M5_FENCE_CROSS  == CSR_R_2 BY == CSR_R_2 ORTHOGONAL ONLY

}
CSR.R.2E { @ The CSR pattern must be covered by solid L-mark Metal.
   CC_M5_FENCE_HOLE NOT LMARK_METAL_CSR
}

CSR.R.2F { @ The L-slot can't overlap AP or PO
  LMARK_SLOT_CSR AND APi 
  LMARK_SLOT_CSR AND POi
}


CSR.S.1 { @ CO space >= 0.36
   EXT CC_CO < CSR_S_1 ABUT < 90 SINGULAR REGION  
}
CSR.EN.1 { @ CO enclosure by M1[crossing area] >=0.53 
   ENC CC_CO CC_M1_FENCE_CROSS  < CSR_EN_1 ABUT < 90 SINGULAR REGION 
}

CSR.S.2 { @ VIAx space at the same level >= 0.35
   EXT CC_V1 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V2 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V3 < CSR_S_2 ABUT < 90 SINGULAR REGION 
}
CSR.EN.2 { @ VIAx enclosure by metal[crossing area] >=0.525
     ENC CC_V1 CC_M1_FENCE_CROSS < CSR_EN_2 ABUT < 90 SINGULAR REGION  
     CC_V1 CUT CC_M1_FENCE_CROSS
     ENC CC_V2 CC_M2_FENCE_CROSS < CSR_EN_2 ABUT < 90 SINGULAR REGION  
     CC_V2 CUT CC_M2_FENCE_CROSS
     ENC CC_V3 CC_M3_FENCE_CROSS < CSR_EN_2 ABUT < 90 SINGULAR REGION  
     CC_V3 CUT CC_M3_FENCE_CROSS
}


CSR.S.4 { @ VIAz space >= ^CSR_S_4
   EXT CC_V4 < CSR_S_4 ABUT < 90 SINGULAR REGION 
   EXT CC_V5 < CSR_S_4 ABUT < 90 SINGULAR REGION 
}
CSR.EN.4 { @ VIAz enclosure by metal[crossing area] >= ^CSR_EN_4
   ENC CC_V4 CC_M4_FENCE_CROSS < CSR_EN_4 ABUT < 90 SINGULAR REGION  
   CC_V4 CUT CC_M4_FENCE_CROSS
   ENC CC_V5 CC_M5_FENCE_CROSS < CSR_EN_4 ABUT < 90 SINGULAR REGION  
   CC_V5 CUT CC_M5_FENCE_CROSS
}


CSR.R.3.CO { @ CO number at M1 crossing area = ^CSR_R_3_X 
   CC_M1_FENCE_CROSS INTERACT CO < CSR_R_3_X
   CC_M1_FENCE_CROSS INTERACT CO > CSR_R_3_X
   CC_M1_FENCE_CROSS NOT INTERACT CO
}
CSR.R.3.VIA1 { @ VIA1 number at M1 crossing area = ^CSR_R_3_X
   CC_M1_FENCE_CROSS INTERACT VIA1 < CSR_R_3_X
   CC_M1_FENCE_CROSS INTERACT VIA1 > CSR_R_3_X
   CC_M1_FENCE_CROSS NOT INTERACT VIA1
}
CSR.R.3.VIA2 { @ VIA2 number at M2 crossing area = ^CSR_R_3_X
   CC_M2_FENCE_CROSS INTERACT VIA2 < CSR_R_3_X
   CC_M2_FENCE_CROSS INTERACT VIA2 > CSR_R_3_X
   CC_M2_FENCE_CROSS NOT INTERACT VIA2
}
CSR.R.3.VIA3 { @ VIA3 number at M3 crossing area = ^CSR_R_3_X
   CC_M3_FENCE_CROSS INTERACT VIA3 < CSR_R_3_X
   CC_M3_FENCE_CROSS INTERACT VIA3 > CSR_R_3_X
   CC_M3_FENCE_CROSS NOT INTERACT VIA3
}
CSR.R.3.VIA4 { @ VIA4 number at M4 crossing area = ^CSR_R_3_Z
    CC_M4_FENCE_CROSS INTERACT VIA4 < CSR_R_3_Z
    CC_M4_FENCE_CROSS INTERACT VIA4 > CSR_R_3_Z
    CC_M4_FENCE_CROSS NOT INTERACT VIA4
}
CSR.R.3.VIA5 { @ VIA5 number at M5 crossing area = ^CSR_R_3_Z
    CC_M5_FENCE_CROSS INTERACT VIA5 < CSR_R_3_Z
    CC_M5_FENCE_CROSS INTERACT VIA5 > CSR_R_3_Z
    CC_M5_FENCE_CROSS NOT INTERACT VIA5
}


CSR.W.1 { @ Width of L-slot = ^CSR_W_1
   SIZE LMARK_SLOT_CSR BY CSR_W_1/2 UNDEROVER
   INT LMARK_SLOT_CSR < CSR_W_1 ABUT < 90 ANGLED == 0 REGION
}
CSR.W.2 { @ Width of 45 degree corner of L-slot, >= ^CSR_W_2_1 um <= ^CSR_W_2_2 um
   X = ANGLE LMARK_SLOT_CSR == 45
   Y = EXPAND EDGE X INSIDE BY CSR_W_2_2+GRID    
   Y OUTSIDE LMARK_METAL_CSR
   INT LMARK_SLOT_CSR < CSR_W_2_1 ABUT < 90 ANGLED == 2 REGION
}

// CSR.W.3 is checked by CO.W.2/VIAx.W.2/VIAy.W.2/VIAz.W.2/VIAr.W.2

CSR.L.1 { @ Length of L-slot, >= ^CSR_L_1_1 um <= ^CSR_L_1_2 um
   NOT ENCLOSE RECTANGLE LMARK_SLOT_CSR 10 CSR_L_1_1
   ENCLOSE RECTANGLE LMARK_SLOT_CSR 10 CSR_L_1_2+GRID
} 

#IFDEF WLCSP_SEALRING
CSR.EN.5.1 { @ L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length] >= ^CSR_EN_5_1 um <= ^CSR_EN_5_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 90
   ENC X LMARK_MS_CSR < CSR_EN_5_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_5_2 < 100 ABUT < 90 OPPOSITE REGION
}
#ELSE
CSR.EN.5 { @ L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length] >= ^CSR_EN_5_1 um <= ^CSR_EN_5_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 90
   ENC X LMARK_MS_CSR < CSR_EN_5_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_5_2 < 100 ABUT < 90 OPPOSITE REGION
}
#ENDIF
#IFDEF WLCSP_SEALRING
TM_SR_EXT = (EXTENT M6) INTERACT CSRDMY
TM_SR_CORNER_A = INT TM_SR_EXT <= CSR_EN_6_1_L1 ABUT == 90 REGION INTERSECTING ONLY
TM_SR_CORNER_B = INT TM_SR_EXT <= CSR_EN_6_1_L2 ABUT == 90 REGION INTERSECTING ONLY

CSR.EN.6.1.M1i { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M1i
   TM_SR_CORNER_B NOT INTERACT M1i
}
CSR.EN.6.1.M2i { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M2i
   TM_SR_CORNER_B NOT INTERACT M2i
}
CSR.EN.6.1.M3i { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M3i
   TM_SR_CORNER_B NOT INTERACT M3i
}
CSR.EN.6.1.M4i { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M4i
   TM_SR_CORNER_B NOT INTERACT M4i
}
CSR.EN.6.1.M5i { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M5i
   TM_SR_CORNER_B NOT INTERACT M5i
}
CSR.EN.6.1.M6i { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M6i
   TM_SR_CORNER_B NOT INTERACT M6i
}
CSR.EN.6.1.APi { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND APi
}
#ELSE
CSR.EN.6 { @ L-mark metal in CSR enclosure of L-slot 
           @ [perpendicular to the direction of the L-slot length] >= ^CSR_EN_6_A um <= ^CSR_EN_6_B um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 225
   ENC X LMARK_MS_CSR < CSR_EN_6_A ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_6_B < 100 ABUT < 90 OPPOSITE REGION   
}
#ENDIF
CSR.EN.7.VIA1 { @ Metal enclosure of VIA1 around L-slot >= ^CSR_EN_7_X um
     EXT CC_M1_LSLOT SR_VIA1 < CSR_EN_7_X ABUT < 90 OPPOSITE REGION
     CC_M1_LSLOT AND SR_VIA1
}
CSR.EN.7.VIA2 { @ Metal enclosure of VIA2 around L-slot >= ^CSR_EN_7_X um
     EXT CC_M2_LSLOT SR_VIA2 < CSR_EN_7_X ABUT < 90 OPPOSITE REGION
     CC_M2_LSLOT AND SR_VIA2
}
CSR.EN.7.VIA3 { @ Metal enclosure of VIA3 around L-slot >= ^CSR_EN_7_X um
     EXT CC_M3_LSLOT SR_VIA3 < CSR_EN_7_X ABUT < 90 OPPOSITE REGION
     CC_M3_LSLOT AND SR_VIA3
}
CSR.EN.7.VIA4 { @ Metal enclosure of VIA4 around L-slot >= ^CSR_EN_7_Z um
    EXT CC_M4_LSLOT SR_VIA4 < CSR_EN_7_Z ABUT < 90 OPPOSITE REGION
    CC_M4_LSLOT AND SR_VIA4
}
CSR.EN.7.VIA5 { @ Metal enclosure of VIA5 around L-slot >= ^CSR_EN_7_Z um
    EXT CC_M5_LSLOT SR_VIA5 < CSR_EN_7_Z ABUT < 90 OPPOSITE REGION
    CC_M5_LSLOT AND SR_VIA5
}


CSR.EN.8 { @ Metal enclosure by L-mark metal in CSR around L-slot >= ^CSR_EN_8 um
   EXT LMARK_SLOT_CSR M1i < CSR_EN_8 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M1i
   EXT LMARK_SLOT_CSR M2i < CSR_EN_8 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M2i
   EXT LMARK_SLOT_CSR M3i < CSR_EN_8 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M3i
   EXT LMARK_SLOT_CSR M4i < CSR_EN_8 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M4i
   EXT LMARK_SLOT_CSR M5i < CSR_EN_8 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M5i
}



// CSR.R.3 can not be checked




// Seal-Ring Rule Check
//=====================


ASSH = HOLES ((M1i AND SR_RING) INTERACT SEALRING) INNER
ASS  = SIZE ASSH BY SR_S_1 UNDEROVER // remove un-wanted hole in corner
CORR = SIZE ASS BY -SR_S_1           // core region 
ISOR = ASS NOT CORR              // assembly isolation region

#IFDEF FULL_CHIP
SR.S.1 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
         @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
	 @ 2. Connect circuit to sealring through AP, it is only allowed connecting to the most inner sealring (AP overlap with CB2 is not allowed)  
  ISOR AND DNWi
  ISOR AND NWi
  (ISOR AND POi) NOT INSIDE CDUDMY
  ISOR AND DPO
  (ISOR AND ODi) NOT INSIDE CDUDMY
  ISOR AND DOD
  ISOR AND CBMi
  ISOR AND CTMi
  (ISOR AND COi) NOT INSIDE CDUDMY
  ISOR AND VIA1i			
  ISOR AND VIA2i			
  ISOR AND VIA3i			
  ISOR AND VIA4i			
  ISOR AND VIA5i			
  ISOR AND UBMi
  ISOR AND CBDi
  ISOR AND CBi
  ISOR AND CB2i
}

SR.S.1.M1 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M1i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM1 AND ISOR
}

SR.S.1.M2 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M2i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM2 AND ISOR
}

SR.S.1.M3 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M3i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM3 AND ISOR
}

SR.S.1.M4 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M4i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM4 AND ISOR
}

SR.S.1.M5 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M5i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM5 AND ISOR
}

SR.S.1.M6 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M6i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM6 AND ISOR
}


#IFDEF WLCSP_SEALRING
SR.S.1.AP {@ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
	   @ 2. Connect circuit to sealring through AP, it is only allowed connecting to the most inner sealring (AP overlap with CB2 is not allowed)  
  (APi NOT INTERACT SEALRING) AND ISOR
  (APi AND SRCSR) AND CB2i
}

SR.AP.WARN { @ AP is must in seal-ring if flip chip or AlCu RDL or AlCu fuse is used 
             @ AP enclosure of CB/CBD in seal-ring >= 1
  SR_EDGEx = SR_EDGE INTERACT (CHIP INTERACT AP) // flip chip or AlCu RDL or AlCu fuse is used
  SRx_CB  = CBi  INSIDE SR_EDGEx 
  SRx_CBD = CBDi INSIDE SR_EDGEx 	 
  SRx_RV  = RVi  INSIDE SR_EDGEx
  SRx_CB  NOT AP
  SRx_CBD NOT AP
  SRx_RV  NOT AP
  ENC SRx_CB  AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CBD AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_RV  AP < 1 ABUT < 90 SINGULAR REGION
}

#ELSE

SR.S.1.AP {@ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
	   @ 2. Connect circuit to sealring through AP is not allowed  
  APi AND ISOR
}

SR.AP.WARN { @ AP is must in seal-ring if flip chip or AlCu RDL or AlCu fuse is used 
             @ AP enclosure of CB/CBD/CB2 in seal-ring >= 1
  SR_EDGEx = SR_EDGE INTERACT (CHIP INTERACT AP) // flip chip or AlCu RDL or AlCu fuse is used
  SRx_CB  = CBi  INSIDE SR_EDGEx 
  SRx_CBD = CBDi INSIDE SR_EDGEx 
  SRx_CB2 = CB2i INSIDE SR_EDGEx		 
  SRx_RV  = RVi  INSIDE SR_EDGEx
  SRx_CB  NOT AP
  SRx_CBD NOT AP
  SRx_CB2 NOT AP
  SRx_RV  NOT AP
  ENC SRx_CB  AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CBD AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CB2 AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_RV  AP < 1 ABUT < 90 SINGULAR REGION
}

#ENDIF

SR.CB2.WARN {@ CB2 is must in seal-ring if AlCu RDL or AlCu fuse is used
  CHIP_ALRDL = CHIP INTERACT ( RVi OR FWALi)  // AlCu RDL or AlCu fuse is used
  SR_EDGEx =  SR_EDGE INTERACT CHIP_ALRDL  
  SR_EDGEx NOT INTERACT CB2i
}

SR.CB.WARN { @ CB is must in seal-ring if wire bond is used 
   CHIP_INT_CB = (CHIP INTERACT CBi) NOT INTERACT UBMi 
   SR_EDGEx = SR_EDGE INTERACT CHIP_INT_CB  
   SR_EDGEx NOT INTERACT CBi
}

SR.CBD_RV.WARN { @  CBD is must in seal-ring if flip chip (without AlCu fuse or AlCu RDL) is used
                     @  Either CBD or RV is must in seal-ring if flip chip(with AlCu fuse or AlCu RDL) is used
   CHIP_UBM = CHIP INTERACT UBMi
   CHIP_UBM_1 = CHIP_UBM INTERACT ( RVi OR FWALi) 
   CHIP_UBM_2 = CHIP_UBM NOT INTERACT ( RVi OR FWALi) 
   SR_EDGEx1 = SR_EDGE INTERACT CHIP_UBM_1
   SR_EDGEx1 NOT INTERACT (CBDi OR RVi)
   SR_EDGEx2 = SR_EDGE INTERACT CHIP_UBM_2
   SR_EDGEx2 NOT INTERACT CBDi
   
}

SR.UBM.WARN { @ Do not draw UBM on Chip corner stress relief pattern/Seal ring/Assembly isolation  
  SRCSR AND UBMi
}

SR.CO_VIA.WARN { @ line-co and line-viax must be continuous
   LINE_CO = NOT RECTANGLE SR_CO == CO_W_1 BY == CO_W_1
   CONVEX EDGE LINE_CO ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*CO_W_2
   LINE_VIA1 = NOT RECTANGLE SR_VIA1 == VIA1_W_1 BY == VIA1_W_1
   CONVEX EDGE LINE_VIA1 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA1_W_2
   LINE_VIA2 = NOT RECTANGLE SR_VIA2 == VIA2_W_1 BY == VIA2_W_1
   CONVEX EDGE LINE_VIA2 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA2_W_2
   LINE_VIA3 = NOT RECTANGLE SR_VIA3 == VIA3_W_1 BY == VIA3_W_1
   CONVEX EDGE LINE_VIA3 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA3_W_2
   LINE_VIA4 = NOT RECTANGLE SR_VIA4 == VIA4_W_1 BY == VIA4_W_1
   CONVEX EDGE LINE_VIA4 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA4_W_2
   LINE_VIA5 = NOT RECTANGLE SR_VIA5 == VIA5_W_1 BY == VIA5_W_1
   CONVEX EDGE LINE_VIA5 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 20*VIA5_W_2
}

SR.R.0 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD. SEALRING layer is a must if either you add sealring by themselves, or metal fuse is used.   
  SEALRING NOT ODi 
  SEALRING NOT PPi 
  SEALRING NOT M1x 
  SEALRING NOT M2x 
  SEALRING NOT M3x 
  SEALRING NOT M4x 
  SEALRING NOT M5x 
  SEALRING NOT M6x 
  SR_M1 NOT ENCLOSE COi 
  SR_M2 NOT ENCLOSE VIA1i 
  SR_M3 NOT ENCLOSE VIA2i 
  SR_M4 NOT ENCLOSE VIA3i 
  SR_M5 NOT ENCLOSE VIA4i 
  SR_M6 NOT ENCLOSE VIA5i 
#IFDEF FULL_CHIP
  SEALRING NOT SRCSR 
#ENDIF
}
//SR.R.1 was check by SR.R.0

SR.EN.1 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  SR_OD = OD INTERACT SEALRING
  SR_OD_HOLES = HOLES SR_OD
  SR_OD_FULL = SR_OD OR SR_OD_HOLES
  ENC SR_M1 SR_OD_FULL < SR_EN_1 REGION
  ENC SR_M2 SR_OD_FULL < SR_EN_1 REGION
  ENC SR_M3 SR_OD_FULL < SR_EN_1 REGION
  ENC SR_M4 SR_OD_FULL < SR_EN_1 REGION
  ENC SR_M5 SR_OD_FULL < SR_EN_1 REGION
  ENC SR_M6 SR_OD_FULL < SR_EN_1 REGION
  SR_OD_FULL XOR (EXTENT SR_OD_FULL)
}

#ENDIF









//CDU CHECKS
//==========

#IFDEF FULL_CHIP
CDU.R.1 { @ CDUDMY must be inside the assembly isolation beside seal ring.
  CDUDMY NOT INSIDE ISOR 
  ISOR NOT INTERACT CDUDMY
}
#ENDIF

CDU.R.2 { @ OD/POLY/CO/M1 must be inside layer CDUDMY. 
  CDUDMY NOT ENCLOSE ODi
  CDUDMY NOT ENCLOSE POi
  CDUDMY NOT ENCLOSE COi
  CDUDMY NOT ENCLOSE M1i
}

CDU.WARN1 { @ CDU width == 5.6
  INT CDUDMY < 5.6 ABUT<90 SINGULAR REGION   
  SIZE CDUDMY BY 2.8 UNDEROVER
}

CDU.WARN2 { @ The space from the CDU long edge to the sealring inner edge is 2.2
  ENC CDUDMY ISOR <2.2 ABUT<90 SINGULAR REGION 
}



//DUMMY M1 CHECKS
//==================

DM1.W.1 { @ Width >= ^DM1_W_1 um
  INT DUM1 < DM1_W_1 ABUT < 90 SINGULAR REGION
}
DM1.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM1 BY DM1_W_2 /2 UNDEROVER
}
DM1.S.1 { @ Space >= ^DM1_S_1 um
  EXT DUM1 < DM1_S_1 ABUT < 90 SINGULAR REGION
}
DM1.S.2 { @ Space to M1 >= ^DM1_S_2 um
  EXT M1i DUM1 < DM1_S_2 ABUT < 90 SINGULAR REGION
  M1i AND DUM1
}


DM1.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM1_S_3_W um and the parallel metal run length > ^DM1_S_3_L um] >=  ^DM1_S_3
  X = EXT M1Wide_4.5 DUM1 < DM1_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM1_S_2 DM1_S_3_L+0.005
}

DM1.S.3.1 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM1_S_3_1_W um and the parallel metal run length > ^DM1_S_3_1_L um] >= ^DM1_S_3_1
  X = EXT M1Wide_1.5 DUM1 < DM1_S_3_1 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM1_S_2 DM1_S_3_1_L+0.005
}

DM1.S.4 { @ Space to FW (Overlap is not allowed) >= 5.0 
  EXT FWi DUM1 < DM1_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM1
}

// for solid L-mark (old)
DM1.S.5 { @ Space to LMARK (Overlap is not allowed) >= ^DM1_S_5 um
  EXT LMARK_SOLID DUM1 < DM1_S_5 ABUT < 90 SINGULAR REGION 
  DUM1 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM1.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= ^DM1_S_5_1 um
  EXT LSLOT DUM1 < DM1_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM1 AND LSLOT  
}

DM1.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DUM1
}
DM1.S.8 { @ Space to INDDMY (Overlap is not allowed) >= 2.5 
  EXT INDDMY DUM1 < DM1_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM1
}

DM1.S.10 { @ Space to 45-degree bent Mx >= ^DM1_S_10 um2
    X = EXPAND EDGE M1_EDGE_45 OUTSIDE BY DM1_S_10
    X AND DUM1
}
#IFDEF FULL_CHIP
DM1.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM1 NOT (SIZE CHIP_CHAMFERED BY -DM1_EN_1)
}
#ENDIF
DM1.A.1 { @ Min. area >= ^DM1_A_1 um2
  AREA DUM1 < DM1_A_1 
}
DM1.A.2 { @ Max. area <= ^DM1_A_2 um2
  AREA DUM1 > DM1_A_2 
}
#IFDEF FULL_CHIP
DM1.R.1 { @ DM1 is a must. The DM1 CAD layer (TSMC default, 31;1 for DM1) must be different from the M1 CAD layer.
  CHIPx NOT INTERACT DUM1
}
#ENDIF

// DM1.R.2 is checked by CSR.R.1

DM1.R.3 { @ 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)
  NOT RECTANGLE DUM1
  HOLES DUM1
}

DM1_O.R.1 { @ DM1_O interact M1 is not allowed
  DM1_O INTERACT M1_real
}

//DUMMY M2 CHECKS
//==================

DM2.W.1 { @ Width >= ^DM2_W_1 um
  INT DUM2 < DM2_W_1 ABUT < 90 SINGULAR REGION
}
DM2.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM2 BY DM2_W_2 /2 UNDEROVER
}
DM2.S.1 { @ Space >= ^DM2_S_1 um
  EXT DUM2 < DM2_S_1 ABUT < 90 SINGULAR REGION
}
DM2.S.2 { @ Space to M2 >= ^DM2_S_2 um
  EXT M2i DUM2 < DM2_S_2 ABUT < 90 SINGULAR REGION
  M2i AND DUM2
}


DM2.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM2_S_3_W um and the parallel metal run length > ^DM2_S_3_L um] >=  ^DM2_S_3
  X = EXT M2Wide_4.5 DUM2 < DM2_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM2_S_2 DM2_S_3_L+0.005
}

DM2.S.3.1 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM2_S_3_1_W um and the parallel metal run length > ^DM2_S_3_1_L um] >= ^DM2_S_3_1
  X = EXT M2Wide_1.5 DUM2 < DM2_S_3_1 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM2_S_2 DM2_S_3_1_L+0.005
}

DM2.S.4 { @ Space to FW (Overlap is not allowed) >= 5.0 
  EXT FWi DUM2 < DM2_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM2
}

// for solid L-mark (old)
DM2.S.5 { @ Space to LMARK (Overlap is not allowed) >= ^DM2_S_5 um
  EXT LMARK_SOLID DUM2 < DM2_S_5 ABUT < 90 SINGULAR REGION 
  DUM2 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM2.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= ^DM2_S_5_1 um
  EXT LSLOT DUM2 < DM2_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM2 AND LSLOT  
}

DM2.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DUM2
}
DM2.S.8 { @ Space to INDDMY (Overlap is not allowed) >= 2.5 
  EXT INDDMY DUM2 < DM2_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM2
}

DM2.S.10 { @ Space to 45-degree bent Mx >= ^DM2_S_10 um2
    X = EXPAND EDGE M2_EDGE_45 OUTSIDE BY DM2_S_10
    X AND DUM2
}
#IFDEF FULL_CHIP
DM2.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM2 NOT (SIZE CHIP_CHAMFERED BY -DM2_EN_1)
}
#ENDIF
DM2.A.1 { @ Min. area >= ^DM2_A_1 um2
  AREA DUM2 < DM2_A_1 
}
DM2.A.2 { @ Max. area <= ^DM2_A_2 um2
  AREA DUM2 > DM2_A_2 
}
#IFDEF FULL_CHIP
DM2.R.1 { @ DM2 is a must. The DM2 CAD layer (TSMC default, 32;1 for DM2) must be different from the M2 CAD layer.
  CHIPx NOT INTERACT DUM2
}
#ENDIF

// DM2.R.2 is checked by CSR.R.1

DM2.R.3 { @ 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)
  NOT RECTANGLE DUM2
  HOLES DUM2
}

DM2_O.R.1 { @ DM2_O interact M2 is not allowed
  DM2_O INTERACT M2_real
}

//DUMMY M3 CHECKS
//==================

DM3.W.1 { @ Width >= ^DM3_W_1 um
  INT DUM3 < DM3_W_1 ABUT < 90 SINGULAR REGION
}
DM3.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM3 BY DM3_W_2 /2 UNDEROVER
}
DM3.S.1 { @ Space >= ^DM3_S_1 um
  EXT DUM3 < DM3_S_1 ABUT < 90 SINGULAR REGION
}
DM3.S.2 { @ Space to M3 >= ^DM3_S_2 um
  EXT M3i DUM3 < DM3_S_2 ABUT < 90 SINGULAR REGION
  M3i AND DUM3
}


DM3.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM3_S_3_W um and the parallel metal run length > ^DM3_S_3_L um] >=  ^DM3_S_3
  X = EXT M3Wide_4.5 DUM3 < DM3_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM3_S_2 DM3_S_3_L+0.005
}

DM3.S.3.1 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM3_S_3_1_W um and the parallel metal run length > ^DM3_S_3_1_L um] >= ^DM3_S_3_1
  X = EXT M3Wide_1.5 DUM3 < DM3_S_3_1 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM3_S_2 DM3_S_3_1_L+0.005
}

DM3.S.4 { @ Space to FW (Overlap is not allowed) >= 5.0 
  EXT FWi DUM3 < DM3_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM3
}

// for solid L-mark (old)
DM3.S.5 { @ Space to LMARK (Overlap is not allowed) >= ^DM3_S_5 um
  EXT LMARK_SOLID DUM3 < DM3_S_5 ABUT < 90 SINGULAR REGION 
  DUM3 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM3.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= ^DM3_S_5_1 um
  EXT LSLOT DUM3 < DM3_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM3 AND LSLOT  
}

DM3.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DUM3
}
DM3.S.8 { @ Space to INDDMY (Overlap is not allowed) >= 2.5 
  EXT INDDMY DUM3 < DM3_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM3
}

DM3.S.10 { @ Space to 45-degree bent Mx >= ^DM3_S_10 um2
    X = EXPAND EDGE M3_EDGE_45 OUTSIDE BY DM3_S_10
    X AND DUM3
}
#IFDEF FULL_CHIP
DM3.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM3 NOT (SIZE CHIP_CHAMFERED BY -DM3_EN_1)
}
#ENDIF
DM3.A.1 { @ Min. area >= ^DM3_A_1 um2
  AREA DUM3 < DM3_A_1 
}
DM3.A.2 { @ Max. area <= ^DM3_A_2 um2
  AREA DUM3 > DM3_A_2 
}
#IFDEF FULL_CHIP
DM3.R.1 { @ DM3 is a must. The DM3 CAD layer (TSMC default, 33;1 for DM3) must be different from the M3 CAD layer.
  CHIPx NOT INTERACT DUM3
}
#ENDIF

// DM3.R.2 is checked by CSR.R.1

DM3.R.3 { @ 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)
  NOT RECTANGLE DUM3
  HOLES DUM3
}

DM3_O.R.1 { @ DM3_O interact M3 is not allowed
  DM3_O INTERACT M3_real
}

//DUMMY M4 CHECKS
//==================

DM4.W.1 { @ Width >= ^DM4_W_1 um
  INT DUM4 < DM4_W_1 ABUT < 90 SINGULAR REGION
}
DM4.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM4 BY DM4_W_2 /2 UNDEROVER
}
DM4.S.1 { @ Space >= ^DM4_S_1 um
  EXT DUM4 < DM4_S_1 ABUT < 90 SINGULAR REGION
}
DM4.S.2 { @ Space to M4 >= ^DM4_S_2 um
  EXT M4i DUM4 < DM4_S_2 ABUT < 90 SINGULAR REGION
  M4i AND DUM4
}


DM4.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM4_S_3_W um and the parallel metal run length > ^DM4_S_3_L um] >=  ^DM4_S_3
  X = EXT M4Wide_4.5 DUM4 < DM4_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM4_S_2 DM4_S_3_L+0.005
}

DM4.S.3.1 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM4_S_3_1_W um and the parallel metal run length > ^DM4_S_3_1_L um] >= ^DM4_S_3_1
  X = EXT M4Wide_1.5 DUM4 < DM4_S_3_1 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM4_S_2 DM4_S_3_1_L+0.005
}

DM4.S.4 { @ Space to FW (Overlap is not allowed) >= 5.0 
  EXT FWi DUM4 < DM4_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM4
}

// for solid L-mark (old)
DM4.S.5 { @ Space to LMARK (Overlap is not allowed) >= ^DM4_S_5 um
  EXT LMARK_SOLID DUM4 < DM4_S_5 ABUT < 90 SINGULAR REGION 
  DUM4 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM4.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= ^DM4_S_5_1 um
  EXT LSLOT DUM4 < DM4_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM4 AND LSLOT  
}

DM4.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DUM4
}
DM4.S.8 { @ Space to INDDMY (Overlap is not allowed) >= 2.5 
  EXT INDDMY DUM4 < DM4_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM4
}
DM4.S.9 { @ Space to CBM [CBM between Mx and Mx+1] (Overlap is not allowed) >= 1.5 
  EXT CBM DUM4 < DM4_S_9 ABUT < 90 SINGULAR REGION 
  CBM AND DUM4
}

DM4.S.10 { @ Space to 45-degree bent Mx >= ^DM4_S_10 um2
    X = EXPAND EDGE M4_EDGE_45 OUTSIDE BY DM4_S_10
    X AND DUM4
}
#IFDEF FULL_CHIP
DM4.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM4 NOT (SIZE CHIP_CHAMFERED BY -DM4_EN_1)
}
#ENDIF
DM4.A.1 { @ Min. area >= ^DM4_A_1 um2
  AREA DUM4 < DM4_A_1 
}
DM4.A.2 { @ Max. area <= ^DM4_A_2 um2
  AREA DUM4 > DM4_A_2 
}
#IFDEF FULL_CHIP
DM4.R.1 { @ DM4 is a must. The DM4 CAD layer (TSMC default, 34;1 for DM4) must be different from the M4 CAD layer.
  CHIPx NOT INTERACT DUM4
}
#ENDIF

// DM4.R.2 is checked by CSR.R.1

DM4.R.3 { @ 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)
  NOT RECTANGLE DUM4
  HOLES DUM4
}

DM4_O.R.1 { @ DM4_O interact M4 is not allowed
  DM4_O INTERACT M4_real
}

//DUMMY M5 CHECKS
//==================

DM5.W.1 { @ Width >= ^DM5_W_1 um
  INT DUM5 < DM5_W_1 ABUT < 90 SINGULAR REGION
}
DM5.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM5 BY DM5_W_2 /2 UNDEROVER
}
DM5.S.1 { @ Space >= ^DM5_S_1 um
  EXT DUM5 < DM5_S_1 ABUT < 90 SINGULAR REGION
}
DM5.S.2 { @ Space to M5 >= ^DM5_S_2 um
  EXT M5i DUM5 < DM5_S_2 ABUT < 90 SINGULAR REGION
  M5i AND DUM5
}


DM5.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM5_S_3_W um and the parallel metal run length > ^DM5_S_3_L um] >=  ^DM5_S_3
  X = EXT M5Wide_4.5 DUM5 < DM5_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM5_S_2 DM5_S_3_L+0.005
}


DM5.S.4 { @ Space to FW (Overlap is not allowed) >= 5.0 
  EXT FWi DUM5 < DM5_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM5
}

// for solid L-mark (old)
DM5.S.5 { @ Space to LMARK (Overlap is not allowed) >= ^DM5_S_5 um
  EXT LMARK_SOLID DUM5 < DM5_S_5 ABUT < 90 SINGULAR REGION 
  DUM5 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM5.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= ^DM5_S_5_1 um
  EXT LSLOT DUM5 < DM5_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM5 AND LSLOT  
}

DM5.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DUM5
}
DM5.S.8 { @ Space to INDDMY (Overlap is not allowed) >= 2.5 
  EXT INDDMY DUM5 < DM5_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM5
}

#IFDEF FULL_CHIP
DM5.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM5 NOT (SIZE CHIP_CHAMFERED BY -DM5_EN_1)
}
#ENDIF
DM5.A.1 { @ Min. area >= ^DM5_A_1 um2
  AREA DUM5 < DM5_A_1 
}
DM5.A.2 { @ Max. area <= ^DM5_A_2 um2
  AREA DUM5 > DM5_A_2 
}
#IFDEF FULL_CHIP
DM5.R.1 { @ DM5 is a must. The DM5 CAD layer (TSMC default, 35;41 for DM5) must be different from the M5 CAD layer.
  CHIPx NOT INTERACT DUM5
}
#ENDIF

// DM5.R.2 is checked by CSR.R.1

DM5.R.3 { @ 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)
  NOT RECTANGLE DUM5
  HOLES DUM5
}


//DUMMY M6 CHECKS
//==================

DM6.W.1 { @ Width >= ^DM6_W_1 um
  INT DUM6 < DM6_W_1 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= 3.0 
  SIZE DUM6 BY DM6_W_2 /2 UNDEROVER
}
DM6.S.1 { @ Space >= ^DM6_S_1 um
  EXT DUM6 < DM6_S_1 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to M6 >= ^DM6_S_2 um
  EXT M6i DUM6 < DM6_S_2 ABUT < 90 SINGULAR REGION
  M6i AND DUM6
}

M6Wide_1.5 = (SIZE M6i BY  DM6_S_3_1_W/2 UNDEROVER TRUNCATE DM6_S_3_1_W/2) AND M6i
M6Wide_4.5 = (SIZE M6Wide_1.5 BY DM6_S_3_W/2 UNDEROVER TRUNCATE DM6_S_3_W/2) AND M6Wide_1.5

DM6.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > ^DM6_S_3_W um and the parallel metal run length > ^DM6_S_3_L um] >=  ^DM6_S_3
  X = EXT M6Wide_4.5 DUM6 < DM6_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM6_S_2 DM6_S_3_L+0.005
}


DM6.S.4 { @ Space to FW (Overlap is not allowed) >= 5.0 
  EXT FWi DUM6 < DM6_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM6
}

// for solid L-mark (old)
DM6.S.5 { @ Space to LMARK (Overlap is not allowed) >= ^DM6_S_5 um
  EXT LMARK_SOLID DUM6 < DM6_S_5 ABUT < 90 SINGULAR REGION 
  DUM6 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM6.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= ^DM6_S_5_1 um
  EXT LSLOT DUM6 < DM6_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM6 AND LSLOT  
}

DM6.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0.0 
  LOGO AND DUM6
}
DM6.S.8 { @ Space to INDDMY (Overlap is not allowed) >= 2.5 
  EXT INDDMY DUM6 < DM6_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM6
}

#IFDEF FULL_CHIP
DM6.EN.1 { @ Enclosure by chip edge >= 2.5 
  DUM6 NOT (SIZE CHIP_CHAMFERED BY -DM6_EN_1)
}
#ENDIF
DM6.A.1 { @ Min. area >= ^DM6_A_1 um2
  AREA DUM6 < DM6_A_1 
}
DM6.A.2 { @ Max. area <= ^DM6_A_2 um2
  AREA DUM6 > DM6_A_2 
}
#IFDEF FULL_CHIP
DM6.R.1 { @ DM6 is a must. The DM6 CAD layer (TSMC default, 36;61 for DM6) must be different from the M6 CAD layer.
  CHIPx NOT INTERACT DUM6
}
#ENDIF

// DM6.R.2 is checked by CSR.R.1

DM6.R.3 { @ 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)
  NOT RECTANGLE DUM6
  HOLES DUM6
}



// RV Layout Rules  
//==============================================
RV_CHECK = RV NOT INSIDE SR_EDGE

RV.W.1 {@ Width (maximum = minimum) (Not inside seal ring) = ^RV_W_1 um
  NOT RECTANGLE RV_CHECK == RV_W_1 BY == RV_W_1 ORTHOGONAL ONLY
}

RV.S.1 {@ Space >= ^RV_S_1 um
  EXT RV < RV_S_1 ABUT < 90 SINGULAR REGION
}


//RV.S.2 is checked in flip chip DRC.

RV.S.3 { @ Space to CB/CB2/FW {Overlap is not allowed} >= ^RV_S_3 um
   EXT RV_CHECK CB  < RV_S_3 ABUT < 90 SINGULAR REGION 
   RV_CHECK AND CB
   EXT RV_CHECK CB2  < RV_S_3 ABUT < 90 SINGULAR REGION 
   RV_CHECK AND CB2  
   EXT RV_CHECK FW < RV_S_3 ABUT < 90 SINGULAR REGION 
   RV_CHECK AND FW
}

RV.EN.1 {@ Enclosure by Mtop (Not inside seal ring) >= ^RV_EN_1 um
  ENC RV_CHECK M6 < RV_EN_1 ABUT < 90 SINGULAR REGION
  RV_CHECK NOT M6
}

#IFDEF WLCSP_SEALRING
RV.R.1 {@ A 45-degree rotated RV is prohibited.
  ANGLE RV_CHECK >0 <90
}
#ELSE
RV.R.1 {@ A 45-degree rotated RV is prohibited.
  ANGLE RV >0 <90
}
#ENDIF

//RV.R.2 is checked in wire-bond DRC

//RV.R.3 is checked in flip-chip DRC


// AP Layout Rules
//=================
AP_CHECK = AP NOT INSIDE SR_EDGE
CHIP_INT_AP = CHIP_EDGE INTERACT (FW_AP OR RV) 
CB_CHECK   = CB NOT INSIDE SR_EDGE 
CB2_CHECK  = CB2 NOT INSIDE SR_EDGE
CB_CHECK2  = CB_CHECK INTERACT CHIP_INT_AP
CB2_CHECK2  = CB2_CHECK INTERACT CHIP_INT_AP
    
AP.W.1 { @ Width [interconnect only] [ not inside FW_AP or sealring] >= ^AP_W_1 um
   A = AP_CHECK NOT FW_AP 
   INT A < AP_W_1 ABUT < 90 SINGULAR REGION
}

AP.W.2 { @ Maximum width [interconnect only] [ not inside UBM, CB or CB2] <= ^AP_W_2 um
   A = ((AP NOT UBM) NOT CB) NOT CB2
   WITH WIDTH A > AP_W_2
}

AP.S.1 { @ Space >= ^AP_S_1 um
   EXT AP < AP_S_1 ABUT < 90 SINGULAR REGION
}

//AP.S.1.1 is checked in wire-bond DRC

AP.S.2 { @ Space to FW_CU/FW_AP [(overlap FW_CU)/(Cut FW_AP) is prohibited] >= ^AP_S_2 um
   EXT AP FW < AP_S_2 ABUT < 90 SINGULAR REGION
   AP AND FW_Cu
   AP CUT FW_AP
}

AP.S.3 { @ Space to LMARK [overlap is prohibited, except seal-ring] >= ^AP_S_3 um
   EXT AP_CHECK LMARK < AP_S_3 ABUT < 90 SINGULAR REGION
   AP_CHECK AND LMARK
}

//AP.S.4 is checked in wire-bond/flip-chip DRC

AP.EN.1 { @ Enclosured of RV (Not inside seal ring) >= ^AP_EN_1 um
   ENC RV_CHECK AP_CHECK < AP_EN_1 ABUT < 90 SINGULAR REGION
   RV_CHECK NOT AP_CHECK 
}

AP.EN.2 { @ Enclosure of CB/CB2 >= ^AP_EN_2 um
   ENC CB_CHECK AP < AP_EN_2 ABUT < 90 SINGULAR REGION
   CB_CHECK2 NOT AP
   ENC CB2_CHECK AP < AP_EN_2 ABUT < 90 SINGULAR REGION
   CB2_CHECK2 NOT AP
}

#IFDEF FULL_CHIP

AP.DN.1.L { @ AP density across full chip >= ^AP_DN_1_L
  DENSITY AP CHIP_INT_AP < AP_DN_1_L PRINT AP.DN.1L.density
  [ AREA(AP)/AREA(CHIP_INT_AP)]    
}

AP.DN.1.H { @ AP density across full chip <= ^AP_DN_1_H
  DENSITY AP CHIP_INT_AP > AP_DN_1_H PRINT AP.DN.1H.density    
  [ AREA(AP)/AREA(CHIP_INT_AP)]
}

#ENDIF


// Layer operation for metal fuse and protection ring
//====================================================

F_M0    = FW_AP AND POLY
F_V0    = FW_AP AND CO
F_M1    = FW_AP AND M1
F_V1	= FW_AP AND VIA1
F_M2    = FW_AP AND M2
F_V2	= FW_AP AND VIA2
F_M3    = FW_AP AND M3
F_V3	= FW_AP AND VIA3
F_M4    = FW_AP AND M4
F_V4	= FW_AP AND VIA4
F_M5    = FW_AP AND M5
F_V5	= FW_AP AND VIA5
F_M6    = FW_AP AND M6
MTFS    = FW_AP AND AP    

R_M0    = RNGX AND POLY
R_V0    = RNGX AND CO
R_M1    = RNGX AND M1
R_V1    = RNGX AND VIA1
R_M2    = RNGX AND M2
R_V2    = RNGX AND VIA2
R_M3    = RNGX AND M3
R_V3    = RNGX AND VIA3
R_M4    = RNGX AND M4
R_V4    = RNGX AND VIA4
R_M5    = RNGX AND M5
R_V5    = RNGX AND VIA5
R_M6    = RNGX AND M6
H_RM1   = HOLES R_M1
H_RV1   = HOLES R_V1
H_RM2   = HOLES R_M2
H_RV2   = HOLES R_V2
H_RM3   = HOLES R_M3
H_RV3   = HOLES R_V3
H_RM4   = HOLES R_M4
H_RV4   = HOLES R_V4
H_RM5   = HOLES R_M5
H_RV5   = HOLES R_V5
H_RM6  = HOLES R_M6

MTFS_W = CONVEX EDGE MTFS ANGLE1==270 ANGLE2==270
MTFS_B = CONVEX EDGE MTFS ANGLE1==270 ANGLE2==90
MTFS_D = CONVEX EDGE MTFS ANGLE1==90  ANGLE2==90

MTFS_E  = INT MTFS_D MTFS_B < 15 ABUT<90 OPPOSITE REGION
MTFS_EA = MTFS_E AND MTFS 
MTFS_R  = MTFS NOT MTFS_EA
MTFS_CR = INT MTFS_W < 3 ABUT<90 OPPOSITE REGION // metal fuse between dog bone

// connection for metal/via under metal fuse
CONNECT F_V0 MTFS
CONNECT F_V1 MTFS
CONNECT F_V2 MTFS
CONNECT F_V3 MTFS
CONNECT F_V4 MTFS
CONNECT F_V5 MTFS
CONNECT F_M0 MTFS
CONNECT F_M1 MTFS
CONNECT F_M2 MTFS
CONNECT F_M3 MTFS
CONNECT F_M4 MTFS
CONNECT F_M5 MTFS
CONNECT F_M6 MTFS


// Warining checks 
//=================

FUSE_WARN.1 { @ AP fuse must be covered by PMDMY.
  FW_AP OUTSIDE PMDMY
}  

FUSE_WARN.2 { @ PWELL/PMDMY/FW should be used in fuse structure.
  MTFS AND NWi
  MTFS OUTSIDE PMDMY
  PMDMY OUTSIDE MTFS
  PMDMY OUTSIDE FW_AP 
} 

FUSE_WARN.3 { @ Metal fuse should be a dog bone shape.
  VERTEX MTFS != 12
}

// AP fuse Rules checks
//===================

FU.W.1 { @ Width of AP fuse == ^FU_W_1 um
   INT MTFS < FU_W_1 ABUT < 90 SINGULAR REGION  
   WITH WIDTH MTFS_R > FU_W_1
}

FU.W.2 { @ Width of FW  >= ^FU_W_2 um
   INT FW_AP < FU_W_2 ABUT < 90 REGION
}

FU.L.1 { @ Length of AP fuse >=  ^FU_L_1 um 
   NOT ENCLOSE RECTANGLE MTFS GRID FU_L_1 ORTHOGONAL ONLY
}

FU.L.1.1 { @ Length of AP fuse between dog bone >= ^FU_L_1_1 um
   NOT ENCLOSE RECTANGLE MTFS_CR GRID FU_L_1_1 ORTHOGONAL ONLY
}

FU.S.1 { @ Spece of AP fuse >= ^FU_S_1 um
   EXT MTFS_CR < FU_S_1 ABUT < 90 SINGULAR REGION
}

FU.S.1.1 { @ Spece of AP fuse between between dog bone >= ^FU_S_1_1 um
   EXT MTFS < FU_S_1_1 ABUT < 90 SINGULAR REGION
}

FU.S.2_CO { @ Space between COs under the same AP fuse >= ^FU_S_2 um  
   A = MTFS NOT MTFS_CR
   B = EXT F_V0 < FU_S_2 CONNECTED REGION
   B INTERACT A  > 1
} 

FU.S.2_V1 { @ Space between Vias under the same AP fuse >= ^FU_S_2 um  
   A= MTFS NOT MTFS_CR
   B= EXT F_V1 < FU_S_2 CONNECTED REGION
   B INTERACT A > 1
}  
FU.S.2_V2 { @ Space between Vias under the same AP fuse >= ^FU_S_2 um  
   A= MTFS NOT MTFS_CR
   B= EXT F_V2 < FU_S_2 CONNECTED REGION
   B INTERACT A > 1
}  
FU.S.2_V3 { @ Space between Vias under the same AP fuse >= ^FU_S_2 um  
   A= MTFS NOT MTFS_CR
   B= EXT F_V3 < FU_S_2 CONNECTED REGION
   B INTERACT A > 1
}  
FU.S.2_V4 { @ Space between Vias under the same AP fuse >= ^FU_S_2 um  
   A= MTFS NOT MTFS_CR
   B= EXT F_V4 < FU_S_2 CONNECTED REGION
   B INTERACT A > 1
}  
FU.S.2_V5 { @ Space between Vias under the same AP fuse >= ^FU_S_2 um  
   A= MTFS NOT MTFS_CR
   B= EXT F_V5 < FU_S_2 CONNECTED REGION
   B INTERACT A > 1
}  

FU.S.3_PO { @ Space between POs under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M0 < FU_S_3 CONNECTED REGION
}

FU.S.3_M1 { @ Space between M1 metal islands under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M1 < FU_S_3 CONNECTED REGION
}
FU.S.3_M2 { @ Space between M2 metal islands under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M2 < FU_S_3 CONNECTED REGION
}
FU.S.3_M3 { @ Space between M3 metal islands under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M3 < FU_S_3 CONNECTED REGION
}
FU.S.3_M4 { @ Space between M4 metal islands under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M4 < FU_S_3 CONNECTED REGION
}
FU.S.3_M5 { @ Space between M5 metal islands under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M5 < FU_S_3 CONNECTED REGION
}
FU.S.3_M6 { @ Space between M6 metal islands under the same AP fuse >= ^FU_S_3 um.  
   EXT F_M6 < FU_S_3 CONNECTED REGION
}

#IFDEF FULL_CHIP
FU.S.4 { @ Space of FW to chip edge >= ^FU_S_4 um
  ENC FW_AP CHIP_EDGE < FU_S_4 ABUT < 90 REGION
}
#ENDIF


FU.EN.1 { @ FW enclosure of AP fuse [at perpendicular direction of fuse line-end] >= ^FU_EN_1 um 
   ENC MTFS_W FW_AP < FU_EN_1 ABUT < 90 REGION
}

FU.EN.1.1 { @ FW enclosure of Al fuse [at parallel direction of fuse line-end] >= ^FU_EN_1_1 um
   ENC MTFS FW < FU_EN_1_1 ABUT < 90 REGION
}

FU.EN.2 { @ PW enclosure of metal fuse >= ^FU_EN_2 um
   EXT MTFS NWEL < FU_EN_2 ABUT < 90 INSIDE ALSO
   MTFS AND NWEL    
}

FU.EN.3.M1 { @ AP fuse enclosure of metal island >= ^FU_EN_3 um
   ENC F_M1 MTFS < FU_EN_3 ABUT < 90 REGION
   F_M1 NOT MTFS    
}
FU.EN.3.M2 { @ AP fuse enclosure of metal island >= ^FU_EN_3 um
   ENC F_M2 MTFS < FU_EN_3 ABUT < 90 REGION
   F_M2 NOT MTFS    
}
FU.EN.3.M3 { @ AP fuse enclosure of metal island >= ^FU_EN_3 um
   ENC F_M3 MTFS < FU_EN_3 ABUT < 90 REGION
   F_M3 NOT MTFS    
}
FU.EN.3.M4 { @ AP fuse enclosure of metal island >= ^FU_EN_3 um
   ENC F_M4 MTFS < FU_EN_3 ABUT < 90 REGION
   F_M4 NOT MTFS    
}
FU.EN.3.M5 { @ AP fuse enclosure of metal island >= ^FU_EN_3 um
   ENC F_M5 MTFS < FU_EN_3 ABUT < 90 REGION
   F_M5 NOT MTFS    
}
FU.EN.3.M6 { @ AP fuse enclosure of metal island >= ^FU_EN_3 um
   ENC F_M6 MTFS < FU_EN_3 ABUT < 90 REGION
   F_M6 NOT MTFS    
}

FU.A.1 { @ Metal island  for fuse stack >= ^FU_A_1_L x ^FU_A_1_W
  NOT ENCLOSE RECTANGLE F_M1 FU_A_1_L FU_A_1_W ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE F_M2 FU_A_1_L FU_A_1_W ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE F_M3 FU_A_1_L FU_A_1_W ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE F_M4 FU_A_1_L FU_A_1_W ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE F_M5 FU_A_1_L FU_A_1_W ORTHOGONAL ONLY
  NOT ENCLOSE RECTANGLE F_M6 FU_A_1_L FU_A_1_W ORTHOGONAL ONLY
}

FU.R.1 { @ at least two COs are required to connect POLY/M1 for fuse circuit
         @ at least two VIAs are required to connect M1/../MTop for fuse circuit
  (F_M0 AND F_M1) ENCLOSE F_V0 < 2
  (F_M0 AND F_M1) NOT ENCLOSE F_V0 
  (F_M1 AND F_M2) ENCLOSE F_V1 < 2
  (F_M1 AND F_M2) NOT ENCLOSE F_V1 
  (F_M2 AND F_M3) ENCLOSE F_V2 < 2
  (F_M2 AND F_M3) NOT ENCLOSE F_V2 
  (F_M3 AND F_M4) ENCLOSE F_V3 < 2
  (F_M3 AND F_M4) NOT ENCLOSE F_V3 
  (F_M4 AND F_M5) ENCLOSE F_V4 < 2
  (F_M4 AND F_M5) NOT ENCLOSE F_V4 
  (F_M5 AND F_M6) ENCLOSE F_V5 < 2
  (F_M5 AND F_M6) NOT ENCLOSE F_V5 
}

FU.R.2 { @ Only fuse-related layout is allowed in the FW region. Dummy pattern and device are not allowed.
   FW_AP AND DNWi 
   FW_AP AND NWi 
   FW_AP AND ODi 
   FW_AP AND OD_18i 
   FW_AP AND OD_25i
   FW_AP AND OD_33i
   FW_AP AND CBi
   FW_AP AND CBDi
   FW_AP AND RVi
   FW_AP AND UBMi
   FW_AP AND RPOi 
   FW_AP AND NT_Ni
   FW_AP AND CBMi
   FW_AP AND CTMi
   DUM1 AND FW_AP 
   DUM2 AND FW_AP 
   DUM3 AND FW_AP 
   DUM4 AND FW_AP 
   DUM5 AND FW_AP 
   DUM6 AND FW_AP 
   DOD AND FW_AP 
   DPO AND FW_AP 	   
}

FU.R.3 { @ 45 degree fuse metal is not allowed (fuse metal must be orthogonal).
   ANGLE MTFS >0 <90
}
//FU.R.4 can not be checked by DRC.

//FU.R.5 is not necessary to check.


// Protection Ring Rules of AP fuse Checks
//=====================================

PR.W.1_V1 { @ width of via-ring on the protection ring = ^PR_W_1_Vx um
  INT R_V1 < PR_W_1_Vx ABUT < 90 OPPOSITE REGION
  SIZE R_V1 BY PR_W_1_Vx/2 UNDEROVER
} 

PR.EN.1_V1 { @ Metal enclosure of via-ring on the protection ring >= ^PR_EN_1_Vx um
  ENC R_V1 R_M1 < PR_EN_1_Vx ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V1 NOT R_M1  
  ENC R_V1 R_M2 < PR_EN_1_Vx ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V1 NOT R_M2
}

PR.W.1_V2 { @ width of via-ring on the protection ring = ^PR_W_1_Vx um
  INT R_V2 < PR_W_1_Vx ABUT < 90 OPPOSITE REGION
  SIZE R_V2 BY PR_W_1_Vx/2 UNDEROVER
} 

PR.EN.1_V2 { @ Metal enclosure of via-ring on the protection ring >= ^PR_EN_1_Vx um
  ENC R_V2 R_M2 < PR_EN_1_Vx ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V2 NOT R_M2  
  ENC R_V2 R_M3 < PR_EN_1_Vx ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V2 NOT R_M3
}

PR.W.1_V3 { @ width of via-ring on the protection ring = ^PR_W_1_Vx um
  INT R_V3 < PR_W_1_Vx ABUT < 90 OPPOSITE REGION
  SIZE R_V3 BY PR_W_1_Vx/2 UNDEROVER
} 

PR.EN.1_V3 { @ Metal enclosure of via-ring on the protection ring >= ^PR_EN_1_Vx um
  ENC R_V3 R_M3 < PR_EN_1_Vx ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V3 NOT R_M3  
  ENC R_V3 R_M4 < PR_EN_1_Vx ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V3 NOT R_M4
}

PR.W.1_V4 { @ Width of via ring on the protection ring = ^PR_W_1_Vz um
  INT R_V4 < PR_W_1_Vz SINGULAR ABUT < 90 REGION
  SIZE R_V4 BY PR_W_1_Vz/2 UNDEROVER 
}

PR.EN.1_V4 { @ Metal enclosure of via-ring on the protection ring >= ^PR_EN_1_Vz um
  ENC R_V4 R_M4 < PR_EN_1_Vz ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V4 NOT R_M4   
  ENC R_V4 R_M5 < PR_EN_1_Vz ABUT < 90 SINGULAR OUTSIDE ALSO REGION   
  R_V4 NOT R_M5
}

PR.W.1_V5 { @ Width of via ring on the protection ring = ^PR_W_1_Vz um
  INT R_V5 < PR_W_1_Vz SINGULAR ABUT < 90 REGION
  SIZE R_V5 BY PR_W_1_Vz/2 UNDEROVER 
}

PR.EN.1_V5 { @ Metal enclosure of via-ring on the protection ring >= ^PR_EN_1_Vz um
  ENC R_V5 R_M5 < PR_EN_1_Vz ABUT < 90 SINGULAR OUTSIDE ALSO REGION
  R_V5 NOT R_M5   
  ENC R_V5 R_M6 < PR_EN_1_Vz ABUT < 90 SINGULAR OUTSIDE ALSO REGION   
  R_V5 NOT R_M6
}


PR.S.1_M1 { @ Space to FW >= ^PR_S_1 um
  EXT FW R_M1 < PR_S_1 ABUT < 90 SINGULAR REGION
  AND FW R_M1 
}
PR.S.1_M2 { @ Space to FW >= ^PR_S_1 um
  EXT FW R_M2 < PR_S_1 ABUT < 90 SINGULAR REGION
  AND FW R_M2 
}
PR.S.1_M3 { @ Space to FW >= ^PR_S_1 um
  EXT FW R_M3 < PR_S_1 ABUT < 90 SINGULAR REGION
  AND FW R_M3 
}
PR.S.1_M4 { @ Space to FW >= ^PR_S_1 um
  EXT FW R_M4 < PR_S_1 ABUT < 90 SINGULAR REGION
  AND FW R_M4 
}
PR.S.1_M5 { @ Space to FW >= ^PR_S_1 um
  EXT FW R_M5 < PR_S_1 ABUT < 90 SINGULAR REGION
  AND FW R_M5 
}
PR.S.1_M6 { @ Space to FW >= ^PR_S_1 um
  EXT FW R_M6 < PR_S_1 ABUT < 90 SINGULAR REGION
  AND FW R_M6 
}

PR.S.2_M1 { @ Space to AP fuse and metal island below >= ^PR_S_2 um
  EXT F_M1 R_M1 < PR_S_2 ABUT < 90 SINGULAR REGION
  EXT MTFS R_M1 < PR_S_2 ABUT < 90 SINGULAR REGION
}
PR.S.2_M2 { @ Space to AP fuse and metal island below >= ^PR_S_2 um
  EXT F_M2 R_M2 < PR_S_2 ABUT < 90 SINGULAR REGION
  EXT MTFS R_M2 < PR_S_2 ABUT < 90 SINGULAR REGION
}
PR.S.2_M3 { @ Space to AP fuse and metal island below >= ^PR_S_2 um
  EXT F_M3 R_M3 < PR_S_2 ABUT < 90 SINGULAR REGION
  EXT MTFS R_M3 < PR_S_2 ABUT < 90 SINGULAR REGION
}
PR.S.2_M4 { @ Space to AP fuse and metal island below >= ^PR_S_2 um
  EXT F_M4 R_M4 < PR_S_2 ABUT < 90 SINGULAR REGION
  EXT MTFS R_M4 < PR_S_2 ABUT < 90 SINGULAR REGION
}
PR.S.2_M5 { @ Space to AP fuse and metal island below >= ^PR_S_2 um
  EXT F_M5 R_M5 < PR_S_2 ABUT < 90 SINGULAR REGION
  EXT MTFS R_M5 < PR_S_2 ABUT < 90 SINGULAR REGION
}
PR.S.2_M6 { @ Space to AP fuse and metal island below >= ^PR_S_2 um
  EXT F_M6 R_M6 < PR_S_2 ABUT < 90 SINGULAR REGION
  EXT MTFS R_M6 < PR_S_2 ABUT < 90 SINGULAR REGION
}

PR.S.3 { @ Space between contact bar to poly line under AP > ^PR_S_3 um
  EXT R_V0 R_M0 <= PR_S_3 ABUT < 90 SINGULAR REGION
  AND R_V0 R_M0
}

PR.EX.2 { @ Extension of polyimide window beyond fuse window >= ^PR_EX_2 um
  ENC FW_AP PM < PR_EX_2 ABUT < 90 SINGULAR REGION
  FW_AP CUT PM    
}

PR.R.1 { @ AP fuse should be surrounded by protection ring.
  MTFS NOT INSIDE H_RM1
  MTFS NOT INSIDE H_RM2
  MTFS NOT INSIDE H_RM3
  MTFS NOT INSIDE H_RM4
  MTFS NOT INSIDE H_RM5
  MTFS NOT INSIDE H_RM6
  MTFS NOT INSIDE H_RV1
  MTFS NOT INSIDE H_RV2
  MTFS NOT INSIDE H_RV3
  MTFS NOT INSIDE H_RV4
  MTFS NOT INSIDE H_RV5
}

PR.R.2 { @ PMDMY overlap of CB/CBD is not allowed.
  CBi AND PMDMY
  CBDi AND PMDMY
}

// Alignment Mark (L-mark) Rules checks
//=====================================
LMARK_NOT_CSR = LMARK OUTSIDE CSRDMY

MTLM = M6i AND LMARK_NOT_CSR
MTLMH = HOLES MTLM EMPTY // L-mark region
MTLMH_L = CONVEX EDGE MTLMH ANGLE1==90 ANGLE2==90 WITH LENGTH <= LW_W_1_MAX
MTLMH_P = CONVEX EDGE MTLMH ANGLE1==90 ANGLE2==90 WITH LENGTH >= LW_L_1_MIN

LW.W.1 { @ Minimum width of L-slot  >= ^LW_W_1_MIN um
@ Maximum width of L-slot   <= LW_W_1_MAX um
   INT MTLMH < LW_W_1_MIN ABUT < 90 OPPOSITE REGION
   SIZE MTLMH BY LW_W_1_MAX/2 UNDEROVER
}

LW.L.1 { @ Minimum length of L-slot  >= ^LW_L_1_MIN um
@ Maximum length of L-slot  <= LW_L_1_MAX um
   NOT ENCLOSE RECTANGLE MTLMH LW_W_1_MIN LW_L_1_MIN
   ENCLOSE RECTANGLE MTLMH LW_W_1_MIN LW_W_1_MAX + GRID
   MTLMH NOT WITH EDGE MTLMH_P == 2 
}  

LW.EN.1 { @ LMARK enclosure of L-slot [in the direction of the L-slot length] >= ^LW_EN_1 um
   ENC MTLMH_L LMARK < LW_EN_1 ABUT < 90 REGION
}

LW.EN.2 { @ LMARK enclosure of L-slot [perpendicular to the direction of the L-slot length] >= ^LW_EN_2 um
   ENC MTLMH_P LMARK < LW_EN_2 ABUT < 90 REGION
}

LW.S.1 { @ L-slot space to non-L-mark OD/PO/Metal (including dummy patterns) >= ^LW_S_1 um
   EXT MTLMH ALL_OD < LW_S_1 ABUT < 90 SINGULAR REGION
   AND MTLMH ALL_OD
   EXT MTLMH ALL_POLY < LW_S_1 ABUT < 90 SINGULAR REGION
   AND MTLMH ALL_POLY
   EXT MTLMH M1i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH M1i
   EXT MTLMH VIA1i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH VIA1i
   EXT MTLMH M2i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH M2i
   EXT MTLMH VIA2i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH VIA2i
   EXT MTLMH M3i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH M3i
   EXT MTLMH VIA3i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH VIA3i
   EXT MTLMH M4i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH M4i
   EXT MTLMH VIA4i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH VIA4i
   EXT MTLMH M5i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH M5i
   EXT MTLMH VIA5i < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH VIA5i
   EXT MTLMH DUM1 < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH DUM1
   EXT MTLMH DUM2 < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH DUM2
   EXT MTLMH DUM3 < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH DUM3
   EXT MTLMH DUM4 < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH DUM4
   EXT MTLMH DUM5 < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH DUM5
   EXT MTLMH DUM6 < LW_S_1 ABUT <90 SINGULAR REGION
   AND MTLMH DUM6
}

#IFDEF FULL_CHIP
LW.S.2 { @ LMARK space to chip edge >= ^LW_S_2 um
   ENC LMARK_NOT_CSR CHIP_EDGE < LW_S_2 ABUT < 90 SINGULAR REGION
}
#ENDIF

LW.R.1 { @ Only one Cu metal layer (Mtop) can be treated as L-mark metal. AP is not allowed.
   APi AND LMARK_NOT_CSR
}

LW.R.2 { @ 45-degree L-slot and L-mark metal is not allowed. L-slot and L-mark metal must be orthogonal.
   ANGLE MTLMH >0 <90
   ANGLE MTLM  >0 <90   
}

LW.R.3 { @ LMARK overlap of CB/CBD is not allowed.
   CBi AND LMARK_NOT_CSR 
   CBDi AND LMARK_NOT_CSR
}

LW.R.4 {@ At lease four L-mark metal
   X = CHIP_WISR INTERACT FW_AP
   X NOT INTERACT LMARK_METAL 
   X INTERACT LMARK_METAL < 4
}


#ENDIF


//LOGO CHECKS
//============

LOGO.S.1 { @ Space to OD, PO, or Metals (non-dummy patterns, and non-dummy TCD) >= 10 
  LOGO_EXT = (SIZE LOGO BY LOGO_S_1) NOT LOGO
  LOGO_EXT AND (ODi NOT TCDDMY)
  LOGO_EXT AND (POi NOT TCDDMY)
  M1i_R = M1i NOT DM1_O
  LOGO_EXT AND M1i_R
  M2i_R = M2i NOT DM2_O
  LOGO_EXT AND M2i_R
  M3i_R = M3i NOT DM3_O
  LOGO_EXT AND M3i_R
  M4i_R = M4i NOT DM4_O
  LOGO_EXT AND M4i_R
  LOGO_EXT AND M5i
  LOGO_EXT AND M6i
}
LOGO.O.1 { @ Overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed.   
  LOGO AND CBi
  LOGO AND CBDi
  LOGO AND FWi
  LOGO AND PMi
  LOGO AND UBMi
  LOGO AND DM1_O
  LOGO AND DM2_O
  LOGO AND DM3_O
  LOGO AND DM4_O
}

// LOGO.R.1 can not be checked.
// LOGO.R.2 is checked by related rules.


#IFDEF FRONT_END


#IFDEF DISCONNECT_AFTER_RESISTOR
NSTPiu = NSTPi NOT EMPTYi
PSTPiu = PSTPi NOT EMPTYi
NSDiu  = NSDc  NOT EMPTYi
PSDiu  = PSDc  NOT EMPTYi
CBiu   = CBi   NOT EMPTYi 
CB2iu  = CB2i  NOT EMPTYi
UBMniu = UBMn  NOT EMPTYi
UBMdiu = UBMd  NOT EMPTYi
PWR_M1iu_BY_TEXT = M1i WITH TEXT VDD_TEXT 131 PRIMARY ONLY
GND_M1iu_BY_TEXT = M1i WITH TEXT VSS_TEXT 131 PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1i WITH TEXT PAD_TEXT 131 PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2i WITH TEXT VDD_TEXT 132 PRIMARY ONLY
GND_M2iu_BY_TEXT = M2i WITH TEXT VSS_TEXT 132 PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2i WITH TEXT PAD_TEXT 132 PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3i WITH TEXT VDD_TEXT 133 PRIMARY ONLY
GND_M3iu_BY_TEXT = M3i WITH TEXT VSS_TEXT 133 PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3i WITH TEXT PAD_TEXT 133 PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4i WITH TEXT VDD_TEXT 134 PRIMARY ONLY
GND_M4iu_BY_TEXT = M4i WITH TEXT VSS_TEXT 134 PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4i WITH TEXT PAD_TEXT 134 PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5i WITH TEXT VDD_TEXT 135 PRIMARY ONLY
GND_M5iu_BY_TEXT = M5i WITH TEXT VSS_TEXT 135 PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5i WITH TEXT PAD_TEXT 135 PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6i WITH TEXT VDD_TEXT 136 PRIMARY ONLY
GND_M6iu_BY_TEXT = M6i WITH TEXT VSS_TEXT 136 PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6i WITH TEXT PAD_TEXT 136 PRIMARY ONLY
PWR_APiu_BY_TEXT = APi WITH TEXT VDD_TEXT 126 PRIMARY ONLY
GND_APiu_BY_TEXT = APi WITH TEXT VSS_TEXT 126 PRIMARY ONLY
PAD_APiu_BY_TEXT = APi WITH TEXT PAD_TEXT 126 PRIMARY ONLY
#ELSE
NSTPiu = NSTPu NOT EMPTYi
PSTPiu = PSTPu NOT EMPTYi
NSDiu  = NSDu  NOT EMPTYi
PSDiu  = PSDu  NOT EMPTYi
CBiu   = CBu   NOT EMPTYi 
CB2iu  = CB2u  NOT EMPTYi
UBMniu = UBMnu NOT EMPTYi
UBMdiu = UBMdu NOT EMPTYi
PWR_M1iu_BY_TEXT = M1u WITH TEXT VDD_TEXT 131 PRIMARY ONLY
GND_M1iu_BY_TEXT = M1u WITH TEXT VSS_TEXT 131 PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1u WITH TEXT PAD_TEXT 131 PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2u WITH TEXT VDD_TEXT 132 PRIMARY ONLY
GND_M2iu_BY_TEXT = M2u WITH TEXT VSS_TEXT 132 PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2u WITH TEXT PAD_TEXT 132 PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3u WITH TEXT VDD_TEXT 133 PRIMARY ONLY
GND_M3iu_BY_TEXT = M3u WITH TEXT VSS_TEXT 133 PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3u WITH TEXT PAD_TEXT 133 PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4u WITH TEXT VDD_TEXT 134 PRIMARY ONLY
GND_M4iu_BY_TEXT = M4u WITH TEXT VSS_TEXT 134 PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4u WITH TEXT PAD_TEXT 134 PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5u WITH TEXT VDD_TEXT 135 PRIMARY ONLY
GND_M5iu_BY_TEXT = M5u WITH TEXT VSS_TEXT 135 PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5u WITH TEXT PAD_TEXT 135 PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6u WITH TEXT VDD_TEXT 136 PRIMARY ONLY
GND_M6iu_BY_TEXT = M6u WITH TEXT VSS_TEXT 136 PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6u WITH TEXT PAD_TEXT 136 PRIMARY ONLY
PWR_APiu_BY_TEXT = APu WITH TEXT VDD_TEXT 126 PRIMARY ONLY
GND_APiu_BY_TEXT = APu WITH TEXT VSS_TEXT 126 PRIMARY ONLY
PAD_APiu_BY_TEXT = APu WITH TEXT PAD_TEXT 126 PRIMARY ONLY
#ENDIF





// Power PAD
NSTPux = NSTPiu NOT INTERACT RNWEL
CONNECT NSTPux NSTPiu
VDD_CB   = NET AREA RATIO CBiu   NSTPux > 0
VSS_CB   = NET AREA RATIO CBiu   PSTPiu > 0
VDD_CB2  = NET AREA RATIO CB2iu  NSTPux > 0
VSS_CB2  = NET AREA RATIO CB2iu  PSTPiu > 0
VDD_UBMn = NET AREA RATIO UBMniu NSTPux > 0
VDD_UBMd = NET AREA RATIO UBMdiu NSTPux > 0
VDD_UBM  = VDD_UBMn OR VDD_UBMd
VSS_UBMn = NET AREA RATIO UBMniu PSTPiu > 0
VSS_UBMd = NET AREA RATIO UBMdiu PSTPiu > 0
VSS_UBM  = VSS_UBMn OR VSS_UBMd
VDD_CB_BY_DUMMY   = CBiu   INTERACT VDDDMY
VSS_CB_BY_DUMMY   = CBiu   INTERACT VSSDMY
VDD_CB2_BY_DUMMY  = CB2iu  INTERACT VDDDMY
VSS_CB2_BY_DUMMY  = CB2iu  INTERACT VSSDMY
VDD_UBMn_BY_DUMMY = UBMniu INTERACT VDDDMY
VDD_UBMd_BY_DUMMY = UBMdiu INTERACT VDDDMY
VSS_UBMn_BY_DUMMY = UBMniu INTERACT VSSDMY
VSS_UBMd_BY_DUMMY = UBMdiu INTERACT VSSDMY
// Signal PAD
IO_CB   = (((CBiu   NOT VDD_CB)  NOT VSS_CB)  NOT VDD_CB_BY_DUMMY)   NOT VSS_CB_BY_DUMMY
IO_CB2  = (((CB2iu  NOT VDD_CB2) NOT VSS_CB2) NOT VDD_CB2_BY_DUMMY)  NOT VSS_CB2_BY_DUMMY
IO_UBMn = (((UBMniu NOT VDD_UBM) NOT VSS_UBM) NOT VDD_UBMn_BY_DUMMY) NOT VSS_UBMn_BY_DUMMY
IO_UBMd = (((UBMdiu NOT VDD_UBM) NOT VSS_UBM) NOT VDD_UBMd_BY_DUMMY) NOT VSS_UBMd_BY_DUMMY




PSD_PAD = NET AREA RATIO PSDiu CBiu CB2iu UBMniu UBMdiu > 0 [!!AREA(CBiu)+!!AREA(CB2iu)+!!AREA(UBMniu)+!!AREA(UBMdiu)]
NSD_PAD = NET AREA RATIO NSDiu CBiu CB2iu UBMniu UBMdiu > 0 [!!AREA(CBiu)+!!AREA(CB2iu)+!!AREA(UBMniu)+!!AREA(UBMdiu)]
PSD_IOPAD_stp = NET AREA RATIO PSDiu IO_CB IO_CB2 IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB)+!!AREA(IO_CB2)+!!AREA(IO_UBMn)+!!AREA(IO_UBMd)]
NSD_IOPAD_stp = NET AREA RATIO NSDiu IO_CB IO_CB2 IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB)+!!AREA(IO_CB2)+!!AREA(IO_UBMn)+!!AREA(IO_UBMd)]
MOS = DACT INTERACT GATE

#IFDEF DEFINE_PAD_BY_TEXT
PSD_PAD_TEXT = NET AREA RATIO PSDiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
NSD_PAD_TEXT = NET AREA RATIO NSDiu OVER PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT > 0
PSD_VDD_VSS_PAD_TEXT = NET AREA RATIO PSDiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0 
NSD_VDD_VSS_PAD_TEXT = NET AREA RATIO NSDiu OVER PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT > 0 
PSD_IOPAD = PSDiu INTERACT ((PSD_IOPAD_stp OR PSD_PAD_TEXT) NOT PSD_VDD_VSS_PAD_TEXT)
NSD_IOPAD = NSDiu INTERACT ((NSD_IOPAD_stp OR NSD_PAD_TEXT) NOT NSD_VDD_VSS_PAD_TEXT)
PMOS_filter = COPY EMPTYi
NMOS_filter = COPY EMPTYi
#ELSE
PSD_IOPAD = PSDiu INTERACT PSD_IOPAD_stp
NSD_IOPAD = NSDiu INTERACT NSD_IOPAD_stp
MOS_filter_DMY = CHIP INTERACT (VDDDMY OR VSSDMY)
PMOS_filter = (MOS INTERACT PSD_PAD == 1 BY NET) NOT MOS_filter_DMY
NMOS_filter = (MOS INTERACT NSD_PAD == 1 BY NET) NOT MOS_filter_DMY
#ENDIF
SD_IOPAD = PSD_IOPAD OR NSD_IOPAD


DUMMY_MOS   = (MOS NOT INTERACT CO) NOT INTERACT (POLY INTERACT CO)
DUMMY_DIODE = (DACT NOT INTERACT POLY) NOT INTERACT CO
G_DIODE     = MOS INTERACT ((GATE INTERACT PP) INTERACT NP)
DACT_real   = ((((DACT NOT INTERACT ODRES) NOT INTERACT RNWEL) NOT DUMMY_MOS) NOT G_DIODE) NOT DUMMY_DIODE
PACT_real = PACT AND DACT_real
NACT_real = NACT AND DACT_real

// ESD device [covered by dummy layers]
POST_DRIVER_ACT1 = DACT_real AND SDI
// ESD device [connected to Signal PAD but not connected to one PAD only]
POST_DRIVER_ACT2 = ((DACT_real NOT PMOS_filter) NOT NMOS_filter) INTERACT SD_IOPAD

#IFDEF CHECK_LATCHUP_BY_PAD_CONNECTION
POST_DRIVER_ACT = POST_DRIVER_ACT1 OR POST_DRIVER_ACT2 
#ELSE
POST_DRIVER_ACT = COPY POST_DRIVER_ACT1
#ENDIF

POST_DRIVER_PACT = (POST_DRIVER_ACT INTERACT PSDiu) NOT INSIDE LUPWDMY
POST_DRIVER_NACT = (POST_DRIVER_ACT INTERACT NSDiu) NOT INSIDE LUPWDMY

NW_inside_guard_ring_pre1 = NWi NOT NSTPi
NW_inside_guard_ring_pre2 = NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NSTPi
NW_inside_guard_ring = NW_inside_guard_ring_pre1 NOT WITH EDGE NW_inside_guard_ring_pre2

PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
PW_inside_guard_ring_pre2 = PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
PW_inside_guard_ring = PW_inside_guard_ring_pre1 NOT WITH EDGE PW_inside_guard_ring_pre2

NTAP_guard_ring_hole = ((HOLES NSTPi INNER) INSIDE NWi) OR NW_inside_guard_ring
PTAP_guard_ring_hole = ((HOLES PSTPi INNER) INSIDE PWELi) OR PW_inside_guard_ring




POST_DRIVER_PMOS = (POST_DRIVER_PACT INTERACT GATE) NOT G_DIODE 
POST_DRIVER_PMOS_NW = STAMP POST_DRIVER_PMOS BY NWEL
POST_DRIVER_PMOS_NW_HV  = POST_DRIVER_PMOS_NW INTERACT HV_GATE
POST_DRIVER_PMOS_NW_5V  = ((POST_DRIVER_PMOS_NW_HV INTERACT OD_25) INTERACT HVD_P) NOT INTERACT DNW
POST_DRIVER_PMOS_NW_33V = POST_DRIVER_PMOS_NW_HV INTERACT OD_33
POST_DRIVER_PMOS_NW_25V = (POST_DRIVER_PMOS_NW_HV INTERACT OD_25) NOT INTERACT HVD_P
POST_DRIVER_PMOS_NW_18V = POST_DRIVER_PMOS_NW_HV INTERACT OD_18
POST_DRIVER_PMOS_NW_LV  = POST_DRIVER_PMOS_NW NOT POST_DRIVER_PMOS_NW_HV

POST_DRIVER_PMOS_NWi = STAMP POST_DRIVER_PMOS BY NWi
POST_DRIVER_PMOS_NWi_HV  = POST_DRIVER_PMOS_NWi INTERACT HV_GATE
POST_DRIVER_PMOS_NWi_5V  = ((POST_DRIVER_PMOS_NWi_HV INTERACT OD_25) INTERACT HVD_P) NOT INTERACT DNW
POST_DRIVER_PMOS_NWi_33V = POST_DRIVER_PMOS_NWi_HV INTERACT OD_33
POST_DRIVER_PMOS_NWi_25V = (POST_DRIVER_PMOS_NWi_HV INTERACT OD_25) NOT INTERACT HVD_P
POST_DRIVER_PMOS_NWi_18V = POST_DRIVER_PMOS_NWi_HV INTERACT OD_18
POST_DRIVER_PMOS_NWi_LV  = POST_DRIVER_PMOS_NWi NOT POST_DRIVER_PMOS_NWi_HV
POST_DRIVER_NMOS = (POST_DRIVER_NACT INTERACT GATE) NOT G_DIODE 

POST_DRIVER_NMOS_RW = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNW
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS NOT POST_DRIVER_NMOS_RW
POST_DRIVER_NMOS_RW_HV  = POST_DRIVER_NMOS_RW INTERACT HV_GATE
POST_DRIVER_NMOS_RW_33V = POST_DRIVER_NMOS_RW_HV INTERACT OD_33
POST_DRIVER_NMOS_RW_25V = (POST_DRIVER_NMOS_RW_HV INTERACT OD_25) NOT INTERACT HVD_N
POST_DRIVER_NMOS_RW_18V = POST_DRIVER_NMOS_RW_HV INTERACT OD_18
POST_DRIVER_NMOS_RW_LV  = POST_DRIVER_NMOS_RW NOT POST_DRIVER_NMOS_RW_HV

POST_DRIVER_NMOS_PW_HV  = POST_DRIVER_NMOS_PW INTERACT HV_GATE
POST_DRIVER_NMOS_PW_5V  = ((POST_DRIVER_NMOS_PW_HV INTERACT OD_25) INTERACT HVD_N) NOT INTERACT DNW
POST_DRIVER_NMOS_PW_33V = POST_DRIVER_NMOS_PW_HV INTERACT OD_33
POST_DRIVER_NMOS_PW_25V = (POST_DRIVER_NMOS_PW_HV INTERACT OD_25) NOT INTERACT HVD_N
POST_DRIVER_NMOS_PW_18V = POST_DRIVER_NMOS_PW_HV INTERACT OD_18
POST_DRIVER_NMOS_PW_LV  = POST_DRIVER_NMOS_PW NOT POST_DRIVER_NMOS_PW_HV
DNWc = STAMP DNW BY NWi
POST_DRIVER_NMOS_RWi = STAMP (POST_DRIVER_NMOS INSIDE DNWc) BY DNWc
POST_DRIVER_NMOS_RWi_HV  = POST_DRIVER_NMOS_RWi INTERACT HV_GATE
POST_DRIVER_NMOS_RWi_33V = POST_DRIVER_NMOS_RWi_HV INTERACT OD_33
POST_DRIVER_NMOS_RWi_25V = POST_DRIVER_NMOS_RWi_HV INTERACT OD_25
POST_DRIVER_NMOS_RWi_18V = POST_DRIVER_NMOS_RWi_HV INTERACT OD_18
POST_DRIVER_NMOS_RWi_LV  = POST_DRIVER_NMOS_RWi NOT POST_DRIVER_NMOS_RWi_HV


POST_DRIVER_MOS = POST_DRIVER_NMOS OR POST_DRIVER_PMOS
BESIDE_POST_DRIVER = SIZE POST_DRIVER_MOS BY LUP_2
BESIDE_POST_DRIVER_NMOS = ((((NACT_real INTERACT GATE) INTERACT BESIDE_POST_DRIVER) NOT POST_DRIVER_NACT) NOT DUMMY_MOS) NOT G_DIODE
BESIDE_POST_DRIVER_PMOS = ((((PACT_real INTERACT GATE) INTERACT BESIDE_POST_DRIVER) NOT POST_DRIVER_PACT) NOT DUMMY_MOS) NOT G_DIODE


BESIDE_POST_DRIVER_PMOS_NW = STAMP BESIDE_POST_DRIVER_PMOS BY NWEL
BESIDE_POST_DRIVER_PMOS_NW_HV  = BESIDE_POST_DRIVER_PMOS_NW INTERACT HV_GATE
BESIDE_POST_DRIVER_PMOS_NW_5V  = ((BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD_25) INTERACT HVD_P) NOT INTERACT DNW
BESIDE_POST_DRIVER_PMOS_NW_33V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD_33
BESIDE_POST_DRIVER_PMOS_NW_25V = (BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD_25) NOT INTERACT HVD_P
BESIDE_POST_DRIVER_PMOS_NW_18V = BESIDE_POST_DRIVER_PMOS_NW_HV INTERACT OD_18
BESIDE_POST_DRIVER_PMOS_NW_LV  = BESIDE_POST_DRIVER_PMOS_NW NOT BESIDE_POST_DRIVER_PMOS_NW_HV

BESIDE_POST_DRIVER_PMOS_NWi = STAMP BESIDE_POST_DRIVER_PMOS BY NWi
BESIDE_POST_DRIVER_PMOS_NWi_HV  = BESIDE_POST_DRIVER_PMOS_NWi INTERACT HV_GATE
BESIDE_POST_DRIVER_PMOS_NWi_5V  = ((BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD_25) INTERACT HVD_P) NOT INTERACT DNW
BESIDE_POST_DRIVER_PMOS_NWi_33V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD_33
BESIDE_POST_DRIVER_PMOS_NWi_25V = (BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD_25) NOT INTERACT HVD_P 
BESIDE_POST_DRIVER_PMOS_NWi_18V = BESIDE_POST_DRIVER_PMOS_NWi_HV INTERACT OD_18
BESIDE_POST_DRIVER_PMOS_NWi_LV  = BESIDE_POST_DRIVER_PMOS_NWi NOT BESIDE_POST_DRIVER_PMOS_NWi_HV

BESIDE_POST_DRIVER_NMOS_RW = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_RW
BESIDE_POST_DRIVER_NMOS_RW_HV  = BESIDE_POST_DRIVER_NMOS_RW INTERACT HV_GATE
BESIDE_POST_DRIVER_NMOS_RW_33V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD_33
BESIDE_POST_DRIVER_NMOS_RW_25V = (BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD_25) NOT INTERACT HVD_N
BESIDE_POST_DRIVER_NMOS_RW_18V = BESIDE_POST_DRIVER_NMOS_RW_HV INTERACT OD_18
BESIDE_POST_DRIVER_NMOS_RW_LV  = BESIDE_POST_DRIVER_NMOS_RW NOT BESIDE_POST_DRIVER_NMOS_RW_HV

BESIDE_POST_DRIVER_NMOS_PW_HV  = BESIDE_POST_DRIVER_NMOS_PW INTERACT HV_GATE
BESIDE_POST_DRIVER_NMOS_PW_5V  = ((BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD_25) INTERACT HVD_N) NOT INTERACT DNW
BESIDE_POST_DRIVER_NMOS_PW_33V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD_33
BESIDE_POST_DRIVER_NMOS_PW_25V = (BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD_25) NOT INTERACT HVD_N
BESIDE_POST_DRIVER_NMOS_PW_18V = BESIDE_POST_DRIVER_NMOS_PW_HV INTERACT OD_18
BESIDE_POST_DRIVER_NMOS_PW_LV  = BESIDE_POST_DRIVER_NMOS_PW NOT BESIDE_POST_DRIVER_NMOS_PW_HV

BESIDE_POST_DRIVER_NMOS_RWi = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNWc) BY DNWc
BESIDE_POST_DRIVER_NMOS_RWi_HV  = BESIDE_POST_DRIVER_NMOS_RWi INTERACT HV_GATE
BESIDE_POST_DRIVER_NMOS_RWi_33V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD_33
BESIDE_POST_DRIVER_NMOS_RWi_25V = (BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD_25) NOT INTERACT HVD_N
BESIDE_POST_DRIVER_NMOS_RWi_18V = BESIDE_POST_DRIVER_NMOS_RWi_HV INTERACT OD_18
BESIDE_POST_DRIVER_NMOS_RWi_LV  = BESIDE_POST_DRIVER_NMOS_RWi NOT BESIDE_POST_DRIVER_NMOS_RWi_HV


    
PTAP_guard_ring_holex = PTAP_guard_ring_hole ENCLOSE (POST_DRIVER_NACT OR BESIDE_POST_DRIVER_NMOS)
NTAP_guard_ring_holex = NTAP_guard_ring_hole ENCLOSE (POST_DRIVER_PACT OR BESIDE_POST_DRIVER_PMOS)
PTAP_guard_ring_wide = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_3_W
NTAP_guard_ring_wide = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_3_W

PW_inside_guard_ring_wide_pre1 = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide
PW_inside_guard_ring_wide = PW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide_pre1
NW_inside_guard_ring_wide_pre1 = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide
NW_inside_guard_ring_wide = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide_pre1

PTAP_guard_ring_wide_hole = (HOLES PTAP_guard_ring_wide INNER) OR PW_inside_guard_ring_wide
NTAP_guard_ring_wide_hole = (HOLES NTAP_guard_ring_wide INNER) OR NW_inside_guard_ring_wide

POST_DRIVER_PMOS_NW_5V_NG  = POST_DRIVER_PMOS_NW_5V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_33V_NG = POST_DRIVER_PMOS_NW_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_25V_NG = POST_DRIVER_PMOS_NW_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_18V_NG =  POST_DRIVER_PMOS_NW_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NW_LV_NG  = POST_DRIVER_PMOS_NW_LV NOT INSIDE NTAP_guard_ring_wide_hole

POST_DRIVER_PMOS_NWi_5V_NG  = POST_DRIVER_PMOS_NWi_5V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_33V_NG = POST_DRIVER_PMOS_NWi_33V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_25V_NG = POST_DRIVER_PMOS_NWi_25V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_18V_NG = POST_DRIVER_PMOS_NWi_18V NOT INSIDE NTAP_guard_ring_wide_hole
POST_DRIVER_PMOS_NWi_LV_NG  = POST_DRIVER_PMOS_NWi_LV NOT INSIDE NTAP_guard_ring_wide_hole

POST_DRIVER_NMOS_RW_33V_NG  = POST_DRIVER_NMOS_RW_33V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_25V_NG  = POST_DRIVER_NMOS_RW_25V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_18V_NG  = POST_DRIVER_NMOS_RW_18V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RW_LV_NG   = POST_DRIVER_NMOS_RW_LV NOT INSIDE PTAP_guard_ring_wide_hole

POST_DRIVER_NMOS_PW_5V_NG   = POST_DRIVER_NMOS_PW_5V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_33V_NG  = POST_DRIVER_NMOS_PW_33V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_25V_NG  = POST_DRIVER_NMOS_PW_25V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_18V_NG  = POST_DRIVER_NMOS_PW_18V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_PW_LV_NG   = POST_DRIVER_NMOS_PW_LV  NOT INSIDE PTAP_guard_ring_wide_hole

POST_DRIVER_NMOS_RWi_33V_NG  = POST_DRIVER_NMOS_RWi_33V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_25V_NG  = POST_DRIVER_NMOS_RWi_25V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_18V_NG  = POST_DRIVER_NMOS_RWi_18V NOT INSIDE PTAP_guard_ring_wide_hole
POST_DRIVER_NMOS_RWi_LV_NG   = POST_DRIVER_NMOS_RWi_LV NOT INSIDE PTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_PMOS_NW_NG = BESIDE_POST_DRIVER_PMOS_NW NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_5V_NG = BESIDE_POST_DRIVER_PMOS_NW_5V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_33V_NG = BESIDE_POST_DRIVER_PMOS_NW_33V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_25V_NG = BESIDE_POST_DRIVER_PMOS_NW_25V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_18V_NG = BESIDE_POST_DRIVER_PMOS_NW_18V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NW_LV_NG  = BESIDE_POST_DRIVER_PMOS_NW_LV NOT INSIDE NTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_PMOS_NWi_NG = BESIDE_POST_DRIVER_PMOS_NWi NOT INSIDE NTAP_guard_ring_wide_hole  
BESIDE_POST_DRIVER_PMOS_NWi_5V_NG = BESIDE_POST_DRIVER_PMOS_NWi_5V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_33V_NG = BESIDE_POST_DRIVER_PMOS_NWi_33V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_25V_NG = BESIDE_POST_DRIVER_PMOS_NWi_25V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_18V_NG = BESIDE_POST_DRIVER_PMOS_NWi_18V NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_PMOS_NWi_LV_NG  = BESIDE_POST_DRIVER_PMOS_NWi_LV NOT INSIDE NTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_NMOS_RW_NG = BESIDE_POST_DRIVER_NMOS_RW NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_NG = BESIDE_POST_DRIVER_NMOS_PW NOT INSIDE PTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_NMOS_RW_33V_NG = BESIDE_POST_DRIVER_NMOS_RW_33V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RW_25V_NG = BESIDE_POST_DRIVER_NMOS_RW_25V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RW_18V_NG = BESIDE_POST_DRIVER_NMOS_RW_18V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RW_LV_NG  = BESIDE_POST_DRIVER_NMOS_RW_LV NOT INSIDE PTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_NMOS_PW_5V_NG = BESIDE_POST_DRIVER_NMOS_PW_5V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_33V_NG = BESIDE_POST_DRIVER_NMOS_PW_33V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_25V_NG = BESIDE_POST_DRIVER_NMOS_PW_25V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_18V_NG = BESIDE_POST_DRIVER_NMOS_PW_18V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_LV_NG  = BESIDE_POST_DRIVER_NMOS_PW_LV NOT INSIDE PTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_NMOS_RWi_NG = BESIDE_POST_DRIVER_NMOS_RWi NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_33V_NG = BESIDE_POST_DRIVER_NMOS_RWi_33V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_25V_NG = BESIDE_POST_DRIVER_NMOS_RWi_25V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_18V_NG = BESIDE_POST_DRIVER_NMOS_RWi_18V NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_LV_NG  = BESIDE_POST_DRIVER_NMOS_RWi_LV NOT INSIDE PTAP_guard_ring_wide_hole 


#IFDEF GUIDELINE_LUP

LUP.1g {@ Any N+Active or an N+Active cluster connected to an I/O pad must be surrounded by a P+ guard-ring.
@ Any P+Active or a P+Active cluster connected to an I/O pad must be surrounded by a N+ guard-ring
   POST_DRIVER_NACT NOT INSIDE PTAP_guard_ring_hole  
   POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole 
}


LUP.2g {@ Within ^LUP_2 um space from the MOS connected to an I/O pad, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster.
  X = EXT POST_DRIVER_PMOS_NWi BESIDE_POST_DRIVER_NMOS_RWi < 5  ABUT <90 SINGULAR REGION NOT CONNECTED
  Y = EXT POST_DRIVER_PMOS_NW  BESIDE_POST_DRIVER_NMOS_RW  < 5  ABUT <90 SINGULAR REGION CONNECTED 
  BESIDE_POST_DRIVER_NMOS_check = BESIDE_POST_DRIVER_NMOS NOT (BESIDE_POST_DRIVER_NMOS_RWi NOT INTERACT (X OR Y))
  BESIDE_POST_DRIVER_NMOS_check NOT INSIDE PTAP_guard_ring_hole  
  BESIDE_POST_DRIVER_PMOS NOT INSIDE NTAP_guard_ring_hole  
}



LUP.3.1.1g {@ For the 1.2V or 1.0V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS >= ^LUP_3_1_1 um
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV < LUP_3_1_1 ABUT < 90 SINGULAR REGION NOT CONNECTED  
}

LUP.3.1.2g {@ For the 1.2V or 1.0V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS >= ^LUP_3_1_2 um
@ if one of guard-ring < ^LUP_3_W um    
  EXT POST_DRIVER_NMOS_PW_LV_NG POST_DRIVER_PMOS_NW_LV < LUP_3_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV_NG POST_DRIVER_PMOS_NW_LV < LUP_3_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG POST_DRIVER_PMOS_NWi_LV < LUP_3_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV_NG < LUP_3_1_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}


LUP.3.2.1g {@ For the 1.8V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 1.8V/1.2V/1.0V PMOS, space between the 1.8V PMOS and the 1.8V/1.2V/1.0V NMOS >= ^LUP_3_2_1 um
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_LV  < LUP_3_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_LV  < LUP_3_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_LV  < LUP_3_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_18V < LUP_3_2_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.2.2g {@ For the 1.8V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 1.8V/1.2V/1.0V PMOS, space between the 1.8V PMOS and the 1.8V/1.2V/1.0V NMOS >= ^LUP_3_2_2 um  if one of guard-ring < ^LUP_3_W um  
  EXT POST_DRIVER_NMOS_PW_18V_NG POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V_NG POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V_NG POST_DRIVER_PMOS_NWi_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_18V < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_18V_NG < LUP_3_2_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}


LUP.3.3.1g {@ For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.2V/1.0V PMOS, space between the 2.5V PMOS and the 2.5V/1.2V/1.0V NMOS >= ^LUP_3_3_1 um
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_LV  < LUP_3_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_25V < LUP_3_3_1 ABUT < 90 SINGULAR REGION NOT CONNECTED

}

LUP.3.3.2g {@ For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.2V/1.0V PMOS, space between the 2.5V PMOS and the 2.5V/1.2V/1.0V NMOS >= ^LUP_3_3_2 um if one of guard-ring < ^LUP_3_W um  
  EXT POST_DRIVER_NMOS_PW_25V_NG POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V_NG POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V_NG POST_DRIVER_PMOS_NWi_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_25V < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_25V_NG < LUP_3_3_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}



LUP.3.4.1g {@ For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.2V/1.0V PMOS, space between the 3.3V PMOS and the 3.3V/1.2V/1.0V NMOS >= ^LUP_3_4_1 um
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_LV  < LUP_3_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_33V < LUP_3_4_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.4.2g {@ For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.2V/1.0V PMOS, space between the 3.3V PMOS and the 3.3V/1.2V/1.0V NMOS >= ^LUP_3_4_2 um if one of guard-ring < ^LUP_3_W um  
  EXT POST_DRIVER_NMOS_PW_33V_NG POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG  POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V_NG POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V_NG POST_DRIVER_PMOS_NW_LV  < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG  POST_DRIVER_PMOS_NW_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V_NG POST_DRIVER_PMOS_NWi_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V_NG POST_DRIVER_PMOS_NWi_LV  < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_33V < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED

  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_LV_NG  < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_33V_NG < LUP_3_4_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

#IFDEF LP
#IFNDEF HALF_NODE
LUP.3.5.1g {@ For the 5V N/PMOS which connects to an I/O pad directly, space between the 5V NMOS and the 5V/2.5V/1.2V PMOS, space between the 5V PMOS and the 5V/2.5V/1.2V NMOS >= ^LUP_3_5_1 um
  EXT POST_DRIVER_NMOS_PW_5V   POST_DRIVER_PMOS_NW_5V  < LUP_3_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V   POST_DRIVER_PMOS_NW_25V < LUP_3_5_1 ABUT < 90 SINGULAR REGION  
  EXT POST_DRIVER_NMOS_PW_5V   POST_DRIVER_PMOS_NW_LV  < LUP_3_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV   POST_DRIVER_PMOS_NW_5V  < LUP_3_5_1 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V  POST_DRIVER_PMOS_NW_5V  < LUP_3_5_1 ABUT < 90 SINGULAR REGION

  EXT POST_DRIVER_NMOS_RW_25V  POST_DRIVER_PMOS_NW_5V  < LUP_3_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV   POST_DRIVER_PMOS_NW_5V  < LUP_3_5_1 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_5V < LUP_3_5_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}

LUP.3.5.2g {@ For the 5V N/PMOS which connects to an I/O pad directly, space between the 5V NMOS and the 5V/2.5V/1.2V PMOS, space between the 5V PMOS and the 5V/2.5V/1.2V NMOS >= ^LUP_3_5_2 um if one of guard-ring < ^LUP_3_W um  
  EXT POST_DRIVER_NMOS_PW_5V_NG   POST_DRIVER_PMOS_NW_5V     < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V_NG   POST_DRIVER_PMOS_NW_25V    < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V_NG   POST_DRIVER_PMOS_NW_LV     < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV_NG   POST_DRIVER_PMOS_NW_5V     < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V_NG  POST_DRIVER_PMOS_NW_5V     < LUP_3_5_2 ABUT < 90 SINGULAR REGION

  EXT POST_DRIVER_NMOS_RW_25V_NG  POST_DRIVER_PMOS_NW_5V     < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV_NG   POST_DRIVER_PMOS_NW_5V     < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V_NG POST_DRIVER_PMOS_NWi_5V    < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV_NG  POST_DRIVER_PMOS_NWi_5V    < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  
  EXT POST_DRIVER_NMOS_PW_5V      POST_DRIVER_PMOS_NW_5V_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V      POST_DRIVER_PMOS_NW_25V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_5V      POST_DRIVER_PMOS_NW_LV_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV      POST_DRIVER_PMOS_NW_5V_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V     POST_DRIVER_PMOS_NW_5V_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION

  EXT POST_DRIVER_NMOS_RW_25V     POST_DRIVER_PMOS_NW_5V_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV      POST_DRIVER_PMOS_NW_5V_NG  < LUP_3_5_2 ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V    POST_DRIVER_PMOS_NWi_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV     POST_DRIVER_PMOS_NWi_5V_NG < LUP_3_5_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
#ENDIF
#ENDIF

LUP.4g {@ Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within ^LUP_2 um space from the MOS connected to an I/O pad. >= ^LUP_4 um
  PTAP_guard_ring_wide2 = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_4
  NTAP_guard_ring_wide2 = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_4

  PW_inside_guard_ring_wide2_pre1 = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide2
  PW_inside_guard_ring_wide2 = PW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide2_pre1
  NW_inside_guard_ring_wide2_pre1 = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide2
  NW_inside_guard_ring_wide2 = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide2_pre1
  
  PTAP_guard_ring_wide2_hole = (HOLES PTAP_guard_ring_wide2 INNER) OR PW_inside_guard_ring_wide2
  NTAP_guard_ring_wide2_hole = (HOLES NTAP_guard_ring_wide2 INNER) OR NW_inside_guard_ring_wide2
  PTAP_guard_ring_hole_check = PTAP_guard_ring_holex NOT INSIDE PTAP_guard_ring_wide2_hole
  NTAP_guard_ring_hole_check = NTAP_guard_ring_holex NOT INSIDE NTAP_guard_ring_wide2_hole
  PTAP_guard_ring_check = PSTPi COIN OUTSIDE EDGE PTAP_guard_ring_hole_check
  NTAP_guard_ring_check = NSTPi COIN OUTSIDE EDGE NTAP_guard_ring_hole_check
  INT PTAP_guard_ring_check PSTPi < LUP_4 ABUT < 90 REGION
  INT NTAP_guard_ring_check NSTPi < LUP_4 ABUT < 90 REGION
}


LUP.5.1.1g {@ Minimum space >= ^LUP_5_1_1 um
@ 1. between 1.2V-1.0V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 1.2V-1.0V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_1_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_1_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1_1 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1_1 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_1_1 ABUT <90 SINGULAR REGION NOT CONNECTED
}

LUP.5.1.2g {@ Minimum space >= ^LUP_5_1_2 um if one of guard-ring < ^LUP_3_W um  
@ 1. between 1.2V-1.0V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 1.2V-1.0V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_LV_NG BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_1_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_LV_NG BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_1_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_LV_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_LV_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_LV_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_LV_NG BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_1_2 ABUT <90 SINGULAR REGION NOT CONNECTED

   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW_NG  < LUP_5_1_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW_NG  < LUP_5_1_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_1_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_1_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_1_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi_NG  < LUP_5_1_2 ABUT <90 SINGULAR REGION NOT CONNECTED
}

LUP.5.2.1g {@ Minimum space >= ^LUP_5_2_1 um
@ 1. between 1.8V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 1.8V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_2_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_2_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_18V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2_1 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_18V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2_1 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_18V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_2_1 ABUT <90 SINGULAR REGION NOT CONNECTED
}


LUP.5.2.2g {@ Minimum space >= ^LUP_5_2_2 um if one of guard-ring < ^LUP_3_W um
@ 1. between 1.8V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 1.8V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_18V_NG BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_2_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_18V_NG BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_2_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_18V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_18V_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_18V_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_18V_NG BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_2_2 ABUT <90 SINGULAR REGION NOT CONNECTED

   EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_PW_NG  < LUP_5_2_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_RW_NG  < LUP_5_2_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_2_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_18V BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_2_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_18V BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_2_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_18V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_2_2 ABUT <90 SINGULAR REGION NOT CONNECTED
}


LUP.5.3.1g {@ Minimum space >= ^LUP_5_3_1 um
@ 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_3_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_3_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_25V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3_1 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_25V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3_1 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_25V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_3_1 ABUT <90 SINGULAR REGION NOT CONNECTED
}

LUP.5.3.2g {@ Minimum space >= ^LUP_5_3_2 um if one of guard-ring < ^LUP_3_W um
@ 1. between 2.5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 2.5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_25V_NG BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_3_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_25V_NG BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_3_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_25V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_25V_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_25V_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_25V_NG BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_3_2 ABUT <90 SINGULAR REGION NOT CONNECTED

   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_PW_NG  < LUP_5_3_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_RW_NG  < LUP_5_3_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_3_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_25V BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_3_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_25V BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_3_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_25V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_3_2 ABUT <90 SINGULAR REGION NOT CONNECTED
}


LUP.5.4.1g {@ Minimum space >= ^LUP_5_4_1 um
@ 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_4_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_4_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_33V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_4_1 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_33V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_4_1 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_33V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_4_1 ABUT <90 SINGULAR REGION NOT CONNECTED
}

LUP.5.4.2g {@ Minimum space >= ^LUP_5_4_2 um if one of guard-ring < ^LUP_3_W um
@ 1. between 3.3V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 3.3V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_33V_NG BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_4_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_33V_NG BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_4_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_33V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_33V_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_4_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_33V_NG BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_4_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_33V_NG BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_4_2 ABUT <90 SINGULAR REGION NOT CONNECTED

   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_PW_NG  < LUP_5_4_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_RW_NG  < LUP_5_4_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_4_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_33V BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_4_2 ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_33V BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_4_2 ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_33V BESIDE_POST_DRIVER_PMOS_NWi_NG < LUP_5_4_2 ABUT <90 SINGULAR REGION NOT CONNECTED
}

#IFDEF LP
#IFNDEF HALF_NODE
LUP.5.5.1g {@ Minimum space >= ^LUP_5_5_1 um
@ 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_5V   BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_5_1  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_5V   BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_5_1  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_5V  BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_5_1  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_5V   BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_5_1  ABUT <90 SINGULAR REGION
}

LUP.5.5.2g {@ Minimum space >= ^LUP_5_5_2 um if one of guard-ring < ^LUP_3_W um
@ 1. between 5V NMOS which connects to the IO pad and the the PMOS in the internal circuit 
@ 2. between 5V PMOS which connects to the IO pad and the the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_5V_NG  BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_5_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_5V_NG  BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_5_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_5V_NG BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_5_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_5V_NG  BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_5_2  ABUT <90 SINGULAR REGION

   EXT POST_DRIVER_PMOS_NW_5V  BESIDE_POST_DRIVER_NMOS_PW_NG  < LUP_5_5_2  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_5V  BESIDE_POST_DRIVER_NMOS_RW_NG  < LUP_5_5_2  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_5V BESIDE_POST_DRIVER_NMOS_RWi_NG < LUP_5_5_2  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_5V  BESIDE_POST_DRIVER_PMOS_NW_NG  < LUP_5_5_2  ABUT <90 SINGULAR REGION
}
#ENDIF
#ENDIF

#ENDIF

CO_PACT = COi OR (PSDc NOT OUTSIDE COi)
NPUi = NSTPi INTERACT CO_PACT
NPUi_SRAM = NPUi INSIDE SRM 
NSTP_OS = SIZE NPUi BY LUP_6 INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NSTP_OS_SRAM = SIZE NPUi_SRAM BY LUP_6_SRAM INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PACT_CHECK = ((PACTi INTERACT COi) INTERACT POi) NOT POi
PACT_CHECK_NON_SRAM = PACT_CHECK NOT INSIDE SRM 
PACT_CHECK_SRAM =  PACT_CHECK INSIDE SRM

CO_NACT = COi OR (NSDc NOT OUTSIDE COi)
PPUi = PSTPi INTERACT CO_NACT
PPUi_SRAM = PPUi INSIDE SRM
PSTP_OS = SIZE PPUi BY LUP_6 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PSTP_OS_SRAM = SIZE PPUi_SRAM BY LUP_6_SRAM INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NACT_CHECK = ((NACTi INTERACT COi) INTERACT POi) NOT POi
NACT_CHECK_NON_SRAM = NACT_CHECK NOT INSIDE SRM 
NACT_CHECK_SRAM =  NACT_CHECK INSIDE SRM

LUP.6 { @ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_6 um
        @ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_6 um
	@ In SRAM bit cell region, the rule is relaxed to ^LUP_6_SRAM um    
  PACT_CHECK_NON_SRAM NOT NSTP_OS
  PACT_CHECK_SRAM NOT (NSTP_OS OR NSTP_OS_SRAM)
  NACT_CHECK_NON_SRAM NOT PSTP_OS
  NACT_CHECK_SRAM NOT (PSTP_OS OR PSTP_OS_SRAM)

}






#IFDEF GUIDELINE_ESD



NSDc_HVMOS = NSDc INTERACT HV_GATE
NSDc_LVMOS = NSDc INTERACT LV_GATE
PSDc_HVMOS = PSDc INTERACT HV_GATE
PSDc_LVMOS = PSDc INTERACT LV_GATE
NSDc_HVMOS_SDI = NSDc_HVMOS INTERACT SDI 
NSDc_LVMOS_SDI = NSDc_LVMOS INTERACT SDI 
PSDc_HVMOS_SDI = PSDc_HVMOS INTERACT SDI 
PSDc_LVMOS_SDI = PSDc_LVMOS INTERACT SDI 
HV_GATEc = STAMP HV_GATE BY ILP1i
LV_GATEc = STAMP LV_GATE BY ILP1i


PMOSi = (PACTi INTERACT POi) INTERACT COi 
NMOSi = (NACTi INTERACT POi) INTERACT COi
ESD_PMOS = SDI AND PMOSi
ESD_NMOS = SDI AND NMOSi
ESD_MOS  = ESD_PMOS OR ESD_NMOS

ESD_GATE = SDI AND GATE
ESD_GATE_fully_RPO = ESD_GATE INSIDE RPO 
ESD_GATE_partial_RPO = ESD_GATE CUT RPO  
ESD_GATE_RPO = ESD_GATE INTERACT RPO
ESD_GATE_noRPO = ESD_GATE NOT INTERACT RPO

ESD_GATE_W = GATE_W INSIDE EDGE SDI
ESD_GATE_L = GATE_L INSIDE EDGE SDI 
ESD_COOD = COOD AND ESD_MOS 

ESD_NSD = NSDu INTERACT ESD_GATE
ESD_PSD = PSDu INTERACT ESD_GATE
ESD_NSD_STACK = ESD_NSD NOT INTERACT CO


PSTPi_real = PSTPu NOT DIODMY
NSTPi_real = NSTPu NOT DIODMY


ESD_NMOS_SOURCE_pre1 = NET AREA RATIO ESD_NSD PSTPi_real  > 0 [!!AREA(ESD_NSD)*!!AREA(PSTPi_real)]
ESD_NMOS_SOURCE_pre2 = ((ESD_NMOS_SOURCE_pre1 OR ESD_GATE) OR ESD_NSD_STACK ) INTERACT ESD_NMOS_SOURCE_pre1
ESD_NMOS_DRAIN_pre1 = (ESD_NSD NOT ESD_NMOS_SOURCE_pre2) INTERACT ESD_NMOS_SOURCE_pre2
ESD_NMOS_DRAIN_pre2 = ((ESD_NMOS_DRAIN_pre1 OR ESD_GATE) OR ESD_NSD_STACK ) INTERACT ESD_NMOS_DRAIN_pre1
ESD_NMOS_SOURCE_pre3 = (ESD_NSD NOT ESD_NMOS_DRAIN_pre2) INTERACT ESD_NMOS_DRAIN_pre2
ESD_NMOS_SOURCE_pre4 = ESD_NMOS_SOURCE_pre1 OR ESD_NMOS_SOURCE_pre3
ESD_NMOS_DRAIN_pre4  = ESD_NSD NOT ESD_NMOS_SOURCE_pre4 
ESD_NMOS_normal = (ESD_NMOS INTERACT ESD_NMOS_SOURCE_pre4) INTERACT ESD_NMOS_DRAIN_pre4
ESD_NMOS_special = ESD_NMOS NOT ESD_NMOS_normal 
ESD_NMOS_SOURCE =  ((ESD_NSD INTERACT ESD_NMOS_special) NOT INTERACT RPO) OR (ESD_NMOS_SOURCE_pre4 INTERACT ESD_NMOS_normal)
ESD_NMOS_DRAIN   = ESD_NSD NOT ESD_NMOS_SOURCE

ESD_PMOS_SOURCE_pre1 = NET AREA RATIO ESD_PSD NSTPi_real > 0 [!!AREA(ESD_PSD)*!!AREA(NSTPi_real)]
ESD_PMOS_SOURCE_pre2 = ESD_PMOS_SOURCE_pre1 OR (ESD_GATE INTERACT ESD_PMOS_SOURCE_pre1) 
ESD_PMOS_DRAIN_pre1 = (ESD_PSD NOT ESD_PMOS_SOURCE_pre2) INTERACT ESD_PMOS_SOURCE_pre2
ESD_PMOS_DRAIN_pre2 = ESD_PMOS_DRAIN_pre1 OR (ESD_GATE INTERACT ESD_PMOS_DRAIN_pre1)
ESD_PMOS_SOURCE_pre3 = (ESD_PSD NOT ESD_PMOS_DRAIN_pre2) INTERACT ESD_PMOS_DRAIN_pre2
ESD_PMOS_SOURCE_pre4 = ESD_PMOS_SOURCE_pre1 OR ESD_PMOS_SOURCE_pre3
ESD_PMOS_DRAIN_pre4  = ESD_PSD NOT ESD_PMOS_SOURCE_pre4 
ESD_PMOS_normal = (ESD_PMOS INTERACT ESD_PMOS_SOURCE_pre4) INTERACT ESD_PMOS_DRAIN_pre4
ESD_PMOS_special = ESD_PMOS NOT ESD_PMOS_normal 
ESD_PMOS_SOURCE =  ((ESD_PSD INTERACT ESD_PMOS_special) NOT INTERACT RPO) OR (ESD_PMOS_SOURCE_pre4 INTERACT ESD_PMOS_normal)
ESD_PMOS_DRAIN   = ESD_PSD NOT ESD_PMOS_SOURCE



ESD_MOS_SOURCE  = ESD_NMOS_SOURCE OR ESD_PMOS_SOURCE 
ESD_MOS_DRAIN   = ESD_NMOS_DRAIN OR ESD_PMOS_DRAIN

ESD_NMOSc = STAMP ESD_NMOS BY ESD_NMOS_DRAIN
ESD_PMOSc = STAMP ESD_PMOS BY ESD_PMOS_DRAIN 

#IFDEF FULL_CHIP
ESD.WARN.1 {@ SDI is  not in whole chip 
   CHIPx NOT INTERACT SDI
}
#ENDIF


ESD.WARN.2 {@ SDI encloure of ACTIVE >= 0
   (DACT INTERACT SDI) NOT SDI     
}




ESD.1g {@  Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers
   NET AREA RATIO NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0 
	[!!AREA(NSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))] 
	RDB ESD.1g.hv_n.rep NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
   NET AREA RATIO NSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc PSTPi > 0 
	[!!AREA(NSDc_LVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_HVMOS)+!!AREA(PSDc_HVMOS)+!!AREA(HV_GATEc))]
        RDB ESD.1g.lv_n.rep NSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc 
   NET AREA RATIO PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0
	[!!AREA(PSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))]
        RDB ESD.1g.hv_p.rep PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
   NET AREA RATIO PSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc PSTPi > 0 
	[!!AREA(PSDc_LVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_HVMOS)+!!AREA(PSDc_HVMOS)+!!AREA(HV_GATEc))]
	RDB ESD.1g.lv_p.rep PSDc_LVMOS_SDI NSDc_HVMOS PSDc_HVMOS HV_GATEc
} 



ESD.3g{@ Unit finger width of NMOS and PMOS for I/O buffer and Power Clamp Device  = 15-60
  PATH LENGTH ESD_GATE_W < ESD_3g_MIN
  PATH LENGTH ESD_GATE_W > ESD_3g_MAX
}


ESD.4g{@ The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain, to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping.
  EDGE_NSD = NSDu INTERACT ESD_GATE == 1
  EDGE_NSD NOT ESD_NMOS_SOURCE 
  EDGE_PSD = PSDu INTERACT ESD_GATE == 1
  EDGE_PSD NOT ESD_PMOS_SOURCE 
}

ESD.5g{@ For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. All other type ODs should be placed outside this guard-ring.
    ESD_PMOS NOT INSIDE NTAP_guard_ring_hole 
    ESD_NMOS NOT INSIDE PTAP_guard_ring_hole 
}

ESD.6g{@ Butted STRAP and the STRAP which are between two sources of the N/PMOS in the same I/O buffer and Power Clamp are strictly prohibited. 
   A = (EXT ESD_NMOSc < ESD_6g ABUT< 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
   A INTERACT PSTPi
   B = (EXT ESD_PMOSc < ESD_6g ABUT< 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
   B INTERACT NSTPi
}


PSDc_CB= NET AREA RATIO PSDc IO_CBi IO_CB2i IO_UBMni IO_UBMdi >0[!!AREA(IO_CBi)+!!AREA(IO_CB2i)+!!AREA(IO_UBMni)+!!AREA(IO_UBMdi)]
NSDc_CB= NET AREA RATIO NSDc IO_CBi IO_CB2i IO_UBMni IO_UBMdi >0[!!AREA(IO_CBi)+!!AREA(IO_CB2i)+!!AREA(IO_UBMni)+!!AREA(IO_UBMdi)]
NWELc = COPY NWEL
CONNECT NWELc
PWELc = COPY PWEL
CONNECT PWELc

ESD.7g{@ Excepting the ESD device, either of the following two condition must be followed.
@ 1. the space of two same type ODs >= 2.4um   2. two same type ODs should be separated by different type OD.    
@ The same type ODs are N+OD and N+OD in the same PW, or P+OD and P+OD in the same NW, which connect to two different Pad.
@ However,if a resistor between pad and checked OD, DRC will not flag the error. 
  PACT_CHECK = (PACT INTERACT PSDc_CB) NOT ESD_PMOS 
  PACT_CHECK_CB = STAMP PACT_CHECK BY PSDc_CB
  P1 = EXT PACT_CHECK_CB < ESD_7g ABUT<90 SINGULAR REGION NOT CONNECTED
  PACT_CHECK_NW = STAMP (PACT_CHECK INTERACT P1) BY NWELc
  P2 = EXT PACT_CHECK_NW < ESD_7g ABUT<90 SINGULAR REGION CONNECTED
  P3 = P1 AND P2
  (P3 NOT NSTPi) INTERACT PACT_CHECK_CB > 1 BY NET
  
  NACT_CHECK = (NACT INTERACT NSDc_CB) NOT ESD_NMOS 
  NACT_CHECK_CB = STAMP NACT_CHECK BY NSDc_CB
  N1 = EXT NACT_CHECK_CB < ESD_7g ABUT<90 SINGULAR REGION NOT CONNECTED
  NACT_CHECK_PW = STAMP (NACT_CHECK INTERACT N1) BY PWELc
  N2 = EXT NACT_CHECK_PW < ESD_7g ABUT<90 SINGULAR REGION CONNECTED
  N3 = N1 AND N2
   (N3 NOT PSTPi) INTERACT NACT_CHECK_CB > 1 BY NET

}


ESD.12g{@ It is not recommended to use OD RPO resistor or NW resistor connected to PAD 
   ODRES_terminal = ((OD NOT POLY) INTERACT ODRES_a) NOT ODRES_a    
   ODRES_terminalc = STAMP ODRES_terminal BY COu 
   NET AREA RATIO ODRES_terminalc CBu CB2u UBMnu UBMdu> 0 
   [!!AREA(ODRES_terminalc)*(!!AREA(CBu)+!!AREA(CB2u)+!!AREA(UBMnu)+!!AREA(UBMdu))]  
   NET AREA RATIO NWRuT CBu CB2u UBMnu UBMdu > 0 
   [!!AREA(NWRuT)*(!!AREA(CBu)+!!AREA(CB2u)+!!AREA(UBMnu)+!!AREA(UBMdu))]  
}

ESD_PMOS_GATE_W = ESD_GATE_W INSIDE EDGE PP
ESD_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE NP
ESD_PMOS_GATE_W_EXP = EXPAND EDGE ESD_PMOS_GATE_W INSIDE BY GRID
ESD_NMOS_GATE_W_EXP = EXPAND EDGE ESD_NMOS_GATE_W INSIDE BY GRID
ESD_PMOS_GATE_W_EXPc = STAMP ESD_PMOS_GATE_W_EXP BY ESD_PMOSc 
ESD_NMOS_GATE_W_EXPc = STAMP ESD_NMOS_GATE_W_EXP BY ESD_NMOSc 



ESD.16g{@ Total finger width for NMOS in same connection > 360
@ ESD.24g/ESD.36g/ESD.44g/ESD.53g are also checked by ESD.16g 
   NET AREA RATIO ESD_NMOS_GATE_W_EXPc < ESD_16g
   [(AREA(ESD_NMOS_GATE_W_EXPc)/2)/GRID]
   RDB ESD.16g.NMOS.rep ESD_NMOS_GATE_W_EXPc
}

ESD.17g{@ Total finger width for PMOS in same connection > 360
@ ESD.25g/ESD.45g are also checked by ESD.17g 
   NET AREA RATIO ESD_PMOS_GATE_W_EXPc < ESD_17g
   [(AREA(ESD_PMOS_GATE_W_EXPc)/2)/GRID]
   RDB ESD.17g.PMOS.rep ESD_PMOS_GATE_W_EXPc
}


33V_ESD_GATE_W = ESD_GATE_W INSIDE EDGE OD_33
25V_ESD_GATE_W = ESD_GATE_W INSIDE EDGE OD_25
18V_ESD_GATE_W = ESD_GATE_W INSIDE EDGE OD_18
LV_ESD_GATE_W  = ESD_GATE_W NOT INSIDE EDGE OD2


ESD.18g { @ Channel length of 3.3V I/O and Power Clamp >= 0.4
@ Channel length of 2.5V I/O and Power Clamp >= 0.35
@ Channel length of 1.8V I/O and Power Clamp >= 0.20 
@ Channel length of 1.0V/1.2V I/O and Power Clamp >= 0.1
@ ESD.26g/ESD.38g/ESD.46g/ESD.54g are also checked by ESD.18g 
   INT 33V_ESD_GATE_W < ESD_18g_33V ABUT < 90 REGION
   INT 25V_ESD_GATE_W < ESD_18g_25V ABUT < 90 REGION
   INT 18V_ESD_GATE_W < ESD_18g_18V ABUT < 90 REGION
   INT LV_ESD_GATE_W  < ESD_18g_10V ABUT < 90 REGION
}

RegularIO_NMOS = (ESD_NMOS INTERACT ESD_GATE_partial_RPO) NOT INTERACT ESD_GATE_fully_RPO
RegularIO_PMOS = (ESD_PMOS INTERACT ESD_GATE_partial_RPO) NOT INTERACT ESD_GATE_fully_RPO
RegularIO_MOS  = RegularIO_NMOS OR RegularIO_PMOS
RegularIO_NMOS_DRAIN = ESD_NMOS_DRAIN AND RegularIO_NMOS
RegularIO_PMOS_DRAIN = ESD_PMOS_DRAIN AND RegularIO_PMOS
RegularIO_MOS_DRAIN = ESD_MOS_DRAIN AND RegularIO_MOS
RegularIO_GATE = ESD_GATE AND RegularIO_MOS

ESD.19g { @ The NMOS and PMOS should have an unsilicided area on the drain side. That is, the RPO mask should block the drain side of the device (except the contact region which should remain silicided).
@ ESD.27g/ESD.39g are also checked by ESD.19g      
   RegularIO_MOS_DRAIN NOT INTERACT RPO
   RegularIO_MOS NOT INTERACT RPO    
}

ESD.20g{@ Overlap of RPO on the drain side to the poly gate =0.06
@ ESD.29g/ESD.40g are also checked by ESD.20g    
   X = ESD_GATE_W TOUCH OUTSIDE EDGE RegularIO_MOS_DRAIN 
   A = EXPAND EDGE X INSIDE BY ESD_20g  
   B = RPO AND RegularIO_GATE
   A XOR B
}

ESD.21g{@ Width of the RPO on the drain side for NMOS 	>= 1.95 
@ ESD.41g is also checked by ESD.21g
   A = RegularIO_NMOS_DRAIN AND RPO 
   INT A < ESD_21g ABUT < 90 SINGULAR REGION
}

ESD.22g{@ Width of the RPO on the drain side for PMOS 	>= 1.0 
@ ESD.31g is also checked by ESD.22g
   A = RegularIO_PMOS_DRAIN AND RPO 
   INT A < ESD_22g ABUT < 90 SINGULAR REGION
}

ESD.23g{@ Space of poly to CO on the source side >= 0.22
@ ESD.32g/ESD.42g are also checked by ESD.23g    
   A = ESD_GATE_W TOUCH INSIDE EDGE RegularIO_GATE
   EXT ESD_COOD A < ESD_23g ABUT < 90 REGION
}

HV_TOL_IO_NMOS = (ESD_NMOS INTERACT ESD_GATE_fully_RPO) INTERACT ESD_GATE_partial_RPO
HV_TOL_IO_NMOS_DRAIN = (ESD_NMOS_DRAIN INTERACT CO) AND HV_TOL_IO_NMOS
HV_TOL_IO_NMOS_DRAIN_x = (ESD_NMOS_DRAIN NOT INTERACT CO) AND HV_TOL_IO_NMOS
HV_TOL_IO_NMOS_SOURCE = ESD_NMOS_SOURCE AND HV_TOL_IO_NMOS
HV_TOL_IO_GATE = ESD_GATE AND HV_TOL_IO_NMOS 
HV_TOL_IO_GATEa = HV_TOL_IO_GATE INTERACT HV_TOL_IO_NMOS_DRAIN
HV_TOL_IO_GATEb = (HV_TOL_IO_GATE NOT INTERACT HV_TOL_IO_NMOS_DRAIN) INTERACT HV_TOL_IO_NMOS_DRAIN_x

ESD.27g{@ The NMOS and PMOS should have an unsilicided area on the drain side. That is, the RPO mask should block the drain side of the device (except the contact region which should remain silicided).DRC only flag no RPO in this device.
   HV_TOL_IO_NMOS_DRAIN NOT INTERACT RPO 
   HV_TOL_IO_NMOS_DRAIN_x NOT RPO    
   HV_TOL_IO_NMOS NOT INTERACT RPO 
}

ESD.28g{@ For NMOS, the RPO needs to cover all inactive poly gates(N2) and extend to overlap the N3 gate = 0.06
   HV_TOL_IO_GATEa NOT RPO
   X = (ESD_GATE_W TOUCH INSIDE EDGE HV_TOL_IO_GATEb) TOUCH OUTSIDE EDGE HV_TOL_IO_NMOS_DRAIN_x 
   A = EXPAND EDGE X INSIDE BY ESD_28g  
   B = RPO AND HV_TOL_IO_GATEb
   A XOR B
}    

ESD.30g{@ Width of the RPO on the drain side for NMOS. >= 1.95
   A = HV_TOL_IO_NMOS_DRAIN AND RPO 
   INT A < ESD_30g ABUT < 90 SINGULAR REGION
}

ESD.32g{@ Space of poly to CO on the source side >= 0.22
   A = ESD_GATE_W TOUCH INSIDE EDGE HV_TOL_IO_GATE
   EXT ESD_COOD A < ESD_32g ABUT < 90 REGION
}


ESD.33g{@ For NMOS, space of the N2 gate to the N3 gate. = 0.25 
   A = EXT HV_TOL_IO_GATEa HV_TOL_IO_GATEb == ESD_33g ABUT < 90 SINGULAR REGION 
   HV_TOL_IO_NMOS_DRAIN_x XOR A 
}

ESD.34g{@ The NMOS should have ESD3
   HV_TOL_IO_NMOS NOT INTERACT ESD3   
}


NCS_NMOS = ESD_NMOS NOT INTERACT RPO
NCS_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE NCS_NMOS 
NCS_NMOS_GATE_W_EXP = EXPAND EDGE NCS_NMOS_GATE_W INSIDE BY GRID 
NCS_NMOS_GATE_W_EXPc = STAMP NCS_NMOS_GATE_W_EXP BY  ESD_NMOSc

NCS_NMOS_GATE = ESD_GATE AND NCS_NMOS

ESD.37g{@ Total finger width for Power Clamp in same connection > 900
   NET AREA RATIO NCS_NMOS_GATE_W_EXPc < ESD_37g
   [(AREA(NCS_NMOS_GATE_W_EXPc)/2)/GRID]
   RDB ESD.37g.rep  NCS_NMOS_GATE_W_EXPc
}




RegularIO_type2_NMOS = (ESD_NMOS INTERACT RPO) NOT INTERACT ESD_GATE_RPO
RegularIO_type2_PMOS = (ESD_PMOS INTERACT RPO) NOT INTERACT ESD_GATE_RPO 
RegularIO_type2_MOS  = RegularIO_type2_NMOS OR RegularIO_type2_PMOS
RegularIO_type2_NMOS_DRAIN = ESD_NMOS_DRAIN AND RegularIO_type2_NMOS
RegularIO_type2_PMOS_DRAIN = ESD_PMOS_DRAIN AND RegularIO_type2_PMOS
RegularIO_type2_MOS_DRAIN = ESD_MOS_DRAIN AND RegularIO_type2_MOS
RegularIO_type2_GATE = ESD_GATE AND RegularIO_type2_MOS


ESD.47g{@ The NMOS and PMOS should have an unsilicided area on the drain side. That is, the RPO mask should be in the drain side of the device (except the contact region which should remain silicided).
   RegularIO_type2_MOS_DRAIN NOT INTERACT RPO
}

ESD.48g{@ RPO on the drain side space to the poly gate = 0.45
   X = ESD_GATE_W TOUCH OUTSIDE EDGE RegularIO_type2_MOS_DRAIN
   A = EXPAND EDGE X OUTSIDE BY ESD_48g  
   B = EXT RPO RegularIO_type2_GATE == ESD_48g ABUT < 90 SINGULAR REGION
   A XOR B
}

ESD.49g{@ Width of the RPO on the drain side for NMOS. >= 1.5
   A = RegularIO_type2_NMOS_DRAIN AND RPO 
   INT A < ESD_49g ABUT < 90 SINGULAR REGION
}

ESD.50g{@ Width of the RPO on the drain side for PMOS. >= 1.0
   A = RegularIO_type2_PMOS_DRAIN AND RPO 
   INT A < ESD_50g ABUT < 90 SINGULAR REGION
}

ESD.51g{@ Space of poly to CO on the source side  >= 0.22 
   A = ESD_GATE_W TOUCH INSIDE EDGE RegularIO_type2_GATE
   EXT ESD_COOD A < ESD_51g ABUT < 90 REGION
}

ESD.52g{@ 1.8V regular IO INTERACT OD_25 or OD_33 is not recommended.
   RegularIO_type2_MOS INTERACT OD_25
   RegularIO_type2_MOS INTERACT OD_33
}

NCS_type2_NMOS = ((ESD_NMOS INTERACT RPO) INTERACT ESD_GATE_fully_RPO) NOT INTERACT ESD_GATE_partial_RPO
NCS_type2_NMOS_DRAIN = ESD_NMOS_DRAIN AND NCS_type2_NMOS
NCS_type2_NMOS_SOURCE = ESD_NMOS_SOURCE AND NCS_type2_NMOS
NCS_type2_NMOS_GATE = ESD_GATE AND NCS_type2_NMOS

ESD.55g{@ The NMOS should have an unsilicided area on the drain/source side. That is, the RPO mask should be in the drain/source side of the device (except the contact region which should remain silicided). 
   NCS_type2_NMOS_DRAIN NOT INTERACT RPO
   NCS_type2_NMOS_SOURCE NOT INTERACT RPO    
}

ESD.56g{@ Width of the RPO on the drain side for NMOS >= 1.95
   A = NCS_type2_NMOS_DRAIN AND RPO 
   INT A < ESD_56g ABUT < 90 SINGULAR REGION
}

ESD.57g{@ Space of poly to CO on the source side  >= 0.22 
   A = ESD_GATE_W TOUCH INSIDE EDGE NCS_type2_NMOS_GATE
   EXT ESD_COOD A < ESD_57g ABUT < 90 REGION 
} 
/*
ESD_NMOS_SOURCE {COPY ESD_NMOS_SOURCE  }
ESD_NMOS_DRAIN {COPY ESD_NMOS_DRAIN}
ESD_PMOS_SOURCE {COPY ESD_PMOS_SOURCE }
ESD_PMOS_DRAIN{COPY ESD_PMOS_DRAIN}
*/

NFD = ((NACT NOT INTERACT POLY) AND SDI) CUT RPO 
PFD = ((PACT NOT INTERACT POLY) AND SDI) CUT RPO 
NFDc = STAMP NFD BY NSDc
PFDc = STAMP PFD BY PSDc
NFD_Emitter = NET AREA RATIO NFDc PSTPi > 0
NFD_Collector = NFDc NOT NFD_Emitter 
PFD_Emitter = NET AREA RATIO PFDc NSTPi > 0
PFD_Collector = PFDc NOT PFD_Emitter

NFD_STI = EXT NFD_Collector NFD_Emitter == ESD_60g OPPOSITE REGION
PFD_STI = EXT PFD_Collector PFD_Emitter == ESD_60g OPPOSITE REGION

ESD.58g {@ Total width for NFD in same connection of collector >= ^ESD_58g 
    A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
    A1 = EXPAND EDGE A INSIDE BY GRID 
    Ac = STAMP A1 BY NFD_Collector
    NET AREA RATIO Ac < ESD_58g
    [(AREA(Ac)/2)/GRID]
}

ESD.59g {@ Total width for PFD in same connection of collector >= ^ESD_59g 
    A =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
    A1 = EXPAND EDGE A INSIDE BY GRID 
    Ac = STAMP A1 BY PFD_Collector
    NET AREA RATIO Ac < ESD_59g
    [(AREA(Ac)/2)/GRID]
}

ESD.60g {@ STI spacing of the NFD and PFD = ^ESD_60g
   NFD_Collector NOT INTERACT NFD_STI == 2
   PFD_Collector NOT INTERACT PFD_STI == 2
}

ESD.61g	{@ Unit collector width of NFD and PFD = ^ESD_61g_MIN ~ ^ESD_61g_MAX
   A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI  
   LENGTH A < ESD_61g_MIN
   LENGTH A > ESD_61g_MAX
   B =  PFD_Collector COIN OUTSIDE EDGE PFD_STI  
   LENGTH B < ESD_61g_MIN
   LENGTH B > ESD_61g_MAX
}

ESD.62g	{@ Unit emitter width of NFD and PFD should be the same as unit collector width
   NOT RECTANGLE ( (NFD_STI OR NFD_Emitter) OR NFD_Collector)   
   NOT RECTANGLE ( (PFD_STI OR PFD_Emitter) OR PFD_Collector)  
}

ESD.63g {@ Unit emitter length of NFD and PFD >= ^ESD_63g
   INT NFD_Emitter < ESD_63g ABUT<90 SINGULAR REGION 
   INT PFD_Emitter < ESD_63g ABUT<90 SINGULAR REGION 
}

ESD.64g	{@ Width of the RPO on the collector side for NFD and PFD >= ^ESD_64g
   A =  NFD_Collector COIN OUTSIDE EDGE NFD_STI
   A1 = EXPAND EDGE A INSIDE BY ESD_64g
   A1 NOT RPO
   B =  PFD_Collector COIN OUTSIDE EDGE PFD_STI
   B1 = EXPAND EDGE B INSIDE BY ESD_64g
   B1 NOT RPO
}

ESD.65g	{@ Width of the RPO on the emitter side for NFD and PFD	= ^ESD_65g
   A =  NFD_Emitter COIN OUTSIDE EDGE NFD_STI
   A1 = EXPAND EDGE A INSIDE BY ESD_65g
   A1 XOR (RPO AND NFD_Emitter)
   B =  PFD_Emitter COIN OUTSIDE EDGE PFD_STI
   B1 = EXPAND EDGE B INSIDE BY ESD_65g
   B1 XOR (RPO AND PFD_Emitter)
}

ESD.66g {@ Space of RPO to CO on the collector and emitter side >= ^ESD_66g
   A = CO AND (NFD OR PFD)
   EXT A RPO < ESD_66g ABUT<90 SINGULAR REGION    
}

ESD.72g {@ The layer of OD2 is required for 5V protection (NFD and PFD)
    NFD NOT OD2
    PFD NOT OD2	
}

#ENDIF


//SRAM CHECKS
//===========
SRAM.W.1 { @ SRM width (interact with OD) >= ^SRAM_W_1 um 
  (INT SRM < SRAM_W_1 ABUT < 90 SINGULAR REGION) INTERACT ODi
}
SRAM.S.1 { @ SRM space (interact with OD) >= ^SRAM_S_1 um 
  (EXT SRM < SRAM_S_1 ABUT < 90 SINGULAR REGION) INTERACT ODi
}
SRAM.S.2 { @ SRM space to {GATE not interact with SRM} >= ^SRAM_S_2 um 
  A = POi AND ODi
  B = A NOT INTERACT SRM    
  EXT B SRM < SRAM_S_2 ABUT < 90 SINGULAR REGION
}
SRAM.EN.1 { @ SRM enclosusre of GATE >= ^SRAM_EN_1 um 
  A = POi AND ODi 
  ENC A SRM < SRAM_EN_1 ABUT < 90 SINGULAR REGION
}
SRAM.EX.1 { @ SRM Extension on NWEL (interact with OD) >= ^SRAM_EX_1 um 
  (ENC NWi SRM < SRAM_EX_1 ABUT < 90 > 0 SINGULAR REGION) INTERACT ODi
}
SRAM.O.1 { @ SRM Overlap of NWEL (interact with OD) >= ^SRAM_O_1 um 
  (INT (SRM AND NWi) < SRAM_O_1 ABUT < 90 OPPOSITE REGION) INTERACT ODi
}
SRAM.R.12 { @ SRMDMY(186;4) overlap SRAMDMY(186;0) is not allowed.
  SRAMDMY_PERI AND SRAMDMY
}
SRAM.R.13 { @ SRM must fully cover GATE.
  A = (POi AND ODi) INTERACT SRM
  A NOT SRM    
}

#IFDEF HALF_NODE
SRAM.R.15 { @ CO_11 (30;11) is a must for CO mask tape-out except 0.62um2 SRAM cell of N55GP
@ 1.if CO_11 exists, it must cover CO    
@ 2.CO_11 must be 0.09 um x 0.09 um
@ 3.CO_11 must be exactly the same as CO	
@ 4.CO_11 must be fully covered by SRM(50;0) and SRAMDMY(186;0)
@ 5.CO_11 is must on square OD contact if CO.S.3 is rule pushed in SRAM.  
@ 6.CO_11 is not allowed on square OD contact if CO.S.3 is not rule pushed in SRAM.  
    A = (COi INTERACT SRAMDMY) INTERACT SRM 
    B = RECTANGLE A == CO_W_1 BY == CO_W_1
    CO_PUSH NOT INTERACT B
    C = A INTERACT CO_PUSH
    C XOR CO_PUSH
    D = B INTERACT ODi
    E = EXT D POi < CO_S_3 ABUT<90 OPPOSITE REGION
    E NOT TOUCH CO_PUSH
    (CO_PUSH AND ODi) NOT TOUCH E   
}
#ELSE
SRAM.R.15 { @ CO_11 (30;11) is a must for CO mask tape-out except 0.62um2 SRAM cell of N55GP
@ 1.if CO_11 exists, it must cover CO    
@ 2.CO_11 must be 0.09 um x 0.09 um
@ 3.CO_11 must be exactly the same as CO	
@ 4.CO_11 must be fully covered by SRM(50;0) and SRAMDMY(186;0)
    A = (COi INTERACT SRAMDMY) INTERACT SRM 
    B = RECTANGLE A == CO_W_1 BY == CO_W_1
    CO_PUSH NOT INTERACT B
    C = A INTERACT CO_PUSH
    C XOR CO_PUSH
}
#ENDIF


SRAM.R.17 { @ SRAMDMY(186;0) must fully cover OD,CO,VIA1
   ODi CUT SRAMDMY
   COi CUT SRAMDMY 
   VIA1i CUT SRAMDMY
}

#IFDEF HALF_NODE
SRAM.R.18 {@ SRAMDMY (186;0) must fully cover SRAMDMY_1(186;1)
    SRAMDMY_1 NOT SRAMDMY
    (SRAMDMY AND SRM) NOT ENCLOSE SRAMDMY_1
}
#ENDIF

SRAM.A.1{@ Enclosed area of Donut-type OD (Enclosed area of OD > 0) interact with poly in SRM region >= ^SRAM_A_1
   SRAM_OD  = ODi NOT OUTSIDE SRM
   SRAM_OD_HOLE = HOLES SRAM_OD INNER    
   SRAM_OD_HOLE_CHECK = SRAM_OD_HOLE TOUCH (POi AND SRAM_OD)  
   AREA SRAM_OD_HOLE_CHECK < SRAM_A_1
}


NW.S.1.SRM_SRAMDMY { @ Spacing between NW along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (NW_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(NW_S_1 + GRID)
  C = A NOT B
  D = NWi NOT OUTSIDE C
  E = EXT D < NW_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
OD.S.1.SRM_SRAMDMY { @ Spacing between OD along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (OD_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(OD_S_1 + GRID)
  C = A NOT B
  D = ODi NOT OUTSIDE C
  E = EXT D < OD_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
PO.S.1.SRM_SRAMDMY { @ Spacing between POLY along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (PO_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(PO_S_1 + GRID)
  C = A NOT B
  D = POi NOT OUTSIDE C
  E = EXT D < PO_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
NP.S.1.SRM_SRAMDMY { @ Spacing between NP along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (NP_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(NP_S_1 + GRID)
  C = A NOT B
  D = NPi NOT OUTSIDE C
  E = EXT D < NP_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
PP.S.1.SRM_SRAMDMY { @ Spacing between PP along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (PP_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(PP_S_1 + GRID)
  C = A NOT B
  D = PPi NOT OUTSIDE C
  E = EXT D < PP_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
CO.S.1.SRM_SRAMDMY { @ Spacing between CO along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (CO_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(CO_S_1 + GRID)
  C = A NOT B
  D = COi NOT OUTSIDE C
  E = EXT D < CO_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
M1.S.1.SRM_SRAMDMY { @ Spacing between M1 along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (M1_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(M1_S_1 + GRID)
  C = A NOT B
  D = M1i NOT OUTSIDE C
  E = EXT D < M1_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}
VIA1.S.1.SRM_SRAMDMY { @ Spacing between VIA1 along the boundary of SRM and SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (VIA1_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(VIA1_S_1 + GRID)
  C = A NOT B
  D = VIA1i NOT OUTSIDE C
  E = EXT D < VIA1_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE
}



// SRAM WORD LINE DECODER CHECKS
//-------------

OD_PERI = ODi AND SRAMDMY_PERI
CO_PERI = COi NOT OUTSIDE SRAMDMY_PERI

CO_PERI_4 = CO_PERI NOT OUTSIDE SRAMDMY_4
CO_PERI_5 = CO_PERI NOT OUTSIDE SRAMDMY_5
COOD_PERI = CO_PERI NOT OUTSIDE OD_PERI

CONNECT COOD_PERI OD_PERI

NPOD_PERI = OD_PERI AND NPi
PPOD_PERI = OD_PERI AND PPi

NSTP_PERI = NPOD_PERI AND NWi
PSTP_PERI = PPOD_PERI NOT NWi
STP_PERI = NSTP_PERI OR PSTP_PERI

NACT_PERI = NPOD_PERI NOT NWi
PACT_PERI = PPOD_PERI AND NWi
DACT_PERI = NACT_PERI OR PACT_PERI
ACT_PERI = DACT_PERI INTERACT POi
SD_PERI = ACT_PERI NOT POi

WLD.R.1 { @ {CO AND SRAMDMY (186;4)} space to PO . >= 0.05 
  EXT CO_PERI_4 POi < WLD_R_1 ABUT < 90 SINGULAR REGION
}
WLD.R.2 { @ {CO SRAMDMY (186;5)} space to PO >= 0.043 
  EXT CO_PERI_5 POi < WLD_R_2 ABUT < 90 SINGULAR REGION
}


WLD.R.3 { @ CO space on the same OD [inside SRAMDMY (186;4 & 186;5)] >= 0.14 
  EXT COOD_PERI < WLD_R_3 ABUT < 90 CONNECTED SINGULAR REGION 
}

WLD.R.6 { @ SRAMDMY (186;4 & 186;5) edge cut CO is not allowed
  CO_PERI CUT SRAMDMY_4
  CO_PERI CUT SRAMDMY_5
}
WLD.R.7 { @ SRMDMY (186;0) upsized 200 um must cover SRMDMY (186;4,5)
  S = SIZE SRAMDMY BY WLD_R_7
  SRAMDMY_4 NOT S
  SRAMDMY_5 NOT S
}




// Analog Checks
//==============

POS14m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS14m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS14m_POCell = POS14m_POCellIn AND POS14m_POCellOut
POS14m_POMarker = POi AND RRuleAnalog 
POS14m_PO = ((( POS14m_POCell OR POS14m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS14m_GATE = ( GATE_NP AND POS14m_PO ) NOT OD2 
POS14m_NW = OD2 OR (NWEL OR NTN)
PO.S.14m { @ Gate space to ( OD2 OR (NW OR NT_N) ) in Core NMOS >= 1.0um
    EXT POS14m_GATE POS14m_NW < 1.0 ABUT < 90 SINGULAR REGION 
}

POEN1m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN1m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN1m_POCell = POEN1m_POCellIn AND POEN1m_POCellOut
POEN1m_POMarker = POi AND RRuleAnalog 
POEN1m_PO = ((( POEN1m_POCell OR POEN1m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN1m_GATE = ( GATE_PP AND POEN1m_PO ) NOT OD2
POEN1m_NW = (NWEL NOT OD_33) NOT NTN 
PO.EN.1m { @ Recommmended 1.0V or 1.2V PMOS gate enclosure by ((NW NOT OD2) NOT NT_N) for 3.3V IO process >= 1.0 um
@ Recommmended 1.0V or 1.2V PMOS gate enclosure by (NW NOT NT_N) for 1.8V or 2.5V IO process >= 1.0 um
    ENC POEN1m_GATE POEN1m_NW < 1.0 ABUT < 90 SINGULAR REGION 
}

POEN2m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN2m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN2m_POCell = POEN2m_POCellIn AND POEN2m_POCellOut
POEN2m_POMarker = POi AND RRuleAnalog 
POEN2m_PO = ((( POEN2m_POCell OR POEN2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN2m_GATE = ( GATE_NP AND POEN2m_PO ) AND OD2
POEN2m_NW = OD2 NOT ( NWEL OR NTN) 
PO.EN.2m { @ Gate enclosure by ( OD2 NOT (NW OR NT_N) ) in IO NMOS >= 2.0um
    ENC POEN2m_GATE POEN2m_NW < 2.0 ABUT < 90 SINGULAR REGION 
}

POEN3m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN3m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN3m_POCell = POEN3m_POCellIn AND POEN3m_POCellOut
POEN3m_POMarker = POi AND RRuleAnalog 
POEN3m_PO = ((( POEN3m_POCell OR POEN3m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN3m_GATE =  GATE_PP AND POEN3m_PO
POEN3m_GATE33 = POEN3m_GATE AND OD_33
POEN3m_GATE1825 = POEN3m_GATE AND (OD_25 OR OD_18)

POEN3m_NW = NWEL NOT NTN 
POEN3m_NW33 = POEN3m_NW AND OD_33

PO.EN.3m { @ Recommmended 3.3V PMOS gate enclosure by ((NW AND OD2) NOT NT_N) >= 1.5 um
@ Recommmended 1.8V or 2.5V PMOS gate enclosure by (NW NOT NT_N) >= 1.5 um
    ENC POEN3m_GATE1825 POEN3m_NW < 1.5 ABUT < 90 SINGULAR REGION 
    ENC POEN3m_GATE33 POEN3m_NW33 < 1.5 ABUT < 90 SINGULAR REGION
}


BJT.R.1 { @ RPO needs to cover 0.3um on EM OD edge from OD and STI sides
     X = ( SIZE EMOD BY 0.3 ) NOT ( SIZE EMOD BY -0.3 )
     Y = RPO INTERACT EMOD
     X XOR Y
}

BJT.R.8 { @ {RH OR BJTDMY} enclosure of  Emitter OD >=0.13
   A = RH OR BJTDMY 
   ENC EMOD A < 0.13 ABUT<90 SINGULAR REGION 
   EMOD NOT A 
}  

RES2m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
RES2m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
RES2m_ODCell = RES2m_ODCellIn AND RES2m_ODCellOut
RES2m_ODMarker = ODi AND RRuleAnalog 
RES2m_OD = ((( RES2m_ODCell OR RES2m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RES2m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
RES2m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
RES2m_POCell = RES2m_POCellIn AND RES2m_POCellOut
RES2m_POMarker = POi AND RRuleAnalog 
RES2m_PO = ((( RES2m_POCell OR RES2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RES2m_ODRES = ODRES AND RES2m_OD
RES2m_PORES = PORESg AND RES2m_PO
RES.2m.OD { @ Width >= 0.4um and length >= 0.4um for unsilicided OD resistor
  INT RES2m_ODRES < 0.4 ABUT < 90 SINGULAR REGION
  RES_L = RES2m_ODRES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 0.4
  CHECK_RES = RES2m_ODRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 0.2 - GRID*2 ) INSIDE OF RES2m_ODRES STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  Y = CHECK_RES INTERACT D
  Y NOT INSIDE DIODMY
}

RES.2m.PO { @ Width >= 0.4um and length >= 0.4um for unsilicided PO resistor
  INT RES2m_PORES < 0.4 ABUT < 90 SINGULAR REGION
  RES_L = RES2m_PORES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 0.4
  CHECK_RES = RES2m_PORES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 0.2 - GRID*2 ) INSIDE OF RES2m_PORES STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

NWRODR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRODR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRODR1m_NWCell = NWRODR1m_NWCellIn AND NWRODR1m_NWCellOut
NWRODR1m_NWMarker = NWi AND RRuleAnalog 
NWRODR1m_NW = ((( NWRODR1m_NWCell OR NWRODR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRODR1m_NWRES = ( NWRODR1m_NW AND NWRES ) AND NWDMY
NWROD.R.1m { @ Width >= 1.8um and length >= 20um for NW resistor with OD
  INT NWRODR1m_NWRES < 1.8 ABUT < 90 SINGULAR REGION
  RES_L = NWRODR1m_NWRES COIN INSIDE EDGE NWRODR1m_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRODR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

NWRSTIR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRSTIR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRSTIR1m_NWCell = NWRSTIR1m_NWCellIn AND NWRSTIR1m_NWCellOut
NWRSTIR1m_NWMarker = NWi AND RRuleAnalog 
NWRSTIR1m_NW = ((( NWRSTIR1m_NWCell OR NWRSTIR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRSTIR1m_NWRES = ( NWRSTIR1m_NW AND NWRES_STI ) AND NWDMY
NWRSTI.R.1m { @ Width >= 1.8um and length >= 20um for NW resistor under STI
  INT NWRSTIR1m_NWRES < 1.8 ABUT < 90 SINGULAR REGION
  RES_L = NWRSTIR1m_NWRES COIN INSIDE EDGE NWRSTIR1m_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRSTIR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

#ENDIF






#ELSE
#IFNDEF DFM
DFM_OPTION.ERR1{@ If DFM_ONLY option is enabled, DFM option should be enabled,too.     
  COPY CHIPx
}
#ENDIF
#ENDIF

#IFDEF DFM       // start DFM check


#IFDEF Required
#DEFINE _POS2_            // Systematic(Litho/OPC/Others) and SPICE related 
#DEFINE _POEX2_           // Systematic(Others) and SPICE related 
#DEFINE _POS5_            // Systematic(Litho/OPC) and SPICE related
#DEFINE _POS14_           // Systematic(Others) and SPICE related
#DEFINE _POEN1_           // Systematic(Others) and SPICE related
#DEFINE _POEN2_           // Systematic(Others) and SPICE related
#DEFINE _POEN3_           // Systematic(Others) and SPICE related
#ENDIF


#IFDEF Recommended
// Start of recommended DFM rules    
#DEFINE _OPCR1_           // Systematic(Litho/OPC) related 
#DEFINE _DNWEN1_          // Systematic(Others) related 
#DEFINE _ODW2_            // SPICE related
#DEFINE _ODS1_            // Defect related
#DEFINE _ODS6_            // Systematic(Others) related 
#DEFINE _NWRODS3_         // SPICE related
#DEFINE _NWRODR1_         // SPICE related 
#DEFINE _NWRSTIEN2_       // SPICE related
#DEFINE _NWRSTIR1_        // SPICE related
#DEFINE _POS1_            // Defect related
#DEFINE _POS4_1_          // SPICE related
#DEFINE _POS11_           // Systematic(Litho/OPC) related
#DEFINE _POS13_           // Systematic(Litho/OPC) related 
#DEFINE _RES2_            // SPICE related
#DEFINE _RES8_            // SPICE related
#DEFINE _RES9_            // SPICE related
#DEFINE _VARA1_           // SPICE related
#DEFINE _COEN1_           // Systematic(Litho/OPC) and SPICE related
#DEFINE _COEN3_           // Systematic(Litho/OPC) and SPICE related
#DEFINE _COS3_            // 1st priority, Systematic(Others) and Defect related
#DEFINE _M1S1_            // Defect related
#DEFINE _M1S7_            // Systematic(Others) related
#DEFINE _M1EN1_M1EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA1EN1_VIA1EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M2S1_            // Defect related
#DEFINE _M2S7_            // Systematic(Others) related
#DEFINE _M2EN1_M2EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA2EN1_VIA2EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M3S1_            // Defect related
#DEFINE _M3S7_            // Systematic(Others) related
#DEFINE _M3EN1_M3EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA3EN1_VIA3EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M4S1_            // Defect related
#DEFINE _M4S7_            // Systematic(Others) related
#DEFINE _M4EN1_M4EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _DTCDDN1_         // Systematic(Others) related
// End of recommended DFM rules    
#ENDIF

#IFDEF Guideline
#DEFINE _OPCR2_            // Systematic(Litho/OPC) related
#DEFINE _NWR1_             // Systematic(Other) and SPICE related
#DEFINE _DNWR6_            // Systematic(Other) and SPICE related
#DEFINE _NWRODR3_NWRSTIR3_  // SPICE related
#DEFINE _COS6_             // SPICE related  
#DEFINE _COR5_             // 1st priority, Defect and SPICE related 
#DEFINE _VIA1R9_           // 1st priority, Defect and SPICE related                       
#DEFINE _VIA2R9_           // 1st priority, Defect and SPICE related                       
#DEFINE _VIA3R9_           // 1st priority, Defect and SPICE related                       
#DEFINE _VIA4R5_           // 1st priority, Defect and SPICE related
#DEFINE _VIA5R5_           // 1st priority, Defect and SPICE related
#ENDIF

#IFDEF Analog
// Start of Analog DFM rules 
#DEFINE _POS5m_
#DEFINE _POS6m_
#DEFINE _RES5m_           
#DEFINE _BJTR2_
#DEFINE _BJTR3_
#DEFINE _BJTR4_
#DEFINE _BJTR5_
#DEFINE _BJTR6_
#DEFINE _BJTR7_
#DEFINE _ANR17_
#DEFINE _ANR20_
// End of Analog DFM rules 
#ENDIF

#IFDEF First_priority
#DEFINE _COS3_            // 1st priority, Systematic(Others) and Defect related
#DEFINE _COR5_             // 1st priority, Defect and SPICE related
#DEFINE _M1EN1_M1EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA1EN1_VIA1EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M2EN1_M2EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA1R9_           // 1st priority, Defect and SPICE related
#DEFINE _VIA2EN1_VIA2EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M3EN1_M3EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA2R9_           // 1st priority, Defect and SPICE related
#DEFINE _VIA3EN1_VIA3EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M4EN1_M4EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA3R9_           // 1st priority, Defect and SPICE related
#DEFINE _VIA4R5_           // 1st priority, Defect and SPICE related
#DEFINE _VIA5R5_           // 1st priority, Defect and SPICE related
#ENDIF

#IFDEF Systematic 
#DEFINE _OPCR2_            // Systematic(Litho/OPC) related
#DEFINE _NWR1_             // Systematic(Other) and SPICE related
#DEFINE _DNWR6_            // Systematic(Other) and SPICE related
#DEFINE _POS2_            // Systematic(Litho/OPC/Others) and SPICE related 
#DEFINE _POEX2_           // Systematic(Others) and SPICE related 
#DEFINE _POS5_            // Systematic(Litho/OPC) and SPICE related
#DEFINE _POS14_           // Systematic(Others) and SPICE related
#DEFINE _POEN1_           // Systematic(Others) and SPICE related
#DEFINE _POEN2_           // Systematic(Others) and SPICE related
#DEFINE _POEN3_           // Systematic(Others) and SPICE related
#DEFINE _OPCR1_           // Systematic(Litho/OPC) related 
#DEFINE _DNWEN1_          // Systematic(Others) related 
#DEFINE _ODS6_            // Systematic(Others) related 
#DEFINE _POS11_           // Systematic(Litho/OPC) related
#DEFINE _POS13_           // Systematic(Litho/OPC) related 
#DEFINE _COEN1_           // Systematic(Litho/OPC) and SPICE related
#DEFINE _COEN3_           // Systematic(Litho/OPC) and SPICE related
#DEFINE _COS3_            // 1st priority, Systematic(Others) and Defect related
#DEFINE _M1S7_            // Systematic(Others) related
#DEFINE _M1EN1_M1EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA1EN1_VIA1EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M2S7_            // Systematic(Others) related
#DEFINE _M2EN1_M2EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA2EN1_VIA2EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M3S7_            // Systematic(Others) related
#DEFINE _M3EN1_M3EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA3EN1_VIA3EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M4S7_            // Systematic(Others) related
#DEFINE _M4EN1_M4EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _DTCDDN1_         // Systematic(Others) related
#ENDIF

#IFDEF Defect
#DEFINE _ODS1_            // Defect related
#DEFINE _COS3_            // 1st priority, Systematic(Others) and Defect related
#DEFINE _POS1_            // Defect related
#DEFINE _M1S1_            // Defect related
#DEFINE _COR5_            // 1st priority, Defect and SPICE related 
#DEFINE _VIA1R9_           // 1st priority, Defect and SPICE related
#DEFINE _M2S1_            // Defect related
#DEFINE _VIA2R9_           // 1st priority, Defect and SPICE related
#DEFINE _M3S1_            // Defect related
#DEFINE _VIA3R9_           // 1st priority, Defect and SPICE related
#DEFINE _M4S1_            // Defect related
#DEFINE _VIA4R5_           // 1st priority, Defect and SPICE related
#DEFINE _VIA5R5_           // 1st priority, Defect and SPICE related
#ENDIF

#IFDEF SPICE
#DEFINE _POS2_            // Systematic(Litho/OPC/Others) and SPICE related 
#DEFINE _POEX2_           // Systematic(Others) and SPICE related 
#DEFINE _POS5_            // Systematic(Litho/OPC) and SPICE related
#DEFINE _POS14_           // Systematic(Others) and SPICE related
#DEFINE _POEN1_           // Systematic(Others) and SPICE related
#DEFINE _POEN2_           // Systematic(Others) and SPICE related
#DEFINE _POEN3_           // Systematic(Others) and SPICE related
#DEFINE _ODW2_            // SPICE related
#DEFINE _NWRODS3_         // SPICE related
#DEFINE _NWRODR1_         // SPICE related 
#DEFINE _NWRSTIEN2_       // SPICE related
#DEFINE _NWRSTIR1_        // SPICE related
#DEFINE _POS4_1_          // SPICE related
#DEFINE _RES2_            // SPICE related
#DEFINE _RES8_            // SPICE related
#DEFINE _RES9_            // SPICE related
#DEFINE _VARA1_           // SPICE related
#DEFINE _COEN1_           // Systematic(Litho/OPC) and SPICE related
#DEFINE _COEN3_           // Systematic(Litho/OPC) and SPICE related
#DEFINE _M1EN1_M1EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA1EN1_VIA1EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M2EN1_M2EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA2EN1_VIA2EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M3EN1_M3EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _VIA3EN1_VIA3EN2_ // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _M4EN1_M4EN2_     // 1st priority, Systematic(Litho/OPC) and SPICE related
#DEFINE _NWR1_             // Systematic(Other) and SPICE related
#DEFINE _DNWR6_            // Systematic(Other) and SPICE related
#DEFINE _NWRODR3_NWRSTIR3_  // SPICE related
#DEFINE _COS6_             // SPICE related  
#DEFINE _COR5_             // 1st priority, Defect and SPICE related 
#DEFINE _VIA1R9_           // 1st priority, Defect and SPICE related                       
#DEFINE _VIA2R9_           // 1st priority, Defect and SPICE related                       
#DEFINE _VIA3R9_           // 1st priority, Defect and SPICE related                       
#DEFINE _VIA4R5_           // 1st priority, Defect and SPICE related
#DEFINE _VIA5R5_           // 1st priority, Defect and SPICE related
#ENDIF

#IFDEF _POS2_
#IFDEF GP
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS2_ODCell = POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRequired 
POS2_OD = ((( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS2_GATE_W = POLY INSIDE EDGE POS2_OD
RR:AR:SP:POS2 { @ Recommended gate space in the same OD in GP process >= 0.2
    EXT POS2_GATE_W < 0.2 ABUT < 90 REGION 
}
#ELSE
#IFDEF LP
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS2_ODCell = POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRequired 
POS2_OD = ((( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS2_GATE_W = POLY INSIDE EDGE POS2_OD
RR:AR:SP:POS2 { @ Recommended gate space in the same OD in LP process >= 0.2
    EXT POS2_GATE_W < 0.2 ABUT < 90 REGION 
}
#ELSE
#IFDEF LPG
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS2_ODCell = POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRequired 
POS2_OD = ((( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS2_GATE_W = (POLY INSIDE EDGE POS2_OD) NOT INSIDE EDGE DCO
RR:AR:SP:POS2 { @ Recommended gate space in the same OD in LP process >= 0.2
    EXT POS2_GATE_W < 0.2 ABUT < 90 REGION 
}
#ENDIF
#ENDIF
#ENDIF
#ENDIF

#IFDEF _POEX2_
POEX2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POEX2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POEX2_ODCell = POEX2_ODCellIn AND POEX2_ODCellOut
POEX2_ODMarker = ODi AND RRuleRequired 
POEX2_OD = ((( POEX2_ODCell OR POEX2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

RR:AR:SP:POEX2 { @ Recommended OD extension on PO >= 0.18 um
    (ENC POLY POEX2_OD < 0.18 ABUT < 89.5 SINGULAR OPPOSITE REGION) NOT INSIDE LOGO
}
#ENDIF


GateW2Check = LENGTH GATE_W >= 0.15 
GATE2Check =  GATE WITH EDGE GateW2Check

#IFDEF _POS5_ 
POS5_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POS5_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POS5_POCell = POS5_POCellIn AND POS5_POCellOut
POS5_POMarker = POi AND RRuleRequired 
POS5_PO = ((( POS5_POCell OR POS5_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS5_GateW = (GATE_W COIN INSIDE EDGE POS5_PO) COIN INSIDE EDGE GATE2Check 
POS5_GateWExp = EXPAND EDGE POS5_GateW INSIDE BY GRID EXTEND BY OD_S_1
POS5_GateWExe = POS5_PO COIN INSIDE EDGE POS5_GateWExp


POS5B_A = EXT POS5_GateWExe ODi < 0.1 ABUT<90 OPPOSITE REGION
POS5B_B = EXPAND EDGE POS5_GateW OUTSIDE BY 0.1 
POS5B_C = POS5B_B AND OD
POS5B_D = POS5B_C TOUCH OUTSIDE EDGE POS5B_A
POS5B_E = EXPAND EDGE POS5B_D OUTSIDE BY 0.21 
POS5B_F = EXPAND EDGE POS5B_D OUTSIDE BY 0.005
POS5B_G = POS5B_E AND OD  
POS5B_H = POS5B_G INTERACT POS5B_F     
POS5B_I = POS5B_H NOT TOUCH EDGE POS5B_F 
POS5B_J = POS5B_I INSIDE EDGE OD 

RR:AR:SP:POS5{@ Space to L-shape OD when PO and OD are in the same MOS [channel width (W) >= 0.15 um ] >= 0.10 
@ or Max L-leg length when PO and OD are in the same MOS [channel width (W) >= 0.15 um & J<0.1 ] <= 0.21 
   POS5B_H WITH EDGE POS5B_J
}
#ENDIF 


#IFDEF _POS14_
POS14_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POS14_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POS14_POCell = POS14_POCellIn AND POS14_POCellOut
POS14_POMarker = POi AND RRuleRequired 
POS14_PO = ((( POS14_POCell OR POS14_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS14_GATE = (GATE_NP AND POS14_PO) NOT OD2 
POS14_NW = OD2 OR ( NWEL OR NTN )
RR:AR:SP:POS14 { @ Recommmended 1.0V or 1.2V NMOS gate space to (OD2 OR (NW OR NT_N))  >= 1.0 um
    EXT POS14_GATE POS14_NW < 1.0 ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _POEN1_
POEN1_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POEN1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POEN1_POCell = POEN1_POCellIn AND POEN1_POCellOut
POEN1_POMarker = POi AND RRuleRequired 
POEN1_PO = ((( POEN1_POCell OR POEN1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POEN1_GATE = (GATE_PP AND POEN1_PO) NOT OD2 
POEN1_NW = ( NWEL NOT OD_33 ) NOT NTN

RR:AR:SP:POEN1 { @ Recommmended 1.0V or 1.2V PMOS gate enclosure by ((NW NOT OD2) NOT NT_N) for 3.3V IO process >= 1.0 um
@ Recommmended 1.0V or 1.2V PMOS gate enclosure by (NW NOT NT_N) for 1.8V or 2.5V IO process >= 1.0 um    
    ENC POEN1_GATE POEN1_NW < 1.0 ABUT < 90 SINGULAR REGION
     
}
#ENDIF

#IFDEF _POEN2_
POEN2_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POEN2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POEN2_POCell = POEN2_POCellIn AND POEN2_POCellOut
POEN2_POMarker = POi AND RRuleRequired 
POEN2_PO = ((( POEN2_POCell OR POEN2_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POEN2_GATE = (GATE_NP AND POEN2_PO) AND OD2
POEN2_NW = OD2 NOT ( NWEL OR NTN )
RR:AR:SP:POEN2 { @ Recommmended 1.8V or 2.5V or 3.3V NMOS gate enclosure by (OD2 NOT (NW OR NT_N)) >= 2.0 um
    ENC POEN2_GATE POEN2_NW < 2.0 ABUT < 90 SINGULAR REGION 
}
#ENDIF

#IFDEF _POEN3_
POEN3_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POEN3_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POEN3_POCell = POEN3_POCellIn AND POEN3_POCellOut
POEN3_POMarker = POi AND RRuleRequired 
POEN3_PO = ((( POEN3_POCell OR POEN3_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POEN3_GATE = GATE_PP AND POEN3_PO
POEN3_GATE33 = POEN3_GATE AND OD_33
POEN3_GATE1825 = POEN3_GATE AND (OD_18 OR OD_25)
POEN3_NW   = NWEL NOT NTN
POEN3_NW33 = POEN3_NW AND OD_33
RR:AR:SP:POEN3 { @ Recommmended 3.3V PMOS gate enclosure by ((NW AND OD2) NOT NT_N) >= 1.5 um
@ Recommmended 1.8V or 2.5V PMOS gate enclosure by (NW NOT NT_N) >= 1.5 um    
    ENC POEN3_GATE1825 POEN3_NW < 1.5 ABUT < 90 SINGULAR REGION 
    ENC POEN3_GATE33 POEN3_NW33 < 1.5 ABUT < 90 SINGULAR REGION 
}
#ENDIF 




#IFDEF _OPCR1_
OPCR1_PPCellIn = INSIDE CELL PPi CellsForRRuleRecommended  
OPCR1_PPCellOut = NOT INSIDE CELL PPi ExclCellsForRRuleRecommended 
OPCR1_PPCell = OPCR1_PPCellIn AND OPCR1_PPCellOut
OPCR1_PPMarker = PPi AND RRuleRecommended 
OPCR1_PP = ((( OPCR1_PPCell OR OPCR1_PPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_PP_45ANGLE = OPCR1_PP ANGLE == 45 
RR:RE:S:OPCR1:PP { @ Recommended 45-degree edge length >= 0.27 um for OPC friendly layout
    (LENGTH OPCR1_PP_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_NPCellIn = INSIDE CELL NPi CellsForRRuleRecommended  
OPCR1_NPCellOut = NOT INSIDE CELL NPi ExclCellsForRRuleRecommended 
OPCR1_NPCell = OPCR1_NPCellIn AND OPCR1_NPCellOut
OPCR1_NPMarker = NPi AND RRuleRecommended 
OPCR1_NP = ((( OPCR1_NPCell OR OPCR1_NPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_NP_45ANGLE = OPCR1_NP ANGLE == 45 
RR:RE:S:OPCR1:NP { @ Recommended 45-degree edge length >= 0.27 um for OPC friendly layout
    (LENGTH OPCR1_NP_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_VTHNCellIn = INSIDE CELL VTH_Ni CellsForRRuleRecommended  
OPCR1_VTHNCellOut = NOT INSIDE CELL VTH_Ni ExclCellsForRRuleRecommended 
OPCR1_VTHNCell = OPCR1_VTHNCellIn AND OPCR1_VTHNCellOut
OPCR1_VTHNMarker = VTH_Ni AND RRuleRecommended 
OPCR1_VTHN = ((( OPCR1_VTHNCell OR OPCR1_VTHNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTHN_45ANGLE = OPCR1_VTHN ANGLE == 45 
RR:RE:S:OPCR1:VTHN { @ Recommended 45-degree edge length >= 0.27 um for OPC friendly layout
    (LENGTH OPCR1_VTHN_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_VTHPCellIn = INSIDE CELL VTH_Pi CellsForRRuleRecommended  
OPCR1_VTHPCellOut = NOT INSIDE CELL VTH_Pi ExclCellsForRRuleRecommended 
OPCR1_VTHPCell = OPCR1_VTHPCellIn AND OPCR1_VTHPCellOut
OPCR1_VTHPMarker = VTH_Pi AND RRuleRecommended 
OPCR1_VTHP = ((( OPCR1_VTHPCell OR OPCR1_VTHPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTHP_45ANGLE = OPCR1_VTHP ANGLE == 45 
RR:RE:S:OPCR1:VTHP { @ Recommended 45-degree edge length >= 0.27 um for OPC friendly layout
    (LENGTH OPCR1_VTHP_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_VTLNCellIn = INSIDE CELL VTL_Ni CellsForRRuleRecommended  
OPCR1_VTLNCellOut = NOT INSIDE CELL VTL_Ni ExclCellsForRRuleRecommended 
OPCR1_VTLNCell = OPCR1_VTLNCellIn AND OPCR1_VTLNCellOut
OPCR1_VTLNMarker = VTL_Ni AND RRuleRecommended 
OPCR1_VTLN = ((( OPCR1_VTLNCell OR OPCR1_VTLNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTLN_45ANGLE = OPCR1_VTLN ANGLE == 45 
RR:RE:S:OPCR1:VTLN { @ Recommended 45-degree edge length >= 0.27 um for OPC friendly layout
    (LENGTH OPCR1_VTLN_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_VTLPCellIn = INSIDE CELL VTL_Pi CellsForRRuleRecommended  
OPCR1_VTLPCellOut = NOT INSIDE CELL VTL_Pi ExclCellsForRRuleRecommended 
OPCR1_VTLPCell = OPCR1_VTLPCellIn AND OPCR1_VTLPCellOut
OPCR1_VTLPMarker = VTL_Pi AND RRuleRecommended 
OPCR1_VTLP = ((( OPCR1_VTLPCell OR OPCR1_VTLPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTLP_45ANGLE = OPCR1_VTLP ANGLE == 45 
RR:RE:S:OPCR1:VTLP { @ Recommended 45-degree edge length >= 0.27 um for OPC friendly layout
    (LENGTH OPCR1_VTLP_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE 
}
OPCR1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
OPCR1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
OPCR1_ODCell = OPCR1_ODCellIn AND OPCR1_ODCellOut
OPCR1_ODMarker = ODi AND RRuleRecommended 
OPCR1_OD = ((( OPCR1_ODCell OR OPCR1_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_OD_45ANGLE = OPCR1_OD ANGLE == 45 
RR:RE:S:OPCR1:OD { @ Recommended 45-degree edge length >= 0.27um 
    (LENGTH OPCR1_OD_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
OPCR1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
OPCR1_POCell = OPCR1_POCellIn AND OPCR1_POCellOut
OPCR1_POMarker = POi AND RRuleRecommended 
OPCR1_PO = ((( OPCR1_POCell OR OPCR1_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_PO_45ANGLE = OPCR1_PO ANGLE == 45
RR:RE:S:OPCR1:PO { @ Recommended 45-degree edge length >= 0.27um 
    (LENGTH OPCR1_PO_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
OPCR1_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
OPCR1_M1Cell = OPCR1_M1CellIn AND OPCR1_M1CellOut
OPCR1_M1Marker = M1i AND RRuleRecommended 
OPCR1_M1 = ((( OPCR1_M1Cell OR OPCR1_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_M1_45ANGLE = OPCR1_M1 ANGLE == 45
RR:RE:S:OPCR1:M1 { @ Recommended 45-degree edge length >= 0.27um
    (LENGTH OPCR1_M1_45ANGLE < 0.27) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR1_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
OPCR1_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
OPCR1_M2Cell = OPCR1_M2CellIn AND OPCR1_M2CellOut
OPCR1_M2Marker = M2i AND RRuleRecommended 
OPCR1_M2 = ((OPCR1_M2Cell OR OPCR1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M2_45ANGLE = OPCR1_M2 ANGLE == 45
RR:RE:S:OPCR1:M2 { @ Recommended 45-degree edge length >= 0.27um
    LENGTH OPCR1_M2_45ANGLE < 0.27
}
OPCR1_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
OPCR1_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
OPCR1_M3Cell = OPCR1_M3CellIn AND OPCR1_M3CellOut
OPCR1_M3Marker = M3i AND RRuleRecommended 
OPCR1_M3 = ((OPCR1_M3Cell OR OPCR1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M3_45ANGLE = OPCR1_M3 ANGLE == 45
RR:RE:S:OPCR1:M3 { @ Recommended 45-degree edge length >= 0.27um
    LENGTH OPCR1_M3_45ANGLE < 0.27
}
OPCR1_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
OPCR1_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
OPCR1_M4Cell = OPCR1_M4CellIn AND OPCR1_M4CellOut
OPCR1_M4Marker = M4i AND RRuleRecommended 
OPCR1_M4 = ((OPCR1_M4Cell OR OPCR1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M4_45ANGLE = OPCR1_M4 ANGLE == 45
RR:RE:S:OPCR1:M4 { @ Recommended 45-degree edge length >= 0.27um
    LENGTH OPCR1_M4_45ANGLE < 0.27
}
#ENDIF

#IFDEF _ODS6_
ODS6_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS6_ODCell = ODS6_ODCellIn AND ODS6_ODCellOut
ODS6_ODMarker = ODi AND RRuleRecommended 
ODS6_OD = ((( ODS6_ODCell OR ODS6_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

ODS6Area = AREA ( ODi NOT INTERACT SEALRING ) > BIG_AREA
RR:RE:S:ODS6 { @ Space to large OD [OD area > ^BIG_AREA] >= 0.35 um
    (EXT ODS6Area ODi < 0.35 SPACE ABUT < 90 SINGULAR REGION) INTERACT ODS6_OD
}
#ENDIF

#IFDEF _DNWEN1_
DNWEN1_DNWCellIn = INSIDE CELL DNWi CellsForRRuleRecommended  
DNWEN1_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleRecommended 
DNWEN1_DNWCell = DNWEN1_DNWCellIn AND DNWEN1_DNWCellOut
DNWEN1_DNWMarker = DNWi AND RRuleRecommended 
DNWEN1_DNW = ((( DNWEN1_DNWCell OR DNWEN1_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:DNWEN1 { @ Enclosure by NW >= 1.0um for better noise isolation. 
    ENC DNWEN1_DNW NWEL < 1.0 ABUT < 90 SINGULAR REGION 
    DNWEN1_DNW OUTSIDE EDGE NWEL
}
#ENDIF 




#IFDEF _POS11_
POS11_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS11_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS11_POCell = POS11_POCellIn AND POS11_POCellOut
POS11_POMarker = POi AND RRuleRecommended 
POS11_PO = ((( POS11_POCell OR POS11_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS11_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS11_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS11_ODCell = POS11_ODCellIn AND POS11_ODCellOut
POS11_ODMarker = ODi AND RRuleRecommended 
POS11_OD = ((( POS11_ODCell OR POS11_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS11_GATE = POS11_PO AND POS11_OD
POS11_GATEW = POS11_PO COIN INSIDE EDGE POS11_GATE
POS11_CHECK  = INT [POS11_GATEW] <= 0.08 OPPOSITE
POS11_CHIP = SIZE CHIP BY - ( 1.0 - GRID )
POS11_EDGE1 = POS11_CHECK TOUCH EDGE ( POS11_CHECK INSIDE EDGE POS11_CHIP )
POS11_EXPD = EXPAND EDGE POS11_EDGE1 OUTSIDE BY 1.0
POS11_ALL = ALL_POLY INTERACT POS11_EXPD
POS11_EXT = EXT [POS11_CHECK] POS11_ALL < 1.0 ABUT < 90 OPPOSITE 
RR:RE:S:POS11 { @ Recommended gate space to {PO OR DPO} (for channel length <= 0.08 um)  < 1.0um 
   POS11_EDGE1 NOT COIN INSIDE EDGE POS11_EXT
}
#ENDIF


#IFDEF _POS13_  
POS13_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS13_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS13_POCell = POS13_POCellIn AND POS13_POCellOut
POS13_POMarker = POi AND RRuleRecommended 
POS13_PO = ((( POS13_POCell OR POS13_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS13_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS13_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS13_ODCell = POS13_ODCellIn AND POS13_ODCellOut
POS13_ODMarker = ODi AND RRuleRecommended 
POS13_OD = ((( POS13_ODCell OR POS13_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS13_GATE = POS13_PO AND POS13_OD
POS13_GATEW  = POS13_PO COIN INSIDE EDGE POS13_GATE
POS13_CHECK  = INT [POS13_GATEW] == 0.06 OPPOSITE
POS13_BAD19  = EXT POS13_CHECK ALL_POLY < 0.19 OPPOSITE REGION 
POS13_Ext27  = EXT [POS13_CHECK] ALL_POLY <= 0.27 OPPOSITE 
POS13_Left27 = POS13_CHECK NOT COIN INSIDE EDGE POS13_Ext27
POS13_BAD295 = EXT POS13_Left27 ALL_POLY  < 0.295 OPPOSITE REGION
POS13_Ext39  = EXT [POS13_CHECK] ALL_POLY <= 0.39 OPPOSITE 
POS13_Left39 = POS13_CHECK NOT COIN INSIDE EDGE POS13_Ext39
POS13_BAD455 = EXT POS13_Left39 ALL_POLY  < 0.455 OPPOSITE REGION
POS13_Ext94  = EXT [POS13_CHECK] ALL_POLY <= 0.94 OPPOSITE
POS13_Left94 = POS13_CHECK NOT COIN INSIDE EDGE POS13_Ext94
RR:RE:S:POS13 { @ Recommended gate to poly spacing range (for channel length = 0.06um ) =0.19~0.27/0.295~0.39/0.455~0.94
    ( POS13_BAD19 OR POS13_BAD295 ) OR POS13_BAD455 
     COPY POS13_Left94	
}
#ENDIF


#IFDEF _NWRODS3_
NWRODS3_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRODS3_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRODS3_NWCell = NWRODS3_NWCellIn AND NWRODS3_NWCellOut
NWRODS3_NWMarker = NWi AND RRuleRecommended 
NWRODS3_NW = ((( NWRODS3_NWCell OR NWRODS3_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:NWRODS3 { @ RPO space to CO in NWEL resistor within OD for SPICE model accuracy == 0.3 um
  A = RPO INSIDE EDGE ( NWRES AND NWRODS3_NW ) 
  B = EXPAND EDGE A OUTSIDE BY 0.3
  B AND COWR 
  B NOT INTERACT COWR
}
#ENDIF

#IFDEF _NWRODR1_
NWRODR1_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRODR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRODR1_NWCell = NWRODR1_NWCellIn AND NWRODR1_NWCellOut
NWRODR1_NWMarker = NWi AND RRuleRecommended 
NWRODR1_NW = ((( NWRODR1_NWCell OR NWRODR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

NWRODR1_NWRES = ( NWRODR1_NW AND NWRES ) AND NWDMY
RR:RE:P:NWRODR1 { @ Recommended length >= 20um for NW resistor with OD, for SPICE model accuracy
  RES_L = NWRODR1_NWRES COIN INSIDE EDGE NWRODR1_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRODR1_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
#ENDIF

#IFDEF _NWRSTIEN2_
NWRSTIEN2_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRSTIEN2_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRSTIEN2_NWCell = NWRSTIEN2_NWCellIn AND NWRSTIEN2_NWCellOut
NWRSTIEN2_NWMarker = NWi AND RRuleRecommended 
NWRSTIEN2_NW = ((( NWRSTIEN2_NWCell OR NWRSTIEN2_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:NWRSTIEN2 { @ OD enclosure of CO in NWEL resistor under STI for SPICE model accuracy == 0.3 um
  A = OD INSIDE EDGE ( NWRES_STI AND NWRSTIEN2_NW ) 
  B = EXPAND EDGE A INSIDE BY 0.3
  B NOT INTERACT COWR_STI
}
#ENDIF

#IFDEF _NWRSTIR1_
NWRSTIR1_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRSTIR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRSTIR1_NWCell = NWRSTIR1_NWCellIn AND NWRSTIR1_NWCellOut
NWRSTIR1_NWMarker = NWi AND RRuleRecommended 
NWRSTIR1_NW = ((( NWRSTIR1_NWCell OR NWRSTIR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

NWRSTIR1_NWRES = ( NWRSTIR1_NW AND NWRES_STI ) AND NWDMY
RR:RE:P:NWRSTIR1 { @ Recommended length >= 20um for NW resistor under STI, for SPICE model accuracy
  RES_L = NWRSTIR1_NWRES COIN INSIDE EDGE NWRSTIR1_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRSTIR1_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
#ENDIF // _NWRSTIR1_


#IFDEF _ODW2_
ODW2_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODW2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODW2_ODCell = ODW2_ODCellIn AND ODW2_ODCellOut
ODW2_ODMarker = ODi AND RRuleRecommended 
ODW2_OD = ((( ODW2_ODCell OR ODW2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

ODW2_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
ODW2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
ODW2_POCell = ODW2_POCellIn AND ODW2_POCellOut
ODW2_POMarker = POi AND RRuleRecommended 
ODW2_PO = ((( ODW2_POCell OR ODW2_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

ODW2_GATE_W = ( ODW2_PO INSIDE EDGE ODW2_OD ) NOT INSIDE EDGE OD2
RR:RE:P:ODW2 { @ Recommended Width of MOS (<= 1.2V) >= 0.15 um
    LENGTH ODW2_GATE_W < 0.15
}
#ENDIF

#IFDEF _POS4_1_
POS4_1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
POS4_1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
POS4_1_ODCell = POS4_1_ODCellIn AND POS4_1_ODCellOut
POS4_1_ODMarker = ODi AND RRuleRecommended 
POS4_1_OD = ((( POS4_1_ODCell OR POS4_1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS4_1_GATE  = POLY AND POS4_1_OD
RR:RE:P:POS4_1 { @ Recommended gate space when the area enclosed by L-shape OD and L-shape PO < 0.0196 for PO/OD rounding effect >= 0.2
    ((EXT POS4_1_GATE < 0.2 ABUT < 90 REGION CORNER TO CORNER) INTERACT ODi == 1) INTERACT POi == 1
}
#ENDIF



#IFDEF _RES2_
RES2_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
RES2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
RES2_POCell = RES2_POCellIn AND RES2_POCellOut
RES2_POMarker = POi AND RRuleRecommended 
RES2_PO = ((( RES2_POCell OR RES2_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RES2_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
RES2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
RES2_ODCell = RES2_ODCellIn AND RES2_ODCellOut
RES2_ODMarker = ODi AND RRuleRecommended 
RES2_OD = ((( RES2_ODCell OR RES2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RES2_ODRES = ODRES AND RES2_OD 
RES2_PORES = PORESg AND RES2_PO
RR:RE:P:RES2.OD { @ Recommended width >= 0.4um and length >= 0.4um for unsilicided OD resistor
  INT RES2_ODRES < 0.4 ABUT < 90 SINGULAR REGION
  RES_L = RES2_ODRES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 0.4
  CHECK_RES = RES2_ODRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (0.4/2 - GRID*2) INSIDE OF RES2_ODRES STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  Y = CHECK_RES INTERACT D
  Y NOT INSIDE DIODMY
}
RR:RE:P:RES2.PO { @ Recommended width >= 0.4um and length >= 0.4um for unsilicided PO resistor
  INT RES2_PORES < 0.4 ABUT < 90 SINGULAR REGION
  RES_L = RES2_PORES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 0.4
  CHECK_RES = RES2_PORES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (0.4/2 - GRID*2) INSIDE OF RES2_PORES STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
#ENDIF


#IFDEF _RES8_
RES8_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
RES8_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
RES8_ODCell = RES8_ODCellIn AND RES8_ODCellOut
RES8_ODMarker = ODi AND RRuleRecommended 
RES8_OD = ((( RES8_ODCell OR RES8_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RES8_GATE = GATE AND RES8_OD
RR:RE:P:RES8 { @ RH space to Gate >= 0.185um in source or drain direction for unsilicided OD resistor in the s/d of MOS.
  RH_RES = RH NOT OUTSIDE AYRE
  EXT RH_RES RES8_GATE < 0.185 ABUT < 90 SINGULAR REGION
  RH_RES AND RES8_GATE
  RES8_GATE INSIDE RH // RH can not fully cover GATE
}
#ENDIF

#IFDEF _RES9_
RES9_RHCellIn = INSIDE CELL RH CellsForRRuleRecommended  
RES9_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleRecommended 
RES9_RHCell = RES9_RHCellIn AND RES9_RHCellOut
RES9_RHMarker = RH AND RRuleRecommended 
RES9_RH = ((( RES9_RHCell OR RES9_RHMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:P:RES9 { @ RH enclosure of unsilicided OD/PO resistor >= 0.13um.
   ENC AYRE RES9_RH < 0.13 ABUT < 90 SINGULAR REGION
}
#ENDIF




#IFDEF _COEN1_
COEN1_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN1_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN1_COCell = COEN1_COCellIn AND COEN1_COCellOut
COEN1_COMarker = COi AND RRuleRecommended 
COEN1_CO = ((( COEN1_COCell OR COEN1_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:COEN1 { @ Recommended enclosure by OD >= 0.04
  ENC COEN1_CO OD < 0.04 ABUT < 90 REGION
}
#ENDIF

#IFDEF _COEN3_
COEN3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN3_COCell = COEN3_COCellIn AND COEN3_COCellOut
COEN3_COMarker = COi AND RRuleRecommended 
COEN3_CO = ((( COEN3_COCell OR COEN3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:COEN3 { @ Recommended enclosure by PO [at least two opposite sides] >= 0.06 
  X = RECTANGLE ENCLOSURE COEN3_CO POLY ABUT < 90 SINGULAR GOOD CO_EN_2 0.06 OPPOSITE CO_EN_2 0.06 OPPOSITE
  Y = ENC [X] POLY < 0.06 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF

#IFDEF _COS3_
COS3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COS3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COS3_COCell = COS3_COCellIn AND COS3_COCellOut
COS3_COMarker = COi AND RRuleRecommended 
COS3_CO = ((( COS3_COCell OR COS3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FSD:COS3 { @ Recommended CO space to GATE >= 0.065 
  EXT COS3_CO GATE < 0.065 ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _ODS1_
ODS1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS1_ODCell = ODS1_ODCellIn AND ODS1_ODCellOut
ODS1_ODMarker = ODi AND RRuleRecommended 
ODS1_OD = ((( ODS1_ODCell OR ODS1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:ODS1 { @ Recommended OD space >= 0.14 um
    EXT ODS1_OD < 0.14 ABUT < 90 REGION SINGULAR 
}
#ENDIF


#IFDEF _POS1_
POS1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS1_POCell = POS1_POCellIn AND POS1_POCellOut
POS1_POMarker = POi AND RRuleRecommended 
POS1_PO = ((( POS1_POCell OR POS1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS1Err = EXT [POS1_PO] < 0.15 ABUT < 90
POS1ErrLong = POS1Err NOT TOUCH EDGE GATE  // exclude gate space checking
RR:RE:D:POS1 { @ Recommended PO interconnect space >= 0.15um, to reduce short possibility
    EXT POS1ErrLong < 0.15 ABUT < 90 REGION
}
#ENDIF

#IFDEF _M1S1_
M1S1_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1S1_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1S1_M1Cell = M1S1_M1CellIn AND M1S1_M1CellOut
M1S1_M1Marker = M1i AND RRuleRecommended 
M1S1_M1 = ((( M1S1_M1Cell OR M1S1_M1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:M1S1 { @ Recommended M1 space >= 0.12um
    EXT M1S1_M1 < 0.12 ABUT < 90 SINGULAR REGION 
}
#ENDIF



#IFDEF _M1EN1_M1EN2_
M1EN1_M1EN2_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN1_M1EN2_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN1_M1EN2_COCell = M1EN1_M1EN2_COCellIn AND M1EN1_M1EN2_COCellOut
M1EN1_M1EN2_COMarker = COi AND RRuleRecommended 
M1EN1_M1EN2_CO = ((( M1EN1_M1EN2_COCell OR M1EN1_M1EN2_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:FP:M1EN1_M1EN2 { @ Enclosure of CO at least two opposite sides 0.06 um/Enclosure of CO 0.04 um 
  A = RECTANGLE ENCLOSURE M1EN1_M1EN2_CO M1s ABUT > 0 < 90 GOOD 0 0.06 OPPOSITE 0 0.06 OPPOSITE
  (ENC A M1s < 0.04 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
#ENDIF


#IFDEF _M1S7_
M1S7_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1S7_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1S7_M1Cell = M1S7_M1CellIn AND M1S7_M1CellOut
M1S7_M1Marker = M1i AND RRuleRecommended 
M1S7_M1 = ((M1S7_M1Cell OR M1S7_M1Marker) NOT Block ) NOT excludeRRuleRecommended

M1S7_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1S7_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1S7_DM1Cell = M1S7_DM1CellIn AND M1S7_DM1CellOut
M1S7_DM1Marker = DUM1 AND RRuleRecommended 
M1S7_DM1 = ((M1S7_DM1Cell OR M1S7_DM1Marker) NOT Block ) NOT excludeRRuleRecommended

M1S7_M1x = M1S7_M1 OR M1S7_DM1
M1S7_NOT_M1x = CHIP NOT M1x
M1S7_BIGAREA = AREA M1S7_NOT_M1x > BIG_AREA
M1S7_ERROR = (EXT M1S7_BIGAREA M1S7_NOT_M1x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M1S7_M1x 

RR:RE:S:M1S7 { @ Space between two non-M1 regions 0.35 [ one area > ^BIG_AREA ]
  COPY M1S7_ERROR
}
#ENDIF





#IFDEF _VIA1EN1_VIA1EN2_
VIA1EN1_VIA1EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
VIA1EN1_VIA1EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
VIA1EN1_VIA1EN2_VIA1Cell = VIA1EN1_VIA1EN2_VIA1CellIn AND VIA1EN1_VIA1EN2_VIA1CellOut
VIA1EN1_VIA1EN2_VIA1Marker = VIA1i AND RRuleRecommended 
VIA1EN1_VIA1EN2_VIA1 = ((( VIA1EN1_VIA1EN2_VIA1Cell OR VIA1EN1_VIA1EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA1EN1_VIA1EN2 { @ Enclosure of VIA1 at least two opposite sides 0.07 um/Enclosure of VIA1 0.04 um 
 A = RECTANGLE ENCLOSURE VIA1EN1_VIA1EN2_VIA1 M1i ABUT < 90 SINGULAR GOOD 0 0.07 OPPOSITE 0 0.07 OPPOSITE
 ENC A M1i < 0.04 ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M2EN1_M2EN2_
M2EN1_M2EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
M2EN1_M2EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
M2EN1_M2EN2_VIA1Cell = M2EN1_M2EN2_VIA1CellIn AND M2EN1_M2EN2_VIA1CellOut
M2EN1_M2EN2_VIA1Marker = VIA1i AND RRuleRecommended 
M2EN1_M2EN2_VIA1 = ((( M2EN1_M2EN2_VIA1Cell OR M2EN1_M2EN2_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:M2EN1_M2EN2 { @ Enclosure of VIA1 at least two opposite sides 0.07 um/Enclosure of VIA1 0.04 um 
 A = RECTANGLE ENCLOSURE M2EN1_M2EN2_VIA1 M2 ABUT < 90 SINGULAR GOOD 0 0.07 OPPOSITE 0 0.07 OPPOSITE
 ENC A M2 < 0.04 ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _M2S1_
M2S1_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2S1_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2S1_M2Cell = M2S1_M2CellIn AND M2S1_M2CellOut
M2S1_M2Marker = M2i AND RRuleRecommended 
M2S1_M2 = ((M2S1_M2Cell OR M2S1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M2S1 { @ Recommended M2 space >= 0.13um
  EXT M2S1_M2 < 0.13 ABUT < 90 SINGULAR REGION 

}
#ENDIF



#IFDEF _M2S7_
M2S7_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2S7_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2S7_M2Cell = M2S7_M2CellIn AND M2S7_M2CellOut
M2S7_M2Marker = M2i AND RRuleRecommended 
M2S7_M2 = ((M2S7_M2Cell OR M2S7_M2Marker) NOT Block ) NOT excludeRRuleRecommended

M2S7_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2S7_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2S7_DM2Cell = M2S7_DM2CellIn AND M2S7_DM2CellOut
M2S7_DM2Marker = DUM2 AND RRuleRecommended 
M2S7_DM2 = ((M2S7_DM2Cell OR M2S7_DM2Marker) NOT Block ) NOT excludeRRuleRecommended

M2S7_M2x = M2S7_M2 OR M2S7_DM2
M2S7_NOT_M2x = CHIP NOT M2x
M2S7_BIGAREA = AREA M2S7_NOT_M2x > BIG_AREA
M2S7_ERROR = (EXT M2S7_BIGAREA M2S7_NOT_M2x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M2S7_M2x 

RR:RE:S:M2S7 { @ Space between two non-M2 regions 0.35 [ one area > ^BIG_AREA ]
COPY M2S7_ERROR 
}
#ENDIF 




#IFDEF _VIA2EN1_VIA2EN2_
VIA2EN1_VIA2EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
VIA2EN1_VIA2EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
VIA2EN1_VIA2EN2_VIA2Cell = VIA2EN1_VIA2EN2_VIA2CellIn AND VIA2EN1_VIA2EN2_VIA2CellOut
VIA2EN1_VIA2EN2_VIA2Marker = VIA2i AND RRuleRecommended 
VIA2EN1_VIA2EN2_VIA2 = ((( VIA2EN1_VIA2EN2_VIA2Cell OR VIA2EN1_VIA2EN2_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA2EN1_VIA2EN2 { @ Enclosure of VIA2 at least two opposite sides 0.07 um/Enclosure of VIA2 0.04 um 
 A = RECTANGLE ENCLOSURE VIA2EN1_VIA2EN2_VIA2 M2i ABUT < 90 SINGULAR GOOD 0 0.07 OPPOSITE 0 0.07 OPPOSITE
 ENC A M2i < 0.04 ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M3EN1_M3EN2_
M3EN1_M3EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
M3EN1_M3EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
M3EN1_M3EN2_VIA2Cell = M3EN1_M3EN2_VIA2CellIn AND M3EN1_M3EN2_VIA2CellOut
M3EN1_M3EN2_VIA2Marker = VIA2i AND RRuleRecommended 
M3EN1_M3EN2_VIA2 = ((( M3EN1_M3EN2_VIA2Cell OR M3EN1_M3EN2_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:FP:M3EN1_M3EN2 { @ Enclosure of VIA2 at least two opposite sides 0.07 um/Enclosure of VIA2 0.04 um 
 A = RECTANGLE ENCLOSURE M3EN1_M3EN2_VIA2 M3 ABUT < 90 SINGULAR GOOD 0 0.07 OPPOSITE 0 0.07 OPPOSITE
 ENC A M3 < 0.04 ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _M3S1_
M3S1_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3S1_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3S1_M3Cell = M3S1_M3CellIn AND M3S1_M3CellOut
M3S1_M3Marker = M3i AND RRuleRecommended 
M3S1_M3 = ((M3S1_M3Cell OR M3S1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M3S1 { @ Recommended M3 space >= 0.13um
  EXT M3S1_M3 < 0.13 ABUT < 90 SINGULAR REGION 

}
#ENDIF



#IFDEF _M3S7_
M3S7_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3S7_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3S7_M3Cell = M3S7_M3CellIn AND M3S7_M3CellOut
M3S7_M3Marker = M3i AND RRuleRecommended 
M3S7_M3 = ((M3S7_M3Cell OR M3S7_M3Marker) NOT Block ) NOT excludeRRuleRecommended

M3S7_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3S7_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3S7_DM3Cell = M3S7_DM3CellIn AND M3S7_DM3CellOut
M3S7_DM3Marker = DUM3 AND RRuleRecommended 
M3S7_DM3 = ((M3S7_DM3Cell OR M3S7_DM3Marker) NOT Block ) NOT excludeRRuleRecommended

M3S7_M3x = M3S7_M3 OR M3S7_DM3
M3S7_NOT_M3x = CHIP NOT M3x
M3S7_BIGAREA = AREA M3S7_NOT_M3x > BIG_AREA
M3S7_ERROR = (EXT M3S7_BIGAREA M3S7_NOT_M3x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M3S7_M3x 

RR:RE:S:M3S7 { @ Space between two non-M3 regions 0.35 [ one area > ^BIG_AREA ]
COPY M3S7_ERROR 
}
#ENDIF 




#IFDEF _VIA3EN1_VIA3EN2_
VIA3EN1_VIA3EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
VIA3EN1_VIA3EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
VIA3EN1_VIA3EN2_VIA3Cell = VIA3EN1_VIA3EN2_VIA3CellIn AND VIA3EN1_VIA3EN2_VIA3CellOut
VIA3EN1_VIA3EN2_VIA3Marker = VIA3i AND RRuleRecommended 
VIA3EN1_VIA3EN2_VIA3 = ((VIA3EN1_VIA3EN2_VIA3Cell OR VIA3EN1_VIA3EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:VIA3EN1_VIA3EN2 { @ Enclosure of VIA3 at least two opposite sides 0.07 um/Enclosure of VIA3 0.04 um 
 A = RECTANGLE ENCLOSURE VIA3EN1_VIA3EN2_VIA3 M3i ABUT < 90 SINGULAR GOOD 0 0.07 OPPOSITE 0 0.07 OPPOSITE
 ENC A M3i < 0.04 ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _M4EN1_M4EN2_
M4EN1_M4EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
M4EN1_M4EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
M4EN1_M4EN2_VIA3Cell = M4EN1_M4EN2_VIA3CellIn AND M4EN1_M4EN2_VIA3CellOut
M4EN1_M4EN2_VIA3Marker = VIA3i AND RRuleRecommended 
M4EN1_M4EN2_VIA3 = ((M4EN1_M4EN2_VIA3Cell OR M4EN1_M4EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:FP:M4EN1_M4EN2 { @ Enclosure of VIA3 at least two opposite sides 0.07 um/Enclosure of VIA3 0.04 um 
 A = RECTANGLE ENCLOSURE M4EN1_M4EN2_VIA3 M4 ABUT < 90 SINGULAR GOOD 0 0.07 OPPOSITE 0 0.07 OPPOSITE
 ENC A M4 < 0.04 ABUT < 90 SINGULAR REGION
}
#ENDIF


#IFDEF _M4S1_
M4S1_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4S1_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4S1_M4Cell = M4S1_M4CellIn AND M4S1_M4CellOut
M4S1_M4Marker = M4i AND RRuleRecommended 
M4S1_M4 = ((M4S1_M4Cell OR M4S1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:D:M4S1 { @ Recommended M4 space >= 0.13um
  EXT M4S1_M4 < 0.13 ABUT < 90 SINGULAR REGION 

}
#ENDIF



#IFDEF _M4S7_
M4S7_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4S7_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4S7_M4Cell = M4S7_M4CellIn AND M4S7_M4CellOut
M4S7_M4Marker = M4i AND RRuleRecommended 
M4S7_M4 = ((M4S7_M4Cell OR M4S7_M4Marker) NOT Block ) NOT excludeRRuleRecommended

M4S7_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4S7_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4S7_DM4Cell = M4S7_DM4CellIn AND M4S7_DM4CellOut
M4S7_DM4Marker = DUM4 AND RRuleRecommended 
M4S7_DM4 = ((M4S7_DM4Cell OR M4S7_DM4Marker) NOT Block ) NOT excludeRRuleRecommended

M4S7_M4x = M4S7_M4 OR M4S7_DM4
M4S7_NOT_M4x = CHIP NOT M4x
M4S7_BIGAREA = AREA M4S7_NOT_M4x > BIG_AREA
M4S7_ERROR = (EXT M4S7_BIGAREA M4S7_NOT_M4x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M4S7_M4x 

RR:RE:S:M4S7 { @ Space between two non-M4 regions 0.35 [ one area > ^BIG_AREA ]
COPY M4S7_ERROR 
}
#ENDIF 








#IFDEF FULL_CHIP
#IFDEF _DTCDDN1_
RR:RE:S:DTCDDN1{@ Density of Dummy TCD (2mmx2mm is one unit) >= 80 %
   ALL_WIN = DENSITY CHIP == 4000000  WINDOW 2000 STEP 2000 INSIDE OF LAYER CHIPx 
             [AREA(CHIP)]
   BAD_WIN = DENSITY TCDDMY  == 0 WINDOW 2000 STEP 2000 INSIDE OF LAYER ALL_WIN PRINT DTCD.DN.1.NO_TCDDMY 
   GOOD_WIN = ALL_WIN NOT BAD_WIN
   ERR = DENSITY GOOD_WIN INSIDE OF LAYER ALL_WIN < 0.8 PRINT DTCD.DN.1.density   
   MERGE (ERR AND BAD_WIN)
}
#ENDIF
#ENDIF

#IFDEF _OPCR2_
OPCR2_PPCellIn = INSIDE CELL PPi CellsForRRuleGuideline  
OPCR2_PPCellOut = NOT INSIDE CELL PPi ExclCellsForRRuleGuideline 
OPCR2_PPCell = OPCR2_PPCellIn AND OPCR2_PPCellOut
OPCR2_PPMarker = PPi AND RRuleGuideline 
OPCR2_PP = ((( OPCR2_PPCell OR OPCR2_PPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:PP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH PP < PP_W_1/2) TOUCH INSIDE EDGE OPCR2_PP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_NPCellIn = INSIDE CELL NPi CellsForRRuleGuideline  
OPCR2_NPCellOut = NOT INSIDE CELL NPi ExclCellsForRRuleGuideline 
OPCR2_NPCell = OPCR2_NPCellIn AND OPCR2_NPCellOut
OPCR2_NPMarker = NPi AND RRuleGuideline 
OPCR2_NP = ((( OPCR2_NPCell OR OPCR2_NPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:NP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH NP < NP_W_1/2) TOUCH INSIDE EDGE OPCR2_NP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTHNCellIn = INSIDE CELL VTH_Ni CellsForRRuleGuideline  
OPCR2_VTHNCellOut = NOT INSIDE CELL VTH_Ni ExclCellsForRRuleGuideline 
OPCR2_VTHNCell = OPCR2_VTHNCellIn AND OPCR2_VTHNCellOut
OPCR2_VTHNMarker = VTH_Ni AND RRuleGuideline 
OPCR2_VTHN = ((( OPCR2_VTHNCell OR OPCR2_VTHNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:VTHN { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH VTHNs < VTH_N_W_1/2) TOUCH INSIDE EDGE OPCR2_VTHN) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTHPCellIn = INSIDE CELL VTH_Pi CellsForRRuleGuideline  
OPCR2_VTHPCellOut = NOT INSIDE CELL VTH_Pi ExclCellsForRRuleGuideline 
OPCR2_VTHPCell = OPCR2_VTHPCellIn AND OPCR2_VTHPCellOut
OPCR2_VTHPMarker = VTH_Pi AND RRuleGuideline 
OPCR2_VTHP = ((( OPCR2_VTHPCell OR OPCR2_VTHPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:VTHP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH VTHPs < VTH_P_W_1/2) TOUCH INSIDE EDGE OPCR2_VTHP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTLNCellIn = INSIDE CELL VTL_Ni CellsForRRuleGuideline  
OPCR2_VTLNCellOut = NOT INSIDE CELL VTL_Ni ExclCellsForRRuleGuideline 
OPCR2_VTLNCell = OPCR2_VTLNCellIn AND OPCR2_VTLNCellOut
OPCR2_VTLNMarker = VTL_Ni AND RRuleGuideline 
OPCR2_VTLN = ((( OPCR2_VTLNCell OR OPCR2_VTLNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:VTLN { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH VTLNs < VTL_N_W_1/2) TOUCH INSIDE EDGE OPCR2_VTLN) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTLPCellIn = INSIDE CELL VTL_Pi CellsForRRuleGuideline  
OPCR2_VTLPCellOut = NOT INSIDE CELL VTL_Pi ExclCellsForRRuleGuideline 
OPCR2_VTLPCell = OPCR2_VTLPCellIn AND OPCR2_VTLPCellOut
OPCR2_VTLPMarker = VTL_Pi AND RRuleGuideline 
OPCR2_VTLP = ((( OPCR2_VTLPCell OR OPCR2_VTLPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:VTLP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH VTLPs < VTL_P_W_1/2) TOUCH INSIDE EDGE OPCR2_VTLP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_ODCellIn = INSIDE CELL ODi CellsForRRuleGuideline  
OPCR2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleGuideline 
OPCR2_ODCell = OPCR2_ODCellIn AND OPCR2_ODCellOut
OPCR2_ODMarker = ODi AND RRuleGuideline 
OPCR2_OD = ((( OPCR2_ODCell OR OPCR2_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:OD { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH ODs < OD_W_1/2) TOUCH INSIDE EDGE OPCR2_OD) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_POCellIn = INSIDE CELL POi CellsForRRuleGuideline  
OPCR2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleGuideline 
OPCR2_POCell = OPCR2_POCellIn AND OPCR2_POCellOut
OPCR2_POMarker = POi AND RRuleGuideline 
OPCR2_PO = ((( OPCR2_POCell OR OPCR2_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:PO { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH POLYs < PO_W_1/2) TOUCH INSIDE EDGE OPCR2_PO) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_M1CellIn = INSIDE CELL M1i CellsForRRuleGuideline  
OPCR2_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleGuideline 
OPCR2_M1Cell = OPCR2_M1CellIn AND OPCR2_M1CellOut
OPCR2_M1Marker = M1i AND RRuleGuideline 
OPCR2_M1 = ((( OPCR2_M1Cell OR OPCR2_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:M1 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    ((LENGTH M1s < M1_W_1/2) TOUCH INSIDE EDGE OPCR2_M1) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_M2CellIn = INSIDE CELL M2i CellsForRRuleGuideline  
OPCR2_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleGuideline 
OPCR2_M2Cell = OPCR2_M2CellIn AND OPCR2_M2CellOut
OPCR2_M2Marker = M2i AND RRuleGuideline 
OPCR2_M2 = ((OPCR2_M2Cell OR OPCR2_M2Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:M2 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    (LENGTH M2 < M2_W_1/2) TOUCH INSIDE EDGE OPCR2_M2
}
OPCR2_M3CellIn = INSIDE CELL M3i CellsForRRuleGuideline  
OPCR2_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleGuideline 
OPCR2_M3Cell = OPCR2_M3CellIn AND OPCR2_M3CellOut
OPCR2_M3Marker = M3i AND RRuleGuideline 
OPCR2_M3 = ((OPCR2_M3Cell OR OPCR2_M3Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:M3 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    (LENGTH M3 < M3_W_1/2) TOUCH INSIDE EDGE OPCR2_M3
}
OPCR2_M4CellIn = INSIDE CELL M4i CellsForRRuleGuideline  
OPCR2_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleGuideline 
OPCR2_M4Cell = OPCR2_M4CellIn AND OPCR2_M4CellOut
OPCR2_M4Marker = M4i AND RRuleGuideline 
OPCR2_M4 = ((OPCR2_M4Cell OR OPCR2_M4Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:S:OPCR2:M4 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
    (LENGTH M4 < M4_W_1/2) TOUCH INSIDE EDGE OPCR2_M4
}
#ENDIF


#IFDEF _NWR1_
NWR1_NWCellIn = INSIDE CELL NWi CellsForRRuleGuideline  
NWR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleGuideline 
NWR1_NWCell = NWR1_NWCellIn AND NWR1_NWCellOut
NWR1_NWMarker = NWi AND RRuleGuideline 
NWR1_NW = ((( NWR1_NWCell OR NWR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:SP:NWR1 { @ Recommended not to use floating well
   (((NWi OUTSIDE (NPODi INTERACT COi)) NOT LOGO) NOT INSIDE SRAM_EXCLUDE) INTERACT NWR1_NW
   ((PWELi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE SRAM_EXCLUDE) INTERACT NWR1_NW  
}
#ENDIF

#IFDEF _DNWR6_
DNWR6_DNWCellIn = INSIDE CELL DNWi CellsForRRuleGuideline  
DNWR6_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleGuideline 
DNWR6_DNWCell = DNWR6_DNWCellIn AND DNWR6_DNWCellOut
DNWR6_DNWMarker = DNWi AND RRuleGuideline 
DNWR6_DNW = ((( DNWR6_DNWCell OR DNWR6_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:SP:DNWR6 { @ Recommended not to use floating RW
  ((RWi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE SRAM_EXCLUDE) INTERACT DNWR6_DNW  
}
#ENDIF

#IFDEF _NWRODR3_NWRSTIR3_
NWRODR3_NWDMYCellIn = INSIDE CELL NWDMY CellsForRRuleGuideline  
NWRODR3_NWDMYCellOut = NOT INSIDE CELL NWDMY ExclCellsForRRuleGuideline 
NWRODR3_NWDMYCell = NWRODR3_NWDMYCellIn AND NWRODR3_NWDMYCellOut
NWRODR3_NWDMYMarker = NWDMY AND RRuleGuideline 
NWRODR3_NWDMY = ((( NWRODR3_NWDMYCell OR NWRODR3_NWDMYMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:P:NWRODR3_NWRSTIR3 { @ Recommended to use rectangle shape resistor
  NWRES_BODY = RNWEL AND (NWDMY INTERACT NWRODR3_NWDMY)     
  NOT RECTANGLE NWRES_BODY ORTHOGONAL ONLY 
}
#ENDIF

#IFDEF _COS6_
COS6_ODCellIn = INSIDE CELL ODi CellsForRRuleGuideline  
COS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleGuideline 
COS6_ODCell = COS6_ODCellIn AND COS6_ODCellOut
COS6_ODMarker = ODi AND RRuleGuideline 
COS6_OD = ((( COS6_ODCell OR COS6_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:P:COS6 { @ Recommended to put contacts at both source side and butted well pickup.
  BUTT_SOUR = SD INTERACT (BUTT_PSTP OR BUTT_NSTP)
  (BUTT_PSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_NSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_SOUR INTERACT COS6_OD ) NOT INTERACT COi
}
#ENDIF

#IFDEF _COR5_
COR5_COCellIn = INSIDE CELL COi CellsForRRuleGuideline  
COR5_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleGuideline 
COR5_COCell = COR5_COCellIn AND COR5_COCellOut
COR5_COMarker = COi AND RRuleGuideline 
COR5_CO = ((( COR5_COCell OR COR5_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

RR:GL:FDP:COR5 { @ Recommended to use redundant CO to avoid high Rc whenever layout allows.
  ((FPO1 AND M1) INTERACT COR5_CO == 1) AND COR5_CO
  ((SD AND M1) INTERACT COR5_CO == 1) AND COR5_CO
  ((DSTP AND M1) INTERACT COR5_CO == 1) AND COR5_CO
}
#ENDIF

#IFDEF _VIA1R9_
VIA1R9_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleGuideline  
VIA1R9_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleGuideline 
VIA1R9_VIA1Cell = VIA1R9_VIA1CellIn AND VIA1R9_VIA1CellOut
VIA1R9_VIA1Marker = VIA1i AND RRuleGuideline 
VIA1R9_VIA1 = ((( VIA1R9_VIA1Cell OR VIA1R9_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleGuideline

RR:GL:FDP:VIA1R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M1 AND M2) INTERACT VIA1R9_VIA1 == 1) AND VIA1R9_VIA1 
}
#ENDIF
#IFDEF _VIA2R9_
VIA2R9_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleGuideline  
VIA2R9_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleGuideline 
VIA2R9_VIA2Cell = VIA2R9_VIA2CellIn AND VIA2R9_VIA2CellOut
VIA2R9_VIA2Marker = VIA2i AND RRuleGuideline 
VIA2R9_VIA2 = ((( VIA2R9_VIA2Cell OR VIA2R9_VIA2Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleGuideline

RR:GL:FDP:VIA2R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M2 AND M3) INTERACT VIA2R9_VIA2 == 1) AND VIA2R9_VIA2 
}
#ENDIF
#IFDEF _VIA3R9_
VIA3R9_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleGuideline  
VIA3R9_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleGuideline 
VIA3R9_VIA3Cell = VIA3R9_VIA3CellIn AND VIA3R9_VIA3CellOut
VIA3R9_VIA3Marker = VIA3i AND RRuleGuideline 
VIA3R9_VIA3 = ((VIA3R9_VIA3Cell OR VIA3R9_VIA3Marker) NOT Block ) NOT excludeRRuleGuideline

RR:GL:FDP:VIA3R9{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M3 AND M4) INTERACT VIA3R9_VIA3 == 1) AND VIA3R9_VIA3 
}
#ENDIF
#IFDEF _VIA4R5_
#IFDEF MIXED_SCHEME
VIA4R5_VIA4_OLDCellIn = INSIDE CELL VIA4_OLD CellsForRRuleGuideline  
VIA4R5_VIA4_OLDCellOut = NOT INSIDE CELL VIA4_OLD ExclCellsForRRuleGuideline 
VIA4R5_VIA4_OLDCell = VIA4R5_VIA4_OLDCellIn AND VIA4R5_VIA4_OLDCellOut
VIA4R5_VIA4_OLDMarker = VIA4_OLD AND RRuleGuideline 
VIA4R5_VIA4_OLD = ((VIA4R5_VIA4_OLDCell OR VIA4R5_VIA4_OLDMarker) NOT Block ) NOT excludeRRuleGuideline

VIA4R5_VIA4_NEWCellIn = INSIDE CELL VIA4_NEW CellsForRRuleGuideline  
VIA4R5_VIA4_NEWCellOut = NOT INSIDE CELL VIA4_NEW ExclCellsForRRuleGuideline 
VIA4R5_VIA4_NEWCell = VIA4R5_VIA4_NEWCellIn AND VIA4R5_VIA4_NEWCellOut
VIA4R5_VIA4_NEWMarker = VIA4_NEW AND RRuleGuideline 
VIA4R5_VIA4_NEW = ((VIA4R5_VIA4_NEWCell OR VIA4R5_VIA4_NEWMarker) NOT Block ) NOT excludeRRuleGuideline

VIA4R5_VIA4 = VIA4R5_VIA4_OLD OR VIA4R5_VIA4_NEW
#ELSE
VIA4R5_VIA4CellIn = INSIDE CELL VIA4_NEW CellsForRRuleGuideline  
VIA4R5_VIA4CellOut = NOT INSIDE CELL VIA4_NEW ExclCellsForRRuleGuideline 
VIA4R5_VIA4Cell = VIA4R5_VIA4CellIn AND VIA4R5_VIA4CellOut
VIA4R5_VIA4Marker = VIA4_NEW AND RRuleGuideline 
VIA4R5_VIA4 = ((VIA4R5_VIA4Cell OR VIA4R5_VIA4Marker) NOT Block ) NOT excludeRRuleGuideline

#ENDIF
RR:GL:FDP:VIA4R5{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M4 AND M5) INTERACT VIA4R5_VIA4 == 1) AND VIA4R5_VIA4
}
#ENDIF
#IFDEF _VIA5R5_
#IFDEF MIXED_SCHEME
VIA5R5_VIA5_OLDCellIn = INSIDE CELL VIA5_OLD CellsForRRuleGuideline  
VIA5R5_VIA5_OLDCellOut = NOT INSIDE CELL VIA5_OLD ExclCellsForRRuleGuideline 
VIA5R5_VIA5_OLDCell = VIA5R5_VIA5_OLDCellIn AND VIA5R5_VIA5_OLDCellOut
VIA5R5_VIA5_OLDMarker = VIA5_OLD AND RRuleGuideline 
VIA5R5_VIA5_OLD = ((VIA5R5_VIA5_OLDCell OR VIA5R5_VIA5_OLDMarker) NOT Block ) NOT excludeRRuleGuideline

VIA5R5_VIA5_NEWCellIn = INSIDE CELL VIA5_NEW CellsForRRuleGuideline  
VIA5R5_VIA5_NEWCellOut = NOT INSIDE CELL VIA5_NEW ExclCellsForRRuleGuideline 
VIA5R5_VIA5_NEWCell = VIA5R5_VIA5_NEWCellIn AND VIA5R5_VIA5_NEWCellOut
VIA5R5_VIA5_NEWMarker = VIA5_NEW AND RRuleGuideline 
VIA5R5_VIA5_NEW = ((VIA5R5_VIA5_NEWCell OR VIA5R5_VIA5_NEWMarker) NOT Block ) NOT excludeRRuleGuideline

VIA5R5_VIA5 = VIA5R5_VIA5_OLD OR VIA5R5_VIA5_NEW
#ELSE
VIA5R5_VIA5CellIn = INSIDE CELL VIA5_NEW CellsForRRuleGuideline  
VIA5R5_VIA5CellOut = NOT INSIDE CELL VIA5_NEW ExclCellsForRRuleGuideline 
VIA5R5_VIA5Cell = VIA5R5_VIA5CellIn AND VIA5R5_VIA5CellOut
VIA5R5_VIA5Marker = VIA5_NEW AND RRuleGuideline 
VIA5R5_VIA5 = ((VIA5R5_VIA5Cell OR VIA5R5_VIA5Marker) NOT Block ) NOT excludeRRuleGuideline

#ENDIF
RR:GL:FDP:VIA5R5{@ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M5 AND M6) INTERACT VIA5R5_VIA5 == 1) AND VIA5R5_VIA5
}
#ENDIF

#IFDEF _POS5m_
POS5m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS5m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS5m_POCell = POS5m_POCellIn AND POS5m_POCellOut
POS5m_POMarker = POi AND RRuleAnalog 
POS5m_PO = ((( POS5m_POCell OR POS5m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS5m_GateW = GATE_W COIN INSIDE EDGE POS5m_PO
POS5m_GateWExp = EXPAND EDGE POS5m_GateW INSIDE BY GRID EXTEND BY OD_S_1
POS5m_GateWExe = POS5m_PO COIN INSIDE EDGE POS5m_GateWExp
RR:AN:POS5m { @ Space to L-shape OD when PO and OD are in the same MOS  >= 0.20 um
    EXT POS5m_GateWExe ODi < 0.2 ABUT < 90 OPPOSITE REGION
}
#ENDIF 

#IFDEF _POS6m_
POS6m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
POS6m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
POS6m_ODCell = POS6m_ODCellIn AND POS6m_ODCellOut
POS6m_ODMarker = ODi AND RRuleAnalog 
POS6m_OD = ((( POS6m_ODCell OR POS6m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS6m_GateL = GATE_L COIN INSIDE EDGE POS6m_OD
POS6m_GateLExp = EXPAND EDGE POS6m_GateL INSIDE BY GRID EXTEND BY PO_S_1
POS6m_GateLExe = (POS6m_OD COIN INSIDE EDGE POS6m_GateLExp) TOUCH INSIDE EDGE POS6m_GateL
RR:AN:POS6m { @ L-shape PO Space to OD when PO and OD are in the same MOS  >= 0.10 um
    EXT POS6m_GateLExe POi < 0.1 ABUT < 90 OPPOSITE REGION
}
#ENDIF 



#IFDEF _RES5m_
RES5_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
RES5_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
RES5_POCell = RES5_POCellIn AND RES5_POCellOut
RES5_POMarker = POi AND RRuleAnalog 
RES5_PO = ((( RES5_POCell OR RES5_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RES5_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
RES5_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
RES5_ODCell = RES5_ODCellIn AND RES5_ODCellOut
RES5_ODMarker = ODi AND RRuleAnalog 
RES5_OD = ((( RES5_ODCell OR RES5_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RR:AN:RES5m.OD { @ CO space to unsilicided OD resistor should be equal to 0.22um
  ODR_GATE = (RES5_OD INTERACT GATE) AND ODRES  
  ODR_TRM  = SIZE ODR_GATE BY 0.22 INSIDE OF OD STEP OD_S_1
  ODR_TRM NOT INTERACT CO
  ODR_NOT_GATE = (RES5_OD NOT INTERACT GATE) AND ODRES 
  ODR_TER = RPO COIN INSIDE EDGE ODR_NOT_GATE 
  ODR_TER_EX = EXPAND EDGE ODR_TER OUTSIDE BY 0.22
  ODR_TER_EX NOT INTERACT CO
}
RR:AN:RES5m.PO { @ CO space to unsilicided PO resistor should be equal to 0.22um
  POR_GATE = (RES5_PO INTERACT GATE) AND PORESg 
  POR_TRM = SIZE POR_GATE BY 0.22 INSIDE OF POLY STEP PO_S_1
  POR_TRM NOT INTERACT CO
  POR_NOT_GATE = (RES5_PO NOT INTERACT GATE) AND PORESg 
  POR_TER = RPO COIN INSIDE EDGE POR_NOT_GATE 
  POR_TER_EX = EXPAND EDGE POR_TER OUTSIDE BY 0.22
  POR_TER_EX NOT INTERACT CO
}
#ENDIF

#IFDEF _BJTR2_
BJT.R.2R { @ OD( Emitter size ) si 2x2, 5x5, 10x10 
    X = NOT RECTANGLE EMOD == 2.0 BY == 2.0
    Y = NOT RECTANGLE X == 5.0 BY == 5.0
    NOT RECTANGLE Y == 10.0 BY == 10.0
}
#ENDIF

#IFDEF _BJTR3_
BJT.R.3R { @ NW enclosure of P+OD ( Emitter OD ) for PNP == 3.0um
    X = SIZE PP_EMOD BY 3.0
    Y = NWEL INTERACT PP_EMOD
    X XOR Y
}
#ENDIF

BJT_NW = NWEL AND BJTDMY
BJT_DNW = DNW AND BJTDMY
BJT_RW = BJT_DNW NOT BJT_NW 

#IFDEF _BJTR4_
BJT.R.4R { @ NW space to N+OD ( Emitter OD ) for NPN == 3.0um
    X = SIZE NP_EMOD BY 3.0
    Y = BJT_RW INTERACT NP_EMOD
    X XOR Y
}
#ENDIF

#IFDEF _BJTR5_
BJT.R.5R { @ NW enclosure of DNW for NPN >= 1.0um
    ENC BJT_DNW BJT_NW < 1.0 ABUT < 90 SINGULAR REGION
}
#ENDIF

#IFDEF _BJTR6_
BJT.R.6R { @ DNW enclosure of PW for NPN = 3um
   X = SIZE BJT_RW BY 3
   X XOR BJT_DNW    
}
#ENDIF

#IFDEF _BJTR7_
BJT.R.7R { @ BJTDMY overlap of NT_N, PO, VTH_N, VTH_P, VTL_N, VTL_P, VAR and SRM is not recommended
    BJTDMY AND NTN
    BJTDMY AND POLY
    BJTDMY AND VTHN
    BJTDMY AND VTHP
    BJTDMY AND VTLN
    BJTDMY AND VTLP
    BJTDMY AND VAR
    BJTDMY AND SRM
}
#ENDIF

#IFDEF _ANR17_
ANR17mg_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
ANR17mg_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
ANR17mg_POCell = ANR17mg_POCellIn AND ANR17mg_POCellOut
ANR17mg_POMarker = POi AND RRuleAnalog 
ANR17mg_PO = ((( ANR17mg_POCell OR ANR17mg_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

ANR17mg_PORES = ANR17mg_PO AND PORES
RR:AN:ANR17mg { @ PO resistor on NW for better noise immunity; P+ PO resistor is recommended
    ANR17mg_PORES NOT NWEL
    ANR17mg_PORES NOT  PP
}
#ENDIF

#IFDEF _ANR20_
ANR20mg_VARCellIn = INSIDE CELL VARi CellsForRRuleAnalog  
ANR20mg_VARCellOut = NOT INSIDE CELL VARi ExclCellsForRRuleAnalog 
ANR20mg_VARCell = ANR20mg_VARCellIn AND ANR20mg_VARCellOut
ANR20mg_VARMarker = VARi AND RRuleAnalog 
ANR20mg_VAR = ((ANR20mg_VARCell OR ANR20mg_VARMarker) NOT Block ) NOT excludeRRuleAnalog

ANR20mg_VAROD = ANR20mg_VAR AND OD
RR:AN:ANR20mg { @ Use OD2 MOS varactor is recommended.
   ANR20mg_VAROD NOT OD2
}
#ENDIF

#ENDIF



